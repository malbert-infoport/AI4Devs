//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAjusteLiquidacionClient {
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AjusteLiquidacionView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<AjusteLiquidacionView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: AjusteLiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AjusteLiquidacionView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: AjusteLiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AjusteLiquidacionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class AjusteLiquidacionClient implements IAjusteLiquidacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AjusteLiquidacionView> {
        let url_ = this.baseUrl + "/api/AjusteLiquidacion/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AjusteLiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AjusteLiquidacionView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AjusteLiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjusteLiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<AjusteLiquidacionView> {
        let url_ = this.baseUrl + "/api/AjusteLiquidacion/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AjusteLiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AjusteLiquidacionView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<AjusteLiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjusteLiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: AjusteLiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AjusteLiquidacionView> {
        let url_ = this.baseUrl + "/api/AjusteLiquidacion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AjusteLiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AjusteLiquidacionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<AjusteLiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjusteLiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: AjusteLiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AjusteLiquidacionView> {
        let url_ = this.baseUrl + "/api/AjusteLiquidacion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AjusteLiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AjusteLiquidacionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AjusteLiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AjusteLiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AjusteLiquidacion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAttachmentClient {
    /**
     * Obtiene el contenido de un fichero adjunto en Base64 en base al identificador del adjunto.
     * @param accept_Language (optional) 
     * @return OK
     */
    getAttachmentContent(attachmentId: number, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene una lista de entidades en base a sus identificadores estén o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: AttachmentView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Inserta una lista de entidades. Devuelve la lista de entidades insertadas actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insertMany(body: AttachmentView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: AttachmentView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Actualiza una lista de entidades. Devuelve la lista de entidades actualizadas.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    updateMany(body: AttachmentView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Elimina una lista de entidades en base a sus identificadores estén o no de baja lógica. Devuelve el número de elementos eliminados.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<number>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Da de baja lógica o de alta una lista de entidades en base a sus identificadores. Devuelve el número de elementos actualizados.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicByIds(ids: number[], accept_Language?: string | undefined): Observable<number>;
}

@Injectable()
export class AttachmentClient implements IAttachmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene el contenido de un fichero adjunto en Base64 en base al identificador del adjunto.
     * @param accept_Language (optional) 
     * @return OK
     */
    getAttachmentContent(attachmentId: number, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Attachment/GetAttachmentContent?";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined and cannot be null.");
        else
            url_ += "attachmentId=" + encodeURIComponent("" + attachmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentContent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetAttachmentContent(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Attachment/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Attachment/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una lista de entidades en base a sus identificadores estén o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/Attachment/GetByIds?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processGetByIds(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: AttachmentView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Attachment/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una lista de entidades. Devuelve la lista de entidades insertadas actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insertMany(body: AttachmentView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/Attachment/InsertMany?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processInsertMany(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: AttachmentView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Attachment/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una lista de entidades. Devuelve la lista de entidades actualizadas.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    updateMany(body: AttachmentView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/Attachment/UpdateMany?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Attachment/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una lista de entidades en base a sus identificadores estén o no de baja lógica. Devuelve el número de elementos eliminados.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Attachment/DeleteByIds?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteByIds(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Attachment/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una lista de entidades en base a sus identificadores. Devuelve el número de elementos actualizados.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicByIds(ids: number[], accept_Language?: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Attachment/DeleteUndeleteLogicByIds?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteUndeleteLogicByIds(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAttachmentTypeClient {
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: AttachmentTypeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: AttachmentTypeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<AttachmentTypeView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView[]>;
}

@Injectable()
export class AttachmentTypeClient implements IAttachmentTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: AttachmentTypeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView> {
        let url_ = this.baseUrl + "/api/AttachmentType/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<AttachmentTypeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentTypeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/AttachmentType/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: AttachmentTypeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView> {
        let url_ = this.baseUrl + "/api/AttachmentType/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<AttachmentTypeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentTypeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/AttachmentType/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<AttachmentTypeView> {
        let url_ = this.baseUrl + "/api/AttachmentType/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<AttachmentTypeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentTypeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView> {
        let url_ = this.baseUrl + "/api/AttachmentType/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AttachmentTypeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentTypeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<AttachmentTypeView[]> {
        let url_ = this.baseUrl + "/api/AttachmentType/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentTypeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentTypeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AttachmentTypeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentTypeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IB2BRouterConfiguracionClient {
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: B2BRouterConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: B2BRouterConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView>;
    /**
     * Devuelve el valor desencriptado de una propiedad de la configuración.
     * @param accept_Language (optional) 
     * @return OK
     */
    revealValue(configuracionId: number, valueName: string, accept_Language?: string | undefined): Observable<RevealValueResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConfiguracion(accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView>;
}

@Injectable()
export class B2BRouterConfiguracionClient implements IB2BRouterConfiguracionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: B2BRouterConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView> {
        let url_ = this.baseUrl + "/api/B2BRouterConfiguracion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<B2BRouterConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<B2BRouterConfiguracionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<B2BRouterConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = B2BRouterConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/B2BRouterConfiguracion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView> {
        let url_ = this.baseUrl + "/api/B2BRouterConfiguracion/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<B2BRouterConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<B2BRouterConfiguracionView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<B2BRouterConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = B2BRouterConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: B2BRouterConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView> {
        let url_ = this.baseUrl + "/api/B2BRouterConfiguracion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<B2BRouterConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<B2BRouterConfiguracionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<B2BRouterConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = B2BRouterConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el valor desencriptado de una propiedad de la configuración.
     * @param accept_Language (optional) 
     * @return OK
     */
    revealValue(configuracionId: number, valueName: string, accept_Language?: string | undefined): Observable<RevealValueResponse> {
        let url_ = this.baseUrl + "/api/B2BRouterConfiguracion/RevealValue?";
        if (configuracionId === undefined || configuracionId === null)
            throw new Error("The parameter 'configuracionId' must be defined and cannot be null.");
        else
            url_ += "configuracionId=" + encodeURIComponent("" + configuracionId) + "&";
        if (valueName === undefined || valueName === null)
            throw new Error("The parameter 'valueName' must be defined and cannot be null.");
        else
            url_ += "valueName=" + encodeURIComponent("" + valueName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevealValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevealValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RevealValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RevealValueResponse>;
        }));
    }

    protected processRevealValue(response: HttpResponseBase): Observable<RevealValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevealValueResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConfiguracion(accept_Language?: string | undefined): Observable<B2BRouterConfiguracionView> {
        let url_ = this.baseUrl + "/api/B2BRouterConfiguracion/GetConfiguracion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguracion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguracion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<B2BRouterConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<B2BRouterConfiguracionView>;
        }));
    }

    protected processGetConfiguracion(response: HttpResponseBase): Observable<B2BRouterConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = B2BRouterConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClasificacionContenedorClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionContenedorView[]>;
}

@Injectable()
export class ClasificacionContenedorClient implements IClasificacionContenedorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionContenedorView[]> {
        let url_ = this.baseUrl + "/api/ClasificacionContenedor/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClasificacionContenedorView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClasificacionContenedorView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClasificacionContenedorView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClasificacionContenedorView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClasificacionVehiculoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ClasificacionVehiculoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ClasificacionVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ClasificacionVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView[]>;
}

@Injectable()
export class ClasificacionVehiculoClient implements IClasificacionVehiculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ClasificacionVehiculoView> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClasificacionVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClasificacionVehiculoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ClasificacionVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClasificacionVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClasificacionVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClasificacionVehiculoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ClasificacionVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClasificacionVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ClasificacionVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClasificacionVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClasificacionVehiculoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ClasificacionVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClasificacionVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ClasificacionVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClasificacionVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClasificacionVehiculoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClasificacionVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClasificacionVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ClasificacionVehiculoView[]> {
        let url_ = this.baseUrl + "/api/ClasificacionVehiculo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClasificacionVehiculoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClasificacionVehiculoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClasificacionVehiculoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClasificacionVehiculoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IConceptoClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ConceptoView[]>;
    /**
     * @param tipoTarifaId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getConceptosNoIncluidos(conceptoId: string, tipoTarifaId?: number | undefined, accept_Language?: string | undefined): Observable<ConceptoView[]>;
}

@Injectable()
export class ConceptoClient implements IConceptoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ConceptoView[]> {
        let url_ = this.baseUrl + "/api/Concepto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConceptoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConceptoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ConceptoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConceptoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tipoTarifaId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getConceptosNoIncluidos(conceptoId: string, tipoTarifaId?: number | undefined, accept_Language?: string | undefined): Observable<ConceptoView[]> {
        let url_ = this.baseUrl + "/api/Concepto/GetConceptosNoIncluidos?";
        if (conceptoId === undefined || conceptoId === null)
            throw new Error("The parameter 'conceptoId' must be defined and cannot be null.");
        else
            url_ += "ConceptoId=" + encodeURIComponent("" + conceptoId) + "&";
        if (tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' cannot be null.");
        else if (tipoTarifaId !== undefined)
            url_ += "TipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConceptosNoIncluidos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConceptosNoIncluidos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ConceptoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ConceptoView[]>;
        }));
    }

    protected processGetConceptosNoIncluidos(response: HttpResponseBase): Observable<ConceptoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConceptoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDistanciaClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<DistanciaView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<DistanciaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: DistanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<DistanciaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: DistanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<DistanciaView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class DistanciaClient implements IDistanciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Distancia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<DistanciaView> {
        let url_ = this.baseUrl + "/api/Distancia/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistanciaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<DistanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<DistanciaView> {
        let url_ = this.baseUrl + "/api/Distancia/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistanciaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DistanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: DistanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<DistanciaView> {
        let url_ = this.baseUrl + "/api/Distancia/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistanciaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<DistanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: DistanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<DistanciaView> {
        let url_ = this.baseUrl + "/api/Distancia/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistanciaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DistanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DistanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Distancia/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEmpleadoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpleadoView[]>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<EmpleadoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<EmpleadoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: EmpleadoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpleadoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: EmpleadoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpleadoView>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse>;
}

@Injectable()
export class EmpleadoClient implements IEmpleadoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpleadoView[]> {
        let url_ = this.baseUrl + "/api/Empleado/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpleadoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpleadoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EmpleadoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmpleadoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<EmpleadoView> {
        let url_ = this.baseUrl + "/api/Empleado/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpleadoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpleadoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<EmpleadoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<EmpleadoView> {
        let url_ = this.baseUrl + "/api/Empleado/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpleadoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpleadoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<EmpleadoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: EmpleadoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpleadoView> {
        let url_ = this.baseUrl + "/api/Empleado/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpleadoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpleadoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<EmpleadoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: EmpleadoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpleadoView> {
        let url_ = this.baseUrl + "/api/Empleado/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpleadoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpleadoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EmpleadoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpleadoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Empleado/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Empleado/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Empleado/GetNewAttachmentEntity?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewAttachmentEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewAttachmentEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetNewAttachmentEntity(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/Empleado/GetAllAttachments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (attachmentTypeId === null)
            throw new Error("The parameter 'attachmentTypeId' cannot be null.");
        else if (attachmentTypeId !== undefined)
            url_ += "attachmentTypeId=" + encodeURIComponent("" + attachmentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processGetAllAttachments(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Empleado/GetAllVTAAttachmentsKendoFilter?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVTAAttachmentsKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVTAAttachmentsKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllVTAAttachmentsKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEmpresaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<EmpresaView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<EmpresaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: EmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: EmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaView>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param filtro (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    filterByType(tipoEmpresa: number, filtro?: string | undefined, accept_Language?: string | undefined): Observable<EmpresaView[]>;
    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    gestionarDelete(empresaId: number, tipoEmpresaId: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class EmpresaClient implements IEmpresaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaView[]> {
        let url_ = this.baseUrl + "/api/Empresa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EmpresaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmpresaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Empresa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<EmpresaView> {
        let url_ = this.baseUrl + "/api/Empresa/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<EmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<EmpresaView> {
        let url_ = this.baseUrl + "/api/Empresa/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<EmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: EmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaView> {
        let url_ = this.baseUrl + "/api/Empresa/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<EmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: EmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaView> {
        let url_ = this.baseUrl + "/api/Empresa/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Empresa/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filtro (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    filterByType(tipoEmpresa: number, filtro?: string | undefined, accept_Language?: string | undefined): Observable<EmpresaView[]> {
        let url_ = this.baseUrl + "/api/Empresa/FilterByType?";
        if (tipoEmpresa === undefined || tipoEmpresa === null)
            throw new Error("The parameter 'tipoEmpresa' must be defined and cannot be null.");
        else
            url_ += "tipoEmpresa=" + encodeURIComponent("" + tipoEmpresa) + "&";
        if (filtro === null)
            throw new Error("The parameter 'filtro' cannot be null.");
        else if (filtro !== undefined)
            url_ += "filtro=" + encodeURIComponent("" + filtro) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFilterByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaView[]>;
        }));
    }

    protected processFilterByType(response: HttpResponseBase): Observable<EmpresaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmpresaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    gestionarDelete(empresaId: number, tipoEmpresaId: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Empresa/GestionarDelete?";
        if (empresaId === undefined || empresaId === null)
            throw new Error("The parameter 'empresaId' must be defined and cannot be null.");
        else
            url_ += "empresaId=" + encodeURIComponent("" + empresaId) + "&";
        if (tipoEmpresaId === undefined || tipoEmpresaId === null)
            throw new Error("The parameter 'tipoEmpresaId' must be defined and cannot be null.");
        else
            url_ += "tipoEmpresaId=" + encodeURIComponent("" + tipoEmpresaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGestionarDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGestionarDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGestionarDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return _observableOf(result202);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEmpresa_TipoEmpresaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<Empresa_TipoEmpresaView[]>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class Empresa_TipoEmpresaClient implements IEmpresa_TipoEmpresaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<Empresa_TipoEmpresaView[]> {
        let url_ = this.baseUrl + "/api/Empresa_TipoEmpresa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Empresa_TipoEmpresaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Empresa_TipoEmpresaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Empresa_TipoEmpresaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Empresa_TipoEmpresaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Empresa_TipoEmpresa/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEmpresaDireccionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaDireccionView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class EmpresaDireccionClient implements IEmpresaDireccionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EmpresaDireccionView[]> {
        let url_ = this.baseUrl + "/api/EmpresaDireccion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmpresaDireccionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmpresaDireccionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EmpresaDireccionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmpresaDireccionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/EmpresaDireccion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEstadoCivilClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoCivilView[]>;
}

@Injectable()
export class EstadoCivilClient implements IEstadoCivilClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoCivilView[]> {
        let url_ = this.baseUrl + "/api/EstadoCivil/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EstadoCivilView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EstadoCivilView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EstadoCivilView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EstadoCivilView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEstadoEnvioFacturadorClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoEnvioFacturadorView[]>;
}

@Injectable()
export class EstadoEnvioFacturadorClient implements IEstadoEnvioFacturadorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoEnvioFacturadorView[]> {
        let url_ = this.baseUrl + "/api/EstadoEnvioFacturador/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EstadoEnvioFacturadorView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EstadoEnvioFacturadorView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EstadoEnvioFacturadorView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EstadoEnvioFacturadorView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEstadoMensajeClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoMensajeView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class EstadoMensajeClient implements IEstadoMensajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoMensajeView[]> {
        let url_ = this.baseUrl + "/api/EstadoMensaje/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EstadoMensajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EstadoMensajeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EstadoMensajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EstadoMensajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/EstadoMensaje/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEstadoViajeClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoViajeView[]>;
}

@Injectable()
export class EstadoViajeClient implements IEstadoViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<EstadoViajeView[]> {
        let url_ = this.baseUrl + "/api/EstadoViaje/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EstadoViajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EstadoViajeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EstadoViajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EstadoViajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFacturadorExternoClient {
    /**
     * Envía los datos al facturador externo.
     * @param accept_Language (optional) 
     * @return OK
     */
    enviar(body: EnvioDocumentoExterno, accept_Language?: string | undefined): Observable<ResultadoEnvioFacturadorExterno>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    webhook(proveedorId: Provider, delegacionId: number, accept_Language?: string | undefined): Observable<void>;
}

@Injectable()
export class FacturadorExternoClient implements IFacturadorExternoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Envía los datos al facturador externo.
     * @param accept_Language (optional) 
     * @return OK
     */
    enviar(body: EnvioDocumentoExterno, accept_Language?: string | undefined): Observable<ResultadoEnvioFacturadorExterno> {
        let url_ = this.baseUrl + "/api/FacturadorExterno/Enviar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnviar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnviar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultadoEnvioFacturadorExterno>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultadoEnvioFacturadorExterno>;
        }));
    }

    protected processEnviar(response: HttpResponseBase): Observable<ResultadoEnvioFacturadorExterno> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultadoEnvioFacturadorExterno.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    webhook(proveedorId: Provider, delegacionId: number, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/FacturadorExterno/Webhook?";
        if (proveedorId === undefined || proveedorId === null)
            throw new Error("The parameter 'proveedorId' must be defined and cannot be null.");
        else
            url_ += "proveedorId=" + encodeURIComponent("" + proveedorId) + "&";
        if (delegacionId === undefined || delegacionId === null)
            throw new Error("The parameter 'delegacionId' must be defined and cannot be null.");
        else
            url_ += "delegacionId=" + encodeURIComponent("" + delegacionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processWebhook(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFlujoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<FlujoView[]>;
}

@Injectable()
export class FlujoClient implements IFlujoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Flujo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<FlujoView[]> {
        let url_ = this.baseUrl + "/api/Flujo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlujoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlujoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FlujoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlujoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IInformeDCTClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<InformeDCTView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<InformeDCTView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: InformeDCTView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<InformeDCTView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: InformeDCTView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<InformeDCTView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConfiguracion(accept_Language?: string | undefined): Observable<InformeDCTView>;
}

@Injectable()
export class InformeDCTClient implements IInformeDCTClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/InformeDCT/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<InformeDCTView> {
        let url_ = this.baseUrl + "/api/InformeDCT/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InformeDCTView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InformeDCTView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<InformeDCTView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InformeDCTView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<InformeDCTView> {
        let url_ = this.baseUrl + "/api/InformeDCT/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InformeDCTView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InformeDCTView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<InformeDCTView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InformeDCTView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: InformeDCTView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<InformeDCTView> {
        let url_ = this.baseUrl + "/api/InformeDCT/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InformeDCTView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InformeDCTView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InformeDCTView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InformeDCTView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: InformeDCTView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<InformeDCTView> {
        let url_ = this.baseUrl + "/api/InformeDCT/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InformeDCTView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InformeDCTView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<InformeDCTView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InformeDCTView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InformeDCT/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/InformeDCT/GetAllVTAAttachmentsKendoFilter?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVTAAttachmentsKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVTAAttachmentsKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllVTAAttachmentsKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/InformeDCT/GetAllAttachments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (attachmentTypeId === null)
            throw new Error("The parameter 'attachmentTypeId' cannot be null.");
        else if (attachmentTypeId !== undefined)
            url_ += "attachmentTypeId=" + encodeURIComponent("" + attachmentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processGetAllAttachments(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/InformeDCT/GetNewAttachmentEntity?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewAttachmentEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewAttachmentEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetNewAttachmentEntity(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConfiguracion(accept_Language?: string | undefined): Observable<InformeDCTView> {
        let url_ = this.baseUrl + "/InformeDCT/GetConfiguracion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguracion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguracion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InformeDCTView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InformeDCTView>;
        }));
    }

    protected processGetConfiguracion(response: HttpResponseBase): Observable<InformeDCTView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InformeDCTView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIntCorreoConfiguracionClient {
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: IntCorreoConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: IntCorreoConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Devuelve el valor desencriptado de una propiedad de la configuración.
     * @param accept_Language (optional) 
     * @return OK
     */
    revealValue(configuracionId: number, valueName: string, accept_Language?: string | undefined): Observable<RevealValueResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConfiguracion(accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    sendTestMail(toEmail: string, accept_Language?: string | undefined): Observable<void>;
}

@Injectable()
export class IntCorreoConfiguracionClient implements IIntCorreoConfiguracionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntCorreoConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntCorreoConfiguracionView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<IntCorreoConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntCorreoConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: IntCorreoConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntCorreoConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntCorreoConfiguracionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<IntCorreoConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntCorreoConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: IntCorreoConfiguracionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntCorreoConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntCorreoConfiguracionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IntCorreoConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntCorreoConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Devuelve el valor desencriptado de una propiedad de la configuración.
     * @param accept_Language (optional) 
     * @return OK
     */
    revealValue(configuracionId: number, valueName: string, accept_Language?: string | undefined): Observable<RevealValueResponse> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/RevealValue?";
        if (configuracionId === undefined || configuracionId === null)
            throw new Error("The parameter 'configuracionId' must be defined and cannot be null.");
        else
            url_ += "configuracionId=" + encodeURIComponent("" + configuracionId) + "&";
        if (valueName === undefined || valueName === null)
            throw new Error("The parameter 'valueName' must be defined and cannot be null.");
        else
            url_ += "valueName=" + encodeURIComponent("" + valueName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevealValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevealValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RevealValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RevealValueResponse>;
        }));
    }

    protected processRevealValue(response: HttpResponseBase): Observable<RevealValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RevealValueResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConfiguracion(accept_Language?: string | undefined): Observable<IntCorreoConfiguracionView> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/GetConfiguracion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguracion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguracion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntCorreoConfiguracionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntCorreoConfiguracionView>;
        }));
    }

    protected processGetConfiguracion(response: HttpResponseBase): Observable<IntCorreoConfiguracionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntCorreoConfiguracionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    sendTestMail(toEmail: string, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/IntCorreoConfiguracion/SendTestMail?";
        if (toEmail === undefined || toEmail === null)
            throw new Error("The parameter 'toEmail' must be defined and cannot be null.");
        else
            url_ += "toEmail=" + encodeURIComponent("" + toEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestMail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestMail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestMail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIntegracionClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class IntegracionClient implements IIntegracionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Integracion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIntegracionSecurityCompanyClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: IntegracionSecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: IntegracionSecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class IntegracionSecurityCompanyClient implements IIntegracionSecurityCompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/IntegracionSecurityCompany/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView> {
        let url_ = this.baseUrl + "/api/IntegracionSecurityCompany/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegracionSecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegracionSecurityCompanyView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<IntegracionSecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegracionSecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView> {
        let url_ = this.baseUrl + "/api/IntegracionSecurityCompany/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegracionSecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegracionSecurityCompanyView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<IntegracionSecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegracionSecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: IntegracionSecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView> {
        let url_ = this.baseUrl + "/api/IntegracionSecurityCompany/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegracionSecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegracionSecurityCompanyView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<IntegracionSecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegracionSecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: IntegracionSecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntegracionSecurityCompanyView> {
        let url_ = this.baseUrl + "/api/IntegracionSecurityCompany/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegracionSecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegracionSecurityCompanyView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IntegracionSecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegracionSecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/IntegracionSecurityCompany/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IIntercambioClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<IntercambioView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<IntercambioView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<IntercambioView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: IntercambioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntercambioView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: IntercambioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntercambioView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class IntercambioClient implements IIntercambioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<IntercambioView[]> {
        let url_ = this.baseUrl + "/api/Intercambio/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntercambioView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntercambioView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IntercambioView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IntercambioView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Intercambio/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<IntercambioView> {
        let url_ = this.baseUrl + "/api/Intercambio/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntercambioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntercambioView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<IntercambioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntercambioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<IntercambioView> {
        let url_ = this.baseUrl + "/api/Intercambio/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntercambioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntercambioView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<IntercambioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntercambioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: IntercambioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntercambioView> {
        let url_ = this.baseUrl + "/api/Intercambio/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntercambioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntercambioView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<IntercambioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntercambioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: IntercambioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<IntercambioView> {
        let url_ = this.baseUrl + "/api/Intercambio/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntercambioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntercambioView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IntercambioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntercambioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Intercambio/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILiquidacionClient {
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: LiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LiquidacionView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: LiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LiquidacionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Elimina una lista de entidades en base a sus identificadores estén o no de baja lógica. Devuelve el número de elementos eliminados.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<number>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<LiquidacionView>;
    /**
     * Inserta una lista de entidades. Devuelve la lista de entidades insertadas actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insertMany(body: LiquidacionView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LiquidacionView[]>;
    /**
     * @param fechaDesde (optional) 
     * @param fechaHasta (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    liquidarViajes(viajeIds: number[], fechaDesde?: Date | undefined, fechaHasta?: Date | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param enviarAConductor (optional) 
     * @param nombreFichero (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getDctPdfReport(liquidacionIds: number[], enviarAConductor?: boolean | undefined, nombreFichero?: string | undefined, accept_Language?: string | undefined): Observable<FileResponse>;
}

@Injectable()
export class LiquidacionClient implements ILiquidacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: LiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LiquidacionView> {
        let url_ = this.baseUrl + "/api/Liquidacion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LiquidacionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<LiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: LiquidacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LiquidacionView> {
        let url_ = this.baseUrl + "/api/Liquidacion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LiquidacionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Liquidacion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una lista de entidades en base a sus identificadores estén o no de baja lógica. Devuelve el número de elementos eliminados.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Liquidacion/DeleteByIds?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteByIds(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<LiquidacionView> {
        let url_ = this.baseUrl + "/api/Liquidacion/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LiquidacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LiquidacionView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LiquidacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LiquidacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una lista de entidades. Devuelve la lista de entidades insertadas actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insertMany(body: LiquidacionView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LiquidacionView[]> {
        let url_ = this.baseUrl + "/api/Liquidacion/InsertMany?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LiquidacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LiquidacionView[]>;
        }));
    }

    protected processInsertMany(response: HttpResponseBase): Observable<LiquidacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LiquidacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param fechaDesde (optional) 
     * @param fechaHasta (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    liquidarViajes(viajeIds: number[], fechaDesde?: Date | undefined, fechaHasta?: Date | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Liquidacion/LiquidarViajes?";
        if (viajeIds === undefined || viajeIds === null)
            throw new Error("The parameter 'viajeIds' must be defined and cannot be null.");
        else
            viajeIds && viajeIds.forEach(item => { url_ += "viajeIds=" + encodeURIComponent("" + item) + "&"; });
        if (fechaDesde === null)
            throw new Error("The parameter 'fechaDesde' cannot be null.");
        else if (fechaDesde !== undefined)
            url_ += "fechaDesde=" + encodeURIComponent(fechaDesde ? "" + fechaDesde.toISOString() : "") + "&";
        if (fechaHasta === null)
            throw new Error("The parameter 'fechaHasta' cannot be null.");
        else if (fechaHasta !== undefined)
            url_ += "fechaHasta=" + encodeURIComponent(fechaHasta ? "" + fechaHasta.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLiquidarViajes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLiquidarViajes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processLiquidarViajes(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param enviarAConductor (optional) 
     * @param nombreFichero (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getDctPdfReport(liquidacionIds: number[], enviarAConductor?: boolean | undefined, nombreFichero?: string | undefined, accept_Language?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Liquidacion/GetDctPdfReport?";
        if (liquidacionIds === undefined || liquidacionIds === null)
            throw new Error("The parameter 'liquidacionIds' must be defined and cannot be null.");
        else
            liquidacionIds && liquidacionIds.forEach(item => { url_ += "liquidacionIds=" + encodeURIComponent("" + item) + "&"; });
        if (enviarAConductor === null)
            throw new Error("The parameter 'enviarAConductor' cannot be null.");
        else if (enviarAConductor !== undefined)
            url_ += "enviarAConductor=" + encodeURIComponent("" + enviarAConductor) + "&";
        if (nombreFichero === null)
            throw new Error("The parameter 'nombreFichero' cannot be null.");
        else if (nombreFichero !== undefined)
            url_ += "nombreFichero=" + encodeURIComponent("" + nombreFichero) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDctPdfReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDctPdfReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetDctPdfReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ILocalidadClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<LocalidadView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<LocalidadView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<LocalidadView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: LocalidadView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LocalidadView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: LocalidadView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LocalidadView>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class LocalidadClient implements ILocalidadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<LocalidadView[]> {
        let url_ = this.baseUrl + "/api/Localidad/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalidadView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalidadView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LocalidadView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocalidadView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Localidad/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<LocalidadView> {
        let url_ = this.baseUrl + "/api/Localidad/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalidadView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalidadView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<LocalidadView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalidadView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<LocalidadView> {
        let url_ = this.baseUrl + "/api/Localidad/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalidadView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalidadView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LocalidadView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalidadView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: LocalidadView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LocalidadView> {
        let url_ = this.baseUrl + "/api/Localidad/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalidadView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalidadView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<LocalidadView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalidadView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: LocalidadView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<LocalidadView> {
        let url_ = this.baseUrl + "/api/Localidad/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LocalidadView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LocalidadView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LocalidadView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LocalidadView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Localidad/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMensajeClient {
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<MensajeView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<MensajeView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: MensajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<MensajeView>;
    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: MensajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<MensajeView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    audit(body: MensajeView, accept_Language?: string | undefined): Observable<number>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    procesar(mensajeId: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    asignarSecurityCompany(body: number[], accept_Language?: string | undefined): Observable<void>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getPendingMessages(accept_Language?: string | undefined): Observable<MensajeView[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getJsonFromMessageView(mensajeId: number, tipoAdjunto: EnumTipoAdjunto, accept_Language?: string | undefined): Observable<string>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getListPendingMessageIds(accept_Language?: string | undefined): Observable<number[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    asociarMensajeAViaje(mensajeId: number, viajeId: number, accept_Language?: string | undefined): Observable<void>;
}

@Injectable()
export class MensajeClient implements IMensajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<MensajeView> {
        let url_ = this.baseUrl + "/api/Mensaje/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MensajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MensajeView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<MensajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<MensajeView> {
        let url_ = this.baseUrl + "/api/Mensaje/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MensajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MensajeView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<MensajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: MensajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<MensajeView> {
        let url_ = this.baseUrl + "/api/Mensaje/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MensajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MensajeView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MensajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Mensaje/GetNewAttachmentEntity?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewAttachmentEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewAttachmentEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetNewAttachmentEntity(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/Mensaje/GetAllAttachments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (attachmentTypeId === null)
            throw new Error("The parameter 'attachmentTypeId' cannot be null.");
        else if (attachmentTypeId !== undefined)
            url_ += "attachmentTypeId=" + encodeURIComponent("" + attachmentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processGetAllAttachments(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Mensaje/GetAllVTAAttachmentsKendoFilter?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVTAAttachmentsKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVTAAttachmentsKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllVTAAttachmentsKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: MensajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<MensajeView> {
        let url_ = this.baseUrl + "/api/Mensaje/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MensajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MensajeView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<MensajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MensajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    audit(body: MensajeView, accept_Language?: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Mensaje/Audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAudit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    procesar(mensajeId: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Mensaje/Procesar?";
        if (mensajeId === undefined || mensajeId === null)
            throw new Error("The parameter 'mensajeId' must be defined and cannot be null.");
        else
            url_ += "mensajeId=" + encodeURIComponent("" + mensajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcesar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcesar(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processProcesar(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    asignarSecurityCompany(body: number[], accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Mensaje/AsignarSecurityCompany";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsignarSecurityCompany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsignarSecurityCompany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAsignarSecurityCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getPendingMessages(accept_Language?: string | undefined): Observable<MensajeView[]> {
        let url_ = this.baseUrl + "/api/Mensaje/GetPendingMessages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MensajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MensajeView[]>;
        }));
    }

    protected processGetPendingMessages(response: HttpResponseBase): Observable<MensajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MensajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getJsonFromMessageView(mensajeId: number, tipoAdjunto: EnumTipoAdjunto, accept_Language?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Mensaje/GetJsonFromMessageView?";
        if (mensajeId === undefined || mensajeId === null)
            throw new Error("The parameter 'mensajeId' must be defined and cannot be null.");
        else
            url_ += "mensajeId=" + encodeURIComponent("" + mensajeId) + "&";
        if (tipoAdjunto === undefined || tipoAdjunto === null)
            throw new Error("The parameter 'tipoAdjunto' must be defined and cannot be null.");
        else
            url_ += "tipoAdjunto=" + encodeURIComponent("" + tipoAdjunto) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJsonFromMessageView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJsonFromMessageView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetJsonFromMessageView(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getListPendingMessageIds(accept_Language?: string | undefined): Observable<number[]> {
        let url_ = this.baseUrl + "/api/Mensaje/GetListPendingMessageIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPendingMessageIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPendingMessageIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processGetListPendingMessageIds(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    asociarMensajeAViaje(mensajeId: number, viajeId: number, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Mensaje/AsociarMensajeAViaje?";
        if (mensajeId === undefined || mensajeId === null)
            throw new Error("The parameter 'mensajeId' must be defined and cannot be null.");
        else
            url_ += "mensajeId=" + encodeURIComponent("" + mensajeId) + "&";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsociarMensajeAViaje(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsociarMensajeAViaje(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAsociarMensajeAViaje(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IModoCalculoClient {
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getModoCalculoByTipoServicioTipoTarifa(tipoServicioTarificableId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<ModoCalculoView[]>;
}

@Injectable()
export class ModoCalculoClient implements IModoCalculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getModoCalculoByTipoServicioTipoTarifa(tipoServicioTarificableId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<ModoCalculoView[]> {
        let url_ = this.baseUrl + "/api/ModoCalculo/GetModoCalculoByTipoServicioTipoTarifa?";
        if (tipoServicioTarificableId === undefined || tipoServicioTarificableId === null)
            throw new Error("The parameter 'tipoServicioTarificableId' must be defined and cannot be null.");
        else
            url_ += "TipoServicioTarificableId=" + encodeURIComponent("" + tipoServicioTarificableId) + "&";
        if (tipoTarifaId === undefined || tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' must be defined and cannot be null.");
        else
            url_ += "TipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModoCalculoByTipoServicioTipoTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModoCalculoByTipoServicioTipoTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModoCalculoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModoCalculoView[]>;
        }));
    }

    protected processGetModoCalculoByTipoServicioTipoTarifa(response: HttpResponseBase): Observable<ModoCalculoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModoCalculoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IModoCreacionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ModoCreacionView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class ModoCreacionClient implements IModoCreacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ModoCreacionView[]> {
        let url_ = this.baseUrl + "/api/ModoCreacion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ModoCreacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ModoCreacionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ModoCreacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModoCreacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ModoCreacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPaisClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PaisView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<PaisView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<PaisView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: PaisView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<PaisView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: PaisView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<PaisView>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class PaisClient implements IPaisClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PaisView[]> {
        let url_ = this.baseUrl + "/api/Pais/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaisView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaisView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PaisView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaisView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Pais/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<PaisView> {
        let url_ = this.baseUrl + "/api/Pais/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaisView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaisView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<PaisView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaisView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<PaisView> {
        let url_ = this.baseUrl + "/api/Pais/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaisView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaisView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PaisView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaisView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: PaisView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<PaisView> {
        let url_ = this.baseUrl + "/api/Pais/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaisView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaisView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<PaisView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaisView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: PaisView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<PaisView> {
        let url_ = this.baseUrl + "/api/Pais/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaisView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaisView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PaisView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaisView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Pais/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProvinciaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ProvinciaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ProvinciaView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ProvinciaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ProvinciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ProvinciaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ProvinciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ProvinciaView>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ProvinciaClient implements IProvinciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ProvinciaView[]> {
        let url_ = this.baseUrl + "/api/Provincia/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinciaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinciaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ProvinciaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProvinciaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Provincia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ProvinciaView> {
        let url_ = this.baseUrl + "/api/Provincia/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinciaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ProvinciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ProvinciaView> {
        let url_ = this.baseUrl + "/api/Provincia/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinciaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ProvinciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ProvinciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ProvinciaView> {
        let url_ = this.baseUrl + "/api/Provincia/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinciaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ProvinciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ProvinciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ProvinciaView> {
        let url_ = this.baseUrl + "/api/Provincia/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinciaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ProvinciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProvinciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Provincia/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRecargoClient {
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargosByTarifa(accept_Language?: string | undefined): Observable<RecargoView[]>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: RecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoView>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: RecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<RecargoView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargoByTiposServicioTipoTarifa(tipoServicioTarificableId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<RecargoView[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<RecargoView>;
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class RecargoClient implements IRecargoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargosByTarifa(accept_Language?: string | undefined): Observable<RecargoView[]> {
        let url_ = this.baseUrl + "/api/Recargo/GetRecargosByTarifa";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecargosByTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecargosByTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoView[]>;
        }));
    }

    protected processGetRecargosByTarifa(response: HttpResponseBase): Observable<RecargoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecargoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: RecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoView> {
        let url_ = this.baseUrl + "/api/Recargo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<RecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: RecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoView> {
        let url_ = this.baseUrl + "/api/Recargo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Recargo/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<RecargoView> {
        let url_ = this.baseUrl + "/api/Recargo/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargoByTiposServicioTipoTarifa(tipoServicioTarificableId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<RecargoView[]> {
        let url_ = this.baseUrl + "/api/Recargo/GetRecargoByTiposServicioTipoTarifa?";
        if (tipoServicioTarificableId === undefined || tipoServicioTarificableId === null)
            throw new Error("The parameter 'tipoServicioTarificableId' must be defined and cannot be null.");
        else
            url_ += "TipoServicioTarificableId=" + encodeURIComponent("" + tipoServicioTarificableId) + "&";
        if (tipoTarifaId === undefined || tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' must be defined and cannot be null.");
        else
            url_ += "TipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecargoByTiposServicioTipoTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecargoByTiposServicioTipoTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoView[]>;
        }));
    }

    protected processGetRecargoByTiposServicioTipoTarifa(response: HttpResponseBase): Observable<RecargoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecargoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<RecargoView> {
        let url_ = this.baseUrl + "/api/Recargo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<RecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Recargo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRecargoTipoServicioTarificableClient {
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: RecargoTipoServicioTarificableView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTiposServicioTarificablesPorRecargo(recargoId: number, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: RecargoTipoServicioTarificableView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void>;
}

@Injectable()
export class RecargoTipoServicioTarificableClient implements IRecargoTipoServicioTarificableClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView> {
        let url_ = this.baseUrl + "/api/RecargoTipoServicioTarificable/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoTipoServicioTarificableView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoTipoServicioTarificableView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RecargoTipoServicioTarificableView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoTipoServicioTarificableView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: RecargoTipoServicioTarificableView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView> {
        let url_ = this.baseUrl + "/api/RecargoTipoServicioTarificable/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoTipoServicioTarificableView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoTipoServicioTarificableView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RecargoTipoServicioTarificableView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoTipoServicioTarificableView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTiposServicioTarificablesPorRecargo(recargoId: number, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView[]> {
        let url_ = this.baseUrl + "/api/RecargoTipoServicioTarificable/GetTiposServicioTarificablesPorRecargo?";
        if (recargoId === undefined || recargoId === null)
            throw new Error("The parameter 'recargoId' must be defined and cannot be null.");
        else
            url_ += "RecargoId=" + encodeURIComponent("" + recargoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTiposServicioTarificablesPorRecargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTiposServicioTarificablesPorRecargo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoTipoServicioTarificableView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoTipoServicioTarificableView[]>;
        }));
    }

    protected processGetTiposServicioTarificablesPorRecargo(response: HttpResponseBase): Observable<RecargoTipoServicioTarificableView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecargoTipoServicioTarificableView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView> {
        let url_ = this.baseUrl + "/api/RecargoTipoServicioTarificable/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoTipoServicioTarificableView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoTipoServicioTarificableView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<RecargoTipoServicioTarificableView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoTipoServicioTarificableView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: RecargoTipoServicioTarificableView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<RecargoTipoServicioTarificableView> {
        let url_ = this.baseUrl + "/api/RecargoTipoServicioTarificable/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecargoTipoServicioTarificableView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecargoTipoServicioTarificableView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<RecargoTipoServicioTarificableView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecargoTipoServicioTarificableView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/RecargoTipoServicioTarificable/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISageEmpresaClient {
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SageEmpresaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SageEmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageEmpresaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SageEmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageEmpresaView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class SageEmpresaClient implements ISageEmpresaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SageEmpresaView> {
        let url_ = this.baseUrl + "/api/SageEmpresa/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageEmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageEmpresaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SageEmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageEmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SageEmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageEmpresaView> {
        let url_ = this.baseUrl + "/api/SageEmpresa/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageEmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageEmpresaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<SageEmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageEmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SageEmpresaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageEmpresaView> {
        let url_ = this.baseUrl + "/api/SageEmpresa/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageEmpresaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageEmpresaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SageEmpresaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageEmpresaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SageEmpresa/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISageModoCalculoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SageModoCalculoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SageModoCalculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageModoCalculoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SageModoCalculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageModoCalculoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class SageModoCalculoClient implements ISageModoCalculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/SageModoCalculo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SageModoCalculoView> {
        let url_ = this.baseUrl + "/api/SageModoCalculo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageModoCalculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageModoCalculoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<SageModoCalculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageModoCalculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SageModoCalculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageModoCalculoView> {
        let url_ = this.baseUrl + "/api/SageModoCalculo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageModoCalculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageModoCalculoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<SageModoCalculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageModoCalculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SageModoCalculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageModoCalculoView> {
        let url_ = this.baseUrl + "/api/SageModoCalculo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageModoCalculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageModoCalculoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SageModoCalculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageModoCalculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SageModoCalculo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISageRecargoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SageRecargoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SageRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageRecargoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SageRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageRecargoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class SageRecargoClient implements ISageRecargoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/SageRecargo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SageRecargoView> {
        let url_ = this.baseUrl + "/api/SageRecargo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageRecargoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<SageRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SageRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageRecargoView> {
        let url_ = this.baseUrl + "/api/SageRecargo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageRecargoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<SageRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SageRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SageRecargoView> {
        let url_ = this.baseUrl + "/api/SageRecargo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SageRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SageRecargoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SageRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SageRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SageRecargo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityClient {
    /**
     * Obtiene los permisos para autorizar al usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    getPermissions(accept_Language?: string | undefined): Observable<UserContext>;
    /**
     * Elimina la cache de los ReferenceTokens activos y los permisos de usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    cleanCache(accept_Language?: string | undefined): Observable<void>;
}

@Injectable()
export class SecurityClient implements ISecurityClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene los permisos para autorizar al usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    getPermissions(accept_Language?: string | undefined): Observable<UserContext> {
        let url_ = this.baseUrl + "/api/Security/GetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserContext>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserContext>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<UserContext> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserContext.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina la cache de los ReferenceTokens activos y los permisos de usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    cleanCache(accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Security/CleanCache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCleanCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityCompanyClient {
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyView>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyView[]>;
}

@Injectable()
export class SecurityCompanyClient implements ISecurityCompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyView> {
        let url_ = this.baseUrl + "/api/SecurityCompany/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyView> {
        let url_ = this.baseUrl + "/api/SecurityCompany/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyView[]> {
        let url_ = this.baseUrl + "/api/SecurityCompany/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SecurityCompanyView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityCompanyView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityCompanyConfigurationAdditionalClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView[]>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SecurityCompanyConfigurationAdditionalView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityCompanyConfigurationAdditionalView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class SecurityCompanyConfigurationAdditionalClient implements ISecurityCompanyConfigurationAdditionalClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView[]> {
        let url_ = this.baseUrl + "/api/SecurityCompanyConfigurationAdditional/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyConfigurationAdditionalView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyConfigurationAdditionalView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SecurityCompanyConfigurationAdditionalView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityCompanyConfigurationAdditionalView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView> {
        let url_ = this.baseUrl + "/api/SecurityCompanyConfigurationAdditional/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SecurityCompanyConfigurationAdditionalView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityCompanyConfigurationAdditionalView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView> {
        let url_ = this.baseUrl + "/api/SecurityCompanyConfigurationAdditional/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<SecurityCompanyConfigurationAdditionalView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityCompanyConfigurationAdditionalView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SecurityCompanyConfigurationAdditionalView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView> {
        let url_ = this.baseUrl + "/api/SecurityCompanyConfigurationAdditional/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<SecurityCompanyConfigurationAdditionalView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityCompanyConfigurationAdditionalView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityCompanyConfigurationAdditionalView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityCompanyConfigurationAdditionalView> {
        let url_ = this.baseUrl + "/api/SecurityCompanyConfigurationAdditional/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityCompanyConfigurationAdditionalView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SecurityCompanyConfigurationAdditionalView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityCompanyConfigurationAdditionalView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SecurityCompanyConfigurationAdditional/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityProfileClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SecurityProfileView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SecurityProfileView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SecurityProfileView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityProfileView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityProfileView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityProfileView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class SecurityProfileClient implements ISecurityProfileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/SecurityProfile/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<SecurityProfileView> {
        let url_ = this.baseUrl + "/api/SecurityProfile/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityProfileView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityProfileView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SecurityProfileView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityProfileView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SecurityProfileView> {
        let url_ = this.baseUrl + "/api/SecurityProfile/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityProfileView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityProfileView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<SecurityProfileView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityProfileView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SecurityProfileView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityProfileView> {
        let url_ = this.baseUrl + "/api/SecurityProfile/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityProfileView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityProfileView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<SecurityProfileView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityProfileView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityProfileView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityProfileView> {
        let url_ = this.baseUrl + "/api/SecurityProfile/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityProfileView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityProfileView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SecurityProfileView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityProfileView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SecurityProfile/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityUserConfigurationClient {
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityUserConfigurationView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityUserConfigurationView>;
    /**
     * Obtiene la configuración del usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    getUserConfiguration(accept_Language?: string | undefined): Observable<SecurityUserConfigurationView>;
}

@Injectable()
export class SecurityUserConfigurationClient implements ISecurityUserConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityUserConfigurationView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityUserConfigurationView> {
        let url_ = this.baseUrl + "/api/SecurityUserConfiguration/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityUserConfigurationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityUserConfigurationView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SecurityUserConfigurationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserConfigurationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la configuración del usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    getUserConfiguration(accept_Language?: string | undefined): Observable<SecurityUserConfigurationView> {
        let url_ = this.baseUrl + "/api/SecurityUserConfiguration/GetUserConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityUserConfigurationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityUserConfigurationView>;
        }));
    }

    protected processGetUserConfiguration(response: HttpResponseBase): Observable<SecurityUserConfigurationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserConfigurationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityUserGridConfigurationClient {
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SecurityUserGridConfigurationView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityUserGridConfigurationView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene la lista de configuraciones de grid para una entidad del usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    getUserGridConfigurations(entityName: string, accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView[]>;
}

@Injectable()
export class SecurityUserGridConfigurationClient implements ISecurityUserGridConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView> {
        let url_ = this.baseUrl + "/api/SecurityUserGridConfiguration/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityUserGridConfigurationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityUserGridConfigurationView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<SecurityUserGridConfigurationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserGridConfigurationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: SecurityUserGridConfigurationView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView> {
        let url_ = this.baseUrl + "/api/SecurityUserGridConfiguration/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityUserGridConfigurationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityUserGridConfigurationView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<SecurityUserGridConfigurationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserGridConfigurationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: SecurityUserGridConfigurationView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView> {
        let url_ = this.baseUrl + "/api/SecurityUserGridConfiguration/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityUserGridConfigurationView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityUserGridConfigurationView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<SecurityUserGridConfigurationView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserGridConfigurationView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/SecurityUserGridConfiguration/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de configuraciones de grid para una entidad del usuario.
     * @param accept_Language (optional) 
     * @return OK
     */
    getUserGridConfigurations(entityName: string, accept_Language?: string | undefined): Observable<SecurityUserGridConfigurationView[]> {
        let url_ = this.baseUrl + "/api/SecurityUserGridConfiguration/GetUserGridConfigurations?";
        if (entityName === undefined || entityName === null)
            throw new Error("The parameter 'entityName' must be defined and cannot be null.");
        else
            url_ += "entityName=" + encodeURIComponent("" + entityName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserGridConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserGridConfigurations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityUserGridConfigurationView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityUserGridConfigurationView[]>;
        }));
    }

    protected processGetUserGridConfigurations(response: HttpResponseBase): Observable<SecurityUserGridConfigurationView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityUserGridConfigurationView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISecurityVersionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityVersionView[]>;
}

@Injectable()
export class SecurityVersionClient implements ISecurityVersionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<SecurityVersionView[]> {
        let url_ = this.baseUrl + "/api/SecurityVersion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityVersionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityVersionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SecurityVersionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityVersionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITarifaClient {
    /**
     * @param tarifaId (optional) 
     * @param mantenerCambiosUsuario (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    calcularTarifa(viajeId: number, tipoTarifaId: number, tarifaId?: number | undefined, mantenerCambiosUsuario?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    copiarTarifa(tarifaId: number, body: any, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    crearNuevaVigenciaTarifa(body: TarifaView, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewValidityEntity(versionKey: string, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getValidityEntity(versionKey: string, date: Date, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllValidity(date: Date, includeDeleted: boolean, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView[]>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllValidityKendoFilter(date: Date, includeDeleted: boolean, body: KendoGridFilter, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TarifaClient implements ITarifaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param tarifaId (optional) 
     * @param mantenerCambiosUsuario (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    calcularTarifa(viajeId: number, tipoTarifaId: number, tarifaId?: number | undefined, mantenerCambiosUsuario?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/CalcularTarifa?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (tipoTarifaId === undefined || tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' must be defined and cannot be null.");
        else
            url_ += "tipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        if (tarifaId === null)
            throw new Error("The parameter 'tarifaId' cannot be null.");
        else if (tarifaId !== undefined)
            url_ += "tarifaId=" + encodeURIComponent("" + tarifaId) + "&";
        if (mantenerCambiosUsuario === null)
            throw new Error("The parameter 'mantenerCambiosUsuario' cannot be null.");
        else if (mantenerCambiosUsuario !== undefined)
            url_ += "mantenerCambiosUsuario=" + encodeURIComponent("" + mantenerCambiosUsuario) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcularTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcularTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarifaView>;
        }));
    }

    protected processCalcularTarifa(response: HttpResponseBase): Observable<ViajeTarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    copiarTarifa(tarifaId: number, body: any, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/CopiarTarifa?";
        if (tarifaId === undefined || tarifaId === null)
            throw new Error("The parameter 'tarifaId' must be defined and cannot be null.");
        else
            url_ += "TarifaId=" + encodeURIComponent("" + tarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopiarTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopiarTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processCopiarTarifa(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    crearNuevaVigenciaTarifa(body: TarifaView, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/CrearNuevaVigenciaTarifa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCrearNuevaVigenciaTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCrearNuevaVigenciaTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processCrearNuevaVigenciaTarifa(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Tarifa/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewValidityEntity(versionKey: string, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/GetNewValidityEntity?";
        if (versionKey === undefined || versionKey === null)
            throw new Error("The parameter 'versionKey' must be defined and cannot be null.");
        else
            url_ += "VersionKey=" + encodeURIComponent("" + versionKey) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewValidityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewValidityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processGetNewValidityEntity(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getValidityEntity(versionKey: string, date: Date, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView> {
        let url_ = this.baseUrl + "/api/Tarifa/GetValidityEntity?";
        if (versionKey === undefined || versionKey === null)
            throw new Error("The parameter 'versionKey' must be defined and cannot be null.");
        else
            url_ += "VersionKey=" + encodeURIComponent("" + versionKey) + "&";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView>;
        }));
    }

    protected processGetValidityEntity(response: HttpResponseBase): Observable<TarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllValidity(date: Date, includeDeleted: boolean, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaView[]> {
        let url_ = this.baseUrl + "/api/Tarifa/GetAllValidity?";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (includeDeleted === undefined || includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' must be defined and cannot be null.");
        else
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValidity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValidity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaView[]>;
        }));
    }

    protected processGetAllValidity(response: HttpResponseBase): Observable<TarifaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TarifaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllValidityKendoFilter(date: Date, includeDeleted: boolean, body: KendoGridFilter, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Tarifa/GetAllValidityKendoFilter?";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined and cannot be null.");
        else
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
        if (includeDeleted === undefined || includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' must be defined and cannot be null.");
        else
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValidityKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValidityKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllValidityKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITarifaCalculoDetalleConceptoClient {
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getModoCalculoConceptosByTipoServicioTarificableModoCalculo(tipoServicioTarificableId: number, modoCalculoId: number, accept_Language?: string | undefined): Observable<TarifaCalculoDetalleConceptoView[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getCondicionAplicacion(body: TarifaCalculoDetalleConceptoView[], accept_Language?: string | undefined): Observable<string>;
}

@Injectable()
export class TarifaCalculoDetalleConceptoClient implements ITarifaCalculoDetalleConceptoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getModoCalculoConceptosByTipoServicioTarificableModoCalculo(tipoServicioTarificableId: number, modoCalculoId: number, accept_Language?: string | undefined): Observable<TarifaCalculoDetalleConceptoView[]> {
        let url_ = this.baseUrl + "/api/TarifaCalculoDetalleConcepto/GetModoCalculoConceptosByTipoServicioTarificableModoCalculo?";
        if (tipoServicioTarificableId === undefined || tipoServicioTarificableId === null)
            throw new Error("The parameter 'tipoServicioTarificableId' must be defined and cannot be null.");
        else
            url_ += "TipoServicioTarificableId=" + encodeURIComponent("" + tipoServicioTarificableId) + "&";
        if (modoCalculoId === undefined || modoCalculoId === null)
            throw new Error("The parameter 'modoCalculoId' must be defined and cannot be null.");
        else
            url_ += "ModoCalculoId=" + encodeURIComponent("" + modoCalculoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModoCalculoConceptosByTipoServicioTarificableModoCalculo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModoCalculoConceptosByTipoServicioTarificableModoCalculo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaCalculoDetalleConceptoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaCalculoDetalleConceptoView[]>;
        }));
    }

    protected processGetModoCalculoConceptosByTipoServicioTarificableModoCalculo(response: HttpResponseBase): Observable<TarifaCalculoDetalleConceptoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TarifaCalculoDetalleConceptoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getCondicionAplicacion(body: TarifaCalculoDetalleConceptoView[], accept_Language?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/TarifaCalculoDetalleConcepto/GetCondicionAplicacion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCondicionAplicacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCondicionAplicacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCondicionAplicacion(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITarifaRecargoDetalleClient {
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getByIds(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaRecargoDetalleView[]>;
}

@Injectable()
export class TarifaRecargoDetalleClient implements ITarifaRecargoDetalleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getByIds(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaRecargoDetalleView[]> {
        let url_ = this.baseUrl + "/api/TarifaRecargoDetalle/GetByIds?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaRecargoDetalleView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaRecargoDetalleView[]>;
        }));
    }

    protected processGetByIds(response: HttpResponseBase): Observable<TarifaRecargoDetalleView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TarifaRecargoDetalleView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITarifaRecargoDetalleConceptoClient {
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargoConceptosByTipoServicioTarificableRecargo(tipoServicioTarificableId: number, recargoId: number, accept_Language?: string | undefined): Observable<TarifaRecargoDetalleConceptoView[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getCondicionAplicacion(body: TarifaRecargoDetalleConceptoView[], accept_Language?: string | undefined): Observable<string>;
}

@Injectable()
export class TarifaRecargoDetalleConceptoClient implements ITarifaRecargoDetalleConceptoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargoConceptosByTipoServicioTarificableRecargo(tipoServicioTarificableId: number, recargoId: number, accept_Language?: string | undefined): Observable<TarifaRecargoDetalleConceptoView[]> {
        let url_ = this.baseUrl + "/api/TarifaRecargoDetalleConcepto/GetRecargoConceptosByTipoServicioTarificableRecargo?";
        if (tipoServicioTarificableId === undefined || tipoServicioTarificableId === null)
            throw new Error("The parameter 'tipoServicioTarificableId' must be defined and cannot be null.");
        else
            url_ += "TipoServicioTarificableId=" + encodeURIComponent("" + tipoServicioTarificableId) + "&";
        if (recargoId === undefined || recargoId === null)
            throw new Error("The parameter 'recargoId' must be defined and cannot be null.");
        else
            url_ += "RecargoId=" + encodeURIComponent("" + recargoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecargoConceptosByTipoServicioTarificableRecargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecargoConceptosByTipoServicioTarificableRecargo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaRecargoDetalleConceptoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaRecargoDetalleConceptoView[]>;
        }));
    }

    protected processGetRecargoConceptosByTipoServicioTarificableRecargo(response: HttpResponseBase): Observable<TarifaRecargoDetalleConceptoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TarifaRecargoDetalleConceptoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getCondicionAplicacion(body: TarifaRecargoDetalleConceptoView[], accept_Language?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/TarifaRecargoDetalleConcepto/GetCondicionAplicacion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCondicionAplicacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCondicionAplicacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCondicionAplicacion(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITarifaServicioClient {
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TarifaServicioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaServicioView>;
    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TarifaServicioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaServicioView>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void>;
    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaServicioView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TarifaServicioView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTarifaServicioByTarifa(tarifaId: number, accept_Language?: string | undefined): Observable<TarifaServicioView[]>;
}

@Injectable()
export class TarifaServicioClient implements ITarifaServicioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TarifaServicioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaServicioView> {
        let url_ = this.baseUrl + "/api/TarifaServicio/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaServicioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaServicioView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<TarifaServicioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaServicioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TarifaServicioView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TarifaServicioView> {
        let url_ = this.baseUrl + "/api/TarifaServicio/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "ReloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaServicioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaServicioView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TarifaServicioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaServicioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TarifaServicio/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TarifaServicioView> {
        let url_ = this.baseUrl + "/api/TarifaServicio/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaServicioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaServicioView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TarifaServicioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaServicioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TarifaServicioView> {
        let url_ = this.baseUrl + "/api/TarifaServicio/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaServicioView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaServicioView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<TarifaServicioView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TarifaServicioView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTarifaServicioByTarifa(tarifaId: number, accept_Language?: string | undefined): Observable<TarifaServicioView[]> {
        let url_ = this.baseUrl + "/api/TarifaServicio/GetTarifaServicioByTarifa?";
        if (tarifaId === undefined || tarifaId === null)
            throw new Error("The parameter 'tarifaId' must be defined and cannot be null.");
        else
            url_ += "TarifaId=" + encodeURIComponent("" + tarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTarifaServicioByTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTarifaServicioByTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TarifaServicioView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TarifaServicioView[]>;
        }));
    }

    protected processGetTarifaServicioByTarifa(response: HttpResponseBase): Observable<TarifaServicioView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TarifaServicioView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoBultoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoBultoView[]>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TipoBultoView>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TipoBultoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoBultoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TipoBultoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoBultoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TipoBultoView>;
}

@Injectable()
export class TipoBultoClient implements ITipoBultoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoBultoView[]> {
        let url_ = this.baseUrl + "/api/TipoBulto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoBultoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoBultoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoBultoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoBultoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TipoBultoView> {
        let url_ = this.baseUrl + "/api/TipoBulto/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoBultoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoBultoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TipoBultoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoBultoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoBulto/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TipoBultoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoBultoView> {
        let url_ = this.baseUrl + "/api/TipoBulto/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoBultoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoBultoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<TipoBultoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoBultoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TipoBultoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoBultoView> {
        let url_ = this.baseUrl + "/api/TipoBulto/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoBultoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoBultoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TipoBultoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoBultoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TipoBulto/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TipoBultoView> {
        let url_ = this.baseUrl + "/api/TipoBulto/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoBultoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoBultoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<TipoBultoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoBultoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoCarnetClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCarnetView[]>;
}

@Injectable()
export class TipoCarnetClient implements ITipoCarnetClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCarnetView[]> {
        let url_ = this.baseUrl + "/api/TipoCarnet/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoCarnetView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoCarnetView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoCarnetView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoCarnetView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoCodigoISOClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TipoCodigoISOView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TipoCodigoISOView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TipoCodigoISOView>;
}

@Injectable()
export class TipoCodigoISOClient implements ITipoCodigoISOClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView[]> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoCodigoISOView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoCodigoISOView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoCodigoISOView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoCodigoISOView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TipoCodigoISOView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoCodigoISOView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoCodigoISOView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<TipoCodigoISOView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoCodigoISOView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TipoCodigoISOView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoCodigoISOView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoCodigoISOView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TipoCodigoISOView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoCodigoISOView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TipoCodigoISOView> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoCodigoISOView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoCodigoISOView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TipoCodigoISOView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoCodigoISOView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TipoCodigoISOView> {
        let url_ = this.baseUrl + "/api/TipoCodigoISO/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoCodigoISOView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoCodigoISOView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<TipoCodigoISOView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoCodigoISOView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoDireccionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoDireccionView[]>;
}

@Injectable()
export class TipoDireccionClient implements ITipoDireccionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoDireccionView[]> {
        let url_ = this.baseUrl + "/api/TipoDireccion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoDireccionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoDireccionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoDireccionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoDireccionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoDocumentoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoDocumentoView[]>;
}

@Injectable()
export class TipoDocumentoClient implements ITipoDocumentoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoDocumento/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoDocumentoView[]> {
        let url_ = this.baseUrl + "/api/TipoDocumento/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoDocumentoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoDocumentoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoDocumentoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoDocumentoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoEmpleadoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoEmpleadoView[]>;
}

@Injectable()
export class TipoEmpleadoClient implements ITipoEmpleadoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoEmpleadoView[]> {
        let url_ = this.baseUrl + "/api/TipoEmpleado/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoEmpleadoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoEmpleadoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoEmpleadoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoEmpleadoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoEmpresaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoEmpresaView[]>;
}

@Injectable()
export class TipoEmpresaClient implements ITipoEmpresaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoEmpresaView[]> {
        let url_ = this.baseUrl + "/api/TipoEmpresa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoEmpresaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoEmpresaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoEmpresaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoEmpresaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoEquipamientoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoEquipamientoView[]>;
}

@Injectable()
export class TipoEquipamientoClient implements ITipoEquipamientoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoEquipamientoView[]> {
        let url_ = this.baseUrl + "/api/TipoEquipamiento/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoEquipamientoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoEquipamientoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoEquipamientoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoEquipamientoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoFuncionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoFuncionView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TipoFuncionClient implements ITipoFuncionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoFuncionView[]> {
        let url_ = this.baseUrl + "/api/TipoFuncion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoFuncionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoFuncionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoFuncionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoFuncionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoFuncion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoIntegracionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoIntegracionView[]>;
}

@Injectable()
export class TipoIntegracionClient implements ITipoIntegracionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoIntegracionView[]> {
        let url_ = this.baseUrl + "/api/TipoIntegracion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoIntegracionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoIntegracionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoIntegracionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoIntegracionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoIntervencionClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TipoIntervencionView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TipoIntervencionView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TipoIntervencionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoIntervencionView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TipoIntervencionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoIntervencionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class TipoIntervencionClient implements ITipoIntervencionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoIntervencion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<TipoIntervencionView> {
        let url_ = this.baseUrl + "/api/TipoIntervencion/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoIntervencionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoIntervencionView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<TipoIntervencionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoIntervencionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<TipoIntervencionView> {
        let url_ = this.baseUrl + "/api/TipoIntervencion/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoIntervencionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoIntervencionView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TipoIntervencionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoIntervencionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: TipoIntervencionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoIntervencionView> {
        let url_ = this.baseUrl + "/api/TipoIntervencion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoIntervencionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoIntervencionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<TipoIntervencionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoIntervencionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: TipoIntervencionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoIntervencionView> {
        let url_ = this.baseUrl + "/api/TipoIntervencion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoIntervencionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoIntervencionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TipoIntervencionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TipoIntervencionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/TipoIntervencion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoMensajeClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoMensajeView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TipoMensajeClient implements ITipoMensajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoMensajeView[]> {
        let url_ = this.baseUrl + "/api/TipoMensaje/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoMensajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoMensajeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoMensajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoMensajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoMensaje/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoMercanciaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoMercanciaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TipoMercanciaClient implements ITipoMercanciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoMercanciaView[]> {
        let url_ = this.baseUrl + "/api/TipoMercancia/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoMercanciaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoMercanciaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoMercanciaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoMercanciaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoMercancia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoObservacionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoObservacionView[]>;
}

@Injectable()
export class TipoObservacionClient implements ITipoObservacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoObservacionView[]> {
        let url_ = this.baseUrl + "/api/TipoObservacion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoObservacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoObservacionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoObservacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoObservacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoOperacionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoOperacionView[]>;
}

@Injectable()
export class TipoOperacionClient implements ITipoOperacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoOperacionView[]> {
        let url_ = this.baseUrl + "/api/TipoOperacion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoOperacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoOperacionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoOperacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoOperacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoOperacionBuqueClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoOperacionBuqueView[]>;
}

@Injectable()
export class TipoOperacionBuqueClient implements ITipoOperacionBuqueClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoOperacionBuqueView[]> {
        let url_ = this.baseUrl + "/api/TipoOperacionBuque/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoOperacionBuqueView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoOperacionBuqueView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoOperacionBuqueView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoOperacionBuqueView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoPeligrosidadClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoPeligrosidadView[]>;
}

@Injectable()
export class TipoPeligrosidadClient implements ITipoPeligrosidadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoPeligrosidadView[]> {
        let url_ = this.baseUrl + "/api/TipoPeligrosidad/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoPeligrosidadView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoPeligrosidadView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoPeligrosidadView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoPeligrosidadView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoPrecintoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoPrecintoView[]>;
}

@Injectable()
export class TipoPrecintoClient implements ITipoPrecintoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoPrecintoView[]> {
        let url_ = this.baseUrl + "/api/TipoPrecinto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoPrecintoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoPrecintoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoPrecintoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoPrecintoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoPuertoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoPuertoView[]>;
}

@Injectable()
export class TipoPuertoClient implements ITipoPuertoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoPuertoView[]> {
        let url_ = this.baseUrl + "/api/TipoPuerto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoPuertoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoPuertoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoPuertoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoPuertoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoRecargoClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoRecargoView[]>;
}

@Injectable()
export class TipoRecargoClient implements ITipoRecargoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoRecargoView[]> {
        let url_ = this.baseUrl + "/api/TipoRecargo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoRecargoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoRecargoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoRecargoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoRecargoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoRespuestaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoRespuestaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TipoRespuestaClient implements ITipoRespuestaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoRespuestaView[]> {
        let url_ = this.baseUrl + "/api/TipoRespuesta/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoRespuestaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoRespuestaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoRespuestaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoRespuestaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoRespuesta/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoServicioTarificableClient {
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTipoServicioTarificableNoIncluidoEnTarifa(tarifaId: number, accept_Language?: string | undefined): Observable<TipoServicioTarificableView[]>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTipoServicioTarificableNoIncluidoEnRecargo(recargoId: number, accept_Language?: string | undefined): Observable<TipoServicioTarificableView[]>;
}

@Injectable()
export class TipoServicioTarificableClient implements ITipoServicioTarificableClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTipoServicioTarificableNoIncluidoEnTarifa(tarifaId: number, accept_Language?: string | undefined): Observable<TipoServicioTarificableView[]> {
        let url_ = this.baseUrl + "/api/TipoServicioTarificable/GetTipoServicioTarificableNoIncluidoEnTarifa?";
        if (tarifaId === undefined || tarifaId === null)
            throw new Error("The parameter 'tarifaId' must be defined and cannot be null.");
        else
            url_ += "TarifaId=" + encodeURIComponent("" + tarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTipoServicioTarificableNoIncluidoEnTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTipoServicioTarificableNoIncluidoEnTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoServicioTarificableView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoServicioTarificableView[]>;
        }));
    }

    protected processGetTipoServicioTarificableNoIncluidoEnTarifa(response: HttpResponseBase): Observable<TipoServicioTarificableView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoServicioTarificableView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getTipoServicioTarificableNoIncluidoEnRecargo(recargoId: number, accept_Language?: string | undefined): Observable<TipoServicioTarificableView[]> {
        let url_ = this.baseUrl + "/api/TipoServicioTarificable/GetTipoServicioTarificableNoIncluidoEnRecargo?";
        if (recargoId === undefined || recargoId === null)
            throw new Error("The parameter 'recargoId' must be defined and cannot be null.");
        else
            url_ += "RecargoId=" + encodeURIComponent("" + recargoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTipoServicioTarificableNoIncluidoEnRecargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTipoServicioTarificableNoIncluidoEnRecargo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoServicioTarificableView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoServicioTarificableView[]>;
        }));
    }

    protected processGetTipoServicioTarificableNoIncluidoEnRecargo(response: HttpResponseBase): Observable<TipoServicioTarificableView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoServicioTarificableView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoTarifaClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoTarifaView[]>;
}

@Injectable()
export class TipoTarifaClient implements ITipoTarifaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoTarifaView[]> {
        let url_ = this.baseUrl + "/api/TipoTarifa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoTarifaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoTarifaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoTarifaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoTarifaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoUnidadMercanciaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoUnidadMercanciaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TipoUnidadMercanciaClient implements ITipoUnidadMercanciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoUnidadMercanciaView[]> {
        let url_ = this.baseUrl + "/api/TipoUnidadMercancia/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoUnidadMercanciaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoUnidadMercanciaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoUnidadMercanciaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoUnidadMercanciaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoUnidadMercancia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITipoVehiculoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoVehiculoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class TipoVehiculoClient implements ITipoVehiculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<TipoVehiculoView[]> {
        let url_ = this.baseUrl + "/api/TipoVehiculo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TipoVehiculoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TipoVehiculoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TipoVehiculoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TipoVehiculoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/TipoVehiculo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehiculoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<VehiculoView>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoView[]>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<VehiculoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: VehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoView>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: VehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoView>;
    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse>;
    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    gestionarInsert(body: VehiculoView, accept_Language?: string | undefined): Observable<number>;
    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    gestionarDelete(vehiculoId: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class VehiculoClient implements IVehiculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<VehiculoView> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<VehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoView[]> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VehiculoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VehiculoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<VehiculoView> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<VehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: VehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoView> {
        let url_ = this.baseUrl + "/api/Vehiculo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<VehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Vehiculo/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Vehiculo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: VehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoView> {
        let url_ = this.baseUrl + "/api/Vehiculo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetNewAttachmentEntity?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewAttachmentEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewAttachmentEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetNewAttachmentEntity(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad.
     * @param attachmentTypeId (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllAttachments(id: number, attachmentTypeId?: number | undefined, accept_Language?: string | undefined): Observable<AttachmentView[]> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetAllAttachments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (attachmentTypeId === null)
            throw new Error("The parameter 'attachmentTypeId' cannot be null.");
        else if (attachmentTypeId !== undefined)
            url_ += "attachmentTypeId=" + encodeURIComponent("" + attachmentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView[]>;
        }));
    }

    protected processGetAllAttachments(response: HttpResponseBase): Observable<AttachmentView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AttachmentView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Vehiculo/GetAllVTAAttachmentsKendoFilter?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVTAAttachmentsKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVTAAttachmentsKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllVTAAttachmentsKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    gestionarInsert(body: VehiculoView, accept_Language?: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Vehiculo/GestionarInsert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGestionarInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGestionarInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGestionarInsert(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return _observableOf(result202);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    gestionarDelete(vehiculoId: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Vehiculo/GestionarDelete?";
        if (vehiculoId === undefined || vehiculoId === null)
            throw new Error("The parameter 'vehiculoId' must be defined and cannot be null.");
        else
            url_ += "vehiculoId=" + encodeURIComponent("" + vehiculoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGestionarDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGestionarDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGestionarDelete(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return _observableOf(result202);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehiculo_SecurityCompanyClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<Vehiculo_SecurityCompanyView[]>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: Vehiculo_SecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<Vehiculo_SecurityCompanyView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: Vehiculo_SecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<Vehiculo_SecurityCompanyView>;
}

@Injectable()
export class Vehiculo_SecurityCompanyClient implements IVehiculo_SecurityCompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<Vehiculo_SecurityCompanyView[]> {
        let url_ = this.baseUrl + "/api/Vehiculo_SecurityCompany/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Vehiculo_SecurityCompanyView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Vehiculo_SecurityCompanyView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<Vehiculo_SecurityCompanyView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Vehiculo_SecurityCompanyView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: Vehiculo_SecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<Vehiculo_SecurityCompanyView> {
        let url_ = this.baseUrl + "/api/Vehiculo_SecurityCompany/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Vehiculo_SecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Vehiculo_SecurityCompanyView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<Vehiculo_SecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vehiculo_SecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: Vehiculo_SecurityCompanyView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<Vehiculo_SecurityCompanyView> {
        let url_ = this.baseUrl + "/api/Vehiculo_SecurityCompany/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Vehiculo_SecurityCompanyView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Vehiculo_SecurityCompanyView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Vehiculo_SecurityCompanyView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vehiculo_SecurityCompanyView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVehiculoIntervencionTallerClient {
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<VehiculoIntervencionTallerView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: VehiculoIntervencionTallerView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoIntervencionTallerView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: VehiculoIntervencionTallerView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoIntervencionTallerView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class VehiculoIntervencionTallerClient implements IVehiculoIntervencionTallerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<VehiculoIntervencionTallerView> {
        let url_ = this.baseUrl + "/api/VehiculoIntervencionTaller/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoIntervencionTallerView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoIntervencionTallerView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<VehiculoIntervencionTallerView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoIntervencionTallerView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: VehiculoIntervencionTallerView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoIntervencionTallerView> {
        let url_ = this.baseUrl + "/api/VehiculoIntervencionTaller/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoIntervencionTallerView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoIntervencionTallerView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<VehiculoIntervencionTallerView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoIntervencionTallerView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: VehiculoIntervencionTallerView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<VehiculoIntervencionTallerView> {
        let url_ = this.baseUrl + "/api/VehiculoIntervencionTaller/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VehiculoIntervencionTallerView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VehiculoIntervencionTallerView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<VehiculoIntervencionTallerView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VehiculoIntervencionTallerView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/VehiculoIntervencionTaller/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeView>;
    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView>;
    /**
     * Obtiene una lista de entidades en base a sus identificadores estén o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeView[]>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    desasociarOrden(viajeId: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param valorado (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    valorarViajes(viajeIds: number[], cotizacion: boolean, liquidacion: boolean, valorado?: boolean | undefined, accept_Language?: string | undefined): Observable<string>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    obtenerAvisos(viajeId: number, accept_Language?: string | undefined): Observable<IssueResponseView>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    setCancellation(viajeId: number, isCancelled: boolean, accept_Language?: string | undefined): Observable<string>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    cloneTrip(viajeId: number, accept_Language?: string | undefined): Observable<ViajeView>;
    /**
     * Genera un IntegrationOrder a partir de un viaje existente y lo envía a asignación
     * @param accept_Language (optional) 
     * @return OK
     */
    sendIOAssignment(viajeId: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecursosCalendario(fecha: Date, accept_Language?: string | undefined): Observable<CalendarDataDTO>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecursosPlanificador(fecha: Date, accept_Language?: string | undefined): Observable<SchedulerDataDTO>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    previewDocuments(body: PreviewDocumentRequest, accept_Language?: string | undefined): Observable<PreviewDocumentResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getDctPdfReport(viajeId: number, accept_Language?: string | undefined): Observable<FileResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getCompleteOrderPdfReport(viajeId: number, containerItemNumber: string, accept_Language?: string | undefined): Observable<FileResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getReleaseAcceptancePdfReport(viajeId: number, containerItemNumber: string, accept_Language?: string | undefined): Observable<FileResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    sendDocuments(body: SendEmailDocumentsRequest, accept_Language?: string | undefined): Observable<PreviewDocumentResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    sendIOAssignmentBatch(body: number[], accept_Language?: string | undefined): Observable<SendIOAssignmentBatchResponse>;
}

@Injectable()
export class ViajeClient implements IViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeView[]> {
        let url_ = this.baseUrl + "/api/Viaje/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Viaje/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeView> {
        let url_ = this.baseUrl + "/api/Viaje/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeView> {
        let url_ = this.baseUrl + "/api/Viaje/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeView> {
        let url_ = this.baseUrl + "/api/Viaje/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeView> {
        let url_ = this.baseUrl + "/api/Viaje/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todos los adjuntos de una entidad aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @param body (optional) 
     * @return OK
     */
    getAllVTAAttachmentsKendoFilter(id: number, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined, body?: KendoGridFilter | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/Viaje/GetAllVTAAttachmentsKendoFilter?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVTAAttachmentsKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVTAAttachmentsKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllVTAAttachmentsKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad adjunto inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewAttachmentEntity(id: number, accept_Language?: string | undefined): Observable<AttachmentView> {
        let url_ = this.baseUrl + "/api/Viaje/GetNewAttachmentEntity?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewAttachmentEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewAttachmentEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachmentView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachmentView>;
        }));
    }

    protected processGetNewAttachmentEntity(response: HttpResponseBase): Observable<AttachmentView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una lista de entidades en base a sus identificadores estén o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getByIds(ids: number[], configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeView[]> {
        let url_ = this.baseUrl + "/api/Viaje/GetByIds?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView[]>;
        }));
    }

    protected processGetByIds(response: HttpResponseBase): Observable<ViajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Viaje/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    desasociarOrden(viajeId: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Viaje/DesasociarOrden?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDesasociarOrden(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDesasociarOrden(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDesasociarOrden(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param valorado (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    valorarViajes(viajeIds: number[], cotizacion: boolean, liquidacion: boolean, valorado?: boolean | undefined, accept_Language?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Viaje/ValorarViajes?";
        if (viajeIds === undefined || viajeIds === null)
            throw new Error("The parameter 'viajeIds' must be defined and cannot be null.");
        else
            viajeIds && viajeIds.forEach(item => { url_ += "viajeIds=" + encodeURIComponent("" + item) + "&"; });
        if (cotizacion === undefined || cotizacion === null)
            throw new Error("The parameter 'cotizacion' must be defined and cannot be null.");
        else
            url_ += "cotizacion=" + encodeURIComponent("" + cotizacion) + "&";
        if (liquidacion === undefined || liquidacion === null)
            throw new Error("The parameter 'liquidacion' must be defined and cannot be null.");
        else
            url_ += "liquidacion=" + encodeURIComponent("" + liquidacion) + "&";
        if (valorado === null)
            throw new Error("The parameter 'valorado' cannot be null.");
        else if (valorado !== undefined)
            url_ += "valorado=" + encodeURIComponent("" + valorado) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValorarViajes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValorarViajes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processValorarViajes(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    obtenerAvisos(viajeId: number, accept_Language?: string | undefined): Observable<IssueResponseView> {
        let url_ = this.baseUrl + "/api/Viaje/ObtenerAvisos?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processObtenerAvisos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processObtenerAvisos(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IssueResponseView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IssueResponseView>;
        }));
    }

    protected processObtenerAvisos(response: HttpResponseBase): Observable<IssueResponseView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueResponseView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    setCancellation(viajeId: number, isCancelled: boolean, accept_Language?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Viaje/SetCancellation?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (isCancelled === undefined || isCancelled === null)
            throw new Error("The parameter 'isCancelled' must be defined and cannot be null.");
        else
            url_ += "isCancelled=" + encodeURIComponent("" + isCancelled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCancellation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCancellation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetCancellation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    cloneTrip(viajeId: number, accept_Language?: string | undefined): Observable<ViajeView> {
        let url_ = this.baseUrl + "/api/Viaje/CloneTrip?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloneTrip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloneTrip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeView>;
        }));
    }

    protected processCloneTrip(response: HttpResponseBase): Observable<ViajeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Genera un IntegrationOrder a partir de un viaje existente y lo envía a asignación
     * @param accept_Language (optional) 
     * @return OK
     */
    sendIOAssignment(viajeId: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Viaje/SendIOAssignment?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendIOAssignment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendIOAssignment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSendIOAssignment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecursosCalendario(fecha: Date, accept_Language?: string | undefined): Observable<CalendarDataDTO> {
        let url_ = this.baseUrl + "/api/Viaje/GetRecursosCalendario?";
        if (fecha === undefined || fecha === null)
            throw new Error("The parameter 'fecha' must be defined and cannot be null.");
        else
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecursosCalendario(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecursosCalendario(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CalendarDataDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CalendarDataDTO>;
        }));
    }

    protected processGetRecursosCalendario(response: HttpResponseBase): Observable<CalendarDataDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalendarDataDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecursosPlanificador(fecha: Date, accept_Language?: string | undefined): Observable<SchedulerDataDTO> {
        let url_ = this.baseUrl + "/api/Viaje/GetRecursosPlanificador?";
        if (fecha === undefined || fecha === null)
            throw new Error("The parameter 'fecha' must be defined and cannot be null.");
        else
            url_ += "fecha=" + encodeURIComponent(fecha ? "" + fecha.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecursosPlanificador(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecursosPlanificador(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SchedulerDataDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SchedulerDataDTO>;
        }));
    }

    protected processGetRecursosPlanificador(response: HttpResponseBase): Observable<SchedulerDataDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SchedulerDataDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    previewDocuments(body: PreviewDocumentRequest, accept_Language?: string | undefined): Observable<PreviewDocumentResponse> {
        let url_ = this.baseUrl + "/api/Viaje/PreviewDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreviewDocumentResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreviewDocumentResponse>;
        }));
    }

    protected processPreviewDocuments(response: HttpResponseBase): Observable<PreviewDocumentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewDocumentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getDctPdfReport(viajeId: number, accept_Language?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Viaje/GetDctPdfReport?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDctPdfReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDctPdfReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetDctPdfReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getCompleteOrderPdfReport(viajeId: number, containerItemNumber: string, accept_Language?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Viaje/GetCompleteOrderPdfReport?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (containerItemNumber === undefined || containerItemNumber === null)
            throw new Error("The parameter 'containerItemNumber' must be defined and cannot be null.");
        else
            url_ += "containerItemNumber=" + encodeURIComponent("" + containerItemNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompleteOrderPdfReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompleteOrderPdfReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetCompleteOrderPdfReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getReleaseAcceptancePdfReport(viajeId: number, containerItemNumber: string, accept_Language?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Viaje/GetReleaseAcceptancePdfReport?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (containerItemNumber === undefined || containerItemNumber === null)
            throw new Error("The parameter 'containerItemNumber' must be defined and cannot be null.");
        else
            url_ += "containerItemNumber=" + encodeURIComponent("" + containerItemNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReleaseAcceptancePdfReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReleaseAcceptancePdfReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetReleaseAcceptancePdfReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    sendDocuments(body: SendEmailDocumentsRequest, accept_Language?: string | undefined): Observable<PreviewDocumentResponse> {
        let url_ = this.baseUrl + "/api/Viaje/SendDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PreviewDocumentResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PreviewDocumentResponse>;
        }));
    }

    protected processSendDocuments(response: HttpResponseBase): Observable<PreviewDocumentResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PreviewDocumentResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    sendIOAssignmentBatch(body: number[], accept_Language?: string | undefined): Observable<SendIOAssignmentBatchResponse> {
        let url_ = this.baseUrl + "/api/Viaje/SendIOAssignmentBatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendIOAssignmentBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendIOAssignmentBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendIOAssignmentBatchResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendIOAssignmentBatchResponse>;
        }));
    }

    protected processSendIOAssignmentBatch(response: HttpResponseBase): Observable<SendIOAssignmentBatchResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SendIOAssignmentBatchResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeAgenteClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView[]>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeAgenteView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeAgenteView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeAgenteView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeAgenteClient implements IViajeAgenteClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView[]> {
        let url_ = this.baseUrl + "/api/ViajeAgente/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeAgenteView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeAgenteView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeAgenteView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeAgenteView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView> {
        let url_ = this.baseUrl + "/api/ViajeAgente/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeAgenteView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeAgenteView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeAgenteView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeAgenteView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeAgenteView> {
        let url_ = this.baseUrl + "/api/ViajeAgente/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeAgenteView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeAgenteView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeAgenteView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeAgenteView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeAgenteView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView> {
        let url_ = this.baseUrl + "/api/ViajeAgente/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeAgenteView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeAgenteView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeAgenteView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeAgenteView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeAgenteView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeAgenteView> {
        let url_ = this.baseUrl + "/api/ViajeAgente/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeAgenteView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeAgenteView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeAgenteView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeAgenteView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeAgente/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeAgente/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeBuqueClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeBuqueView[]>;
}

@Injectable()
export class ViajeBuqueClient implements IViajeBuqueClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeBuqueView[]> {
        let url_ = this.baseUrl + "/api/ViajeBuque/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeBuqueView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeBuqueView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeBuqueView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeBuqueView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeCargadorClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeCargadorView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeCargadorView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeCargadorView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView>;
    /**
     * Actualiza una lista de entidades. Devuelve la lista de entidades actualizadas.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    updateMany(body: ViajeCargadorView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView[]>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeCargadorClient implements IViajeCargadorClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView[]> {
        let url_ = this.baseUrl + "/api/ViajeCargador/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeCargadorView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeCargadorView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeCargadorView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeCargadorView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeCargador/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeCargadorView> {
        let url_ = this.baseUrl + "/api/ViajeCargador/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeCargadorView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeCargadorView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeCargadorView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeCargadorView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView> {
        let url_ = this.baseUrl + "/api/ViajeCargador/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeCargadorView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeCargadorView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeCargadorView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeCargadorView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeCargadorView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView> {
        let url_ = this.baseUrl + "/api/ViajeCargador/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeCargadorView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeCargadorView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeCargadorView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeCargadorView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeCargadorView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView> {
        let url_ = this.baseUrl + "/api/ViajeCargador/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeCargadorView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeCargadorView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeCargadorView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeCargadorView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una lista de entidades. Devuelve la lista de entidades actualizadas.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    updateMany(body: ViajeCargadorView[], configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeCargadorView[]> {
        let url_ = this.baseUrl + "/api/ViajeCargador/UpdateMany?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMany(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeCargadorView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeCargadorView[]>;
        }));
    }

    protected processUpdateMany(response: HttpResponseBase): Observable<ViajeCargadorView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeCargadorView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeCargador/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeConductorVehiculoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView[]>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeConductorVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeConductorVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeConductorVehiculoClient implements IViajeConductorVehiculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView[]> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeConductorVehiculoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeConductorVehiculoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeConductorVehiculoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeConductorVehiculoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeConductorVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeConductorVehiculoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeConductorVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeConductorVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeConductorVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeConductorVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeConductorVehiculoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeConductorVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeConductorVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeConductorVehiculoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeConductorVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeConductorVehiculoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeConductorVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeConductorVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeConductorVehiculoView> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeConductorVehiculoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeConductorVehiculoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeConductorVehiculoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeConductorVehiculoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeConductorVehiculo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeEquipamientoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeEquipamientoClient implements IViajeEquipamientoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView[]> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeEquipamientoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeEquipamientoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeEquipamientoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeEquipamientoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeEquipamientoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeEquipamientoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeEquipamiento/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeEquipamientoMercanciaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoMercanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoMercanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeEquipamientoMercanciaClient implements IViajeEquipamientoMercanciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView[]> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeEquipamientoMercanciaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoMercanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoMercanciaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercancia/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeEquipamientoMercanciaPeligrosaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoMercanciaPeligrosaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoMercanciaPeligrosaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeEquipamientoMercanciaPeligrosaClient implements IViajeEquipamientoMercanciaPeligrosaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView[]> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaPeligrosaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeEquipamientoMercanciaPeligrosaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaPeligrosaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaPeligrosaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoMercanciaPeligrosaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaPeligrosaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoMercanciaPeligrosaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoMercanciaPeligrosaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeEquipamientoMercanciaPeligrosaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoMercanciaPeligrosaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoMercanciaPeligrosa/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeEquipamientoPrecintoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoPrecintoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoPrecintoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeEquipamientoPrecintoClient implements IViajeEquipamientoPrecintoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView[]> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoPrecintoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoPrecintoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeEquipamientoPrecintoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeEquipamientoPrecintoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoPrecintoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoPrecintoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeEquipamientoPrecintoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoPrecintoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoPrecintoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoPrecintoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeEquipamientoPrecintoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoPrecintoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeEquipamientoPrecintoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoPrecintoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoPrecintoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeEquipamientoPrecintoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoPrecintoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeEquipamientoPrecintoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeEquipamientoPrecintoView> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeEquipamientoPrecintoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeEquipamientoPrecintoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeEquipamientoPrecintoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeEquipamientoPrecintoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeEquipamientoPrecinto/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeObservacionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeObservacionView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeObservacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeObservacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeObservacionClient implements IViajeObservacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView[]> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeObservacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeObservacionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeObservacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeObservacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeObservacionView> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeObservacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeObservacionView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeObservacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeObservacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeObservacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeObservacionView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeObservacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeObservacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeObservacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeObservacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeObservacionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeObservacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeObservacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeObservacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeObservacionView> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeObservacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeObservacionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeObservacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeObservacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeObservacion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajePuertoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajePuertoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajePuertoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajePuertoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajePuertoClient implements IViajePuertoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView[]> {
        let url_ = this.baseUrl + "/api/ViajePuerto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajePuertoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajePuertoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajePuertoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajePuertoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajePuerto/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajePuertoView> {
        let url_ = this.baseUrl + "/api/ViajePuerto/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajePuertoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajePuertoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajePuertoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajePuertoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView> {
        let url_ = this.baseUrl + "/api/ViajePuerto/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajePuertoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajePuertoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajePuertoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajePuertoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajePuertoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView> {
        let url_ = this.baseUrl + "/api/ViajePuerto/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajePuertoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajePuertoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajePuertoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajePuertoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajePuertoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajePuertoView> {
        let url_ = this.baseUrl + "/api/ViajePuerto/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajePuertoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajePuertoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajePuertoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajePuertoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajePuerto/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeRecargoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView[]>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeRecargoClient implements IViajeRecargoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView[]> {
        let url_ = this.baseUrl + "/api/ViajeRecargo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeRecargoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeRecargoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeRecargoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeRecargoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeRecargo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeRecargoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeRecargo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeRecargoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeRecargo/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeRecargoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeRecargo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeRecargo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeTarifaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarifaView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeTarifaClient implements IViajeTarifaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView[]> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarifaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarifaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeTarifaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeTarifaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarifaView> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarifaView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeTarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarifaView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeTarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarifaView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeTarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarifaView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarifaView> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarifaView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarifaView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeTarifaView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarifaView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarifa/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeTarificacionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarificacionView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarificacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarificacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    get(viajeId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<ViajeTarificacionView>;
    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    post(viajeId: number, tipoTarifaId: number, body: ViajeTarificacionView, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeTarificacionClient implements IViajeTarificacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView[]> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeTarificacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeTarificacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarificacionView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeTarificacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeTarificacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarificacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeTarificacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarificacionView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeTarificacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    get(viajeId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<ViajeTarificacionView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/Get?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (tipoTarifaId === undefined || tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' must be defined and cannot be null.");
        else
            url_ += "tipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionView>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ViajeTarificacionView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return Accepted
     */
    post(viajeId: number, tipoTarifaId: number, body: ViajeTarificacionView, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacion/Post?";
        if (viajeId === undefined || viajeId === null)
            throw new Error("The parameter 'viajeId' must be defined and cannot be null.");
        else
            url_ += "viajeId=" + encodeURIComponent("" + viajeId) + "&";
        if (tipoTarifaId === undefined || tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' must be defined and cannot be null.");
        else
            url_ += "tipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return _observableOf(result202);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeTarificacionConceptoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarificacionConceptoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarificacionConceptoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeTarificacionConceptoClient implements IViajeTarificacionConceptoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView[]> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionConceptoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionConceptoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeTarificacionConceptoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeTarificacionConceptoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionConceptoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionConceptoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeTarificacionConceptoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionConceptoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionConceptoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionConceptoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeTarificacionConceptoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionConceptoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarificacionConceptoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionConceptoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionConceptoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeTarificacionConceptoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionConceptoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarificacionConceptoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionConceptoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionConceptoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionConceptoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeTarificacionConceptoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionConceptoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionConcepto/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IViajeTarificacionRecargoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView>;
    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView>;
    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarificacionRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView>;
    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarificacionRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView>;
    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean>;
    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean>;
}

@Injectable()
export class ViajeTarificacionRecargoClient implements IViajeTarificacionRecargoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView[]> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionRecargoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionRecargoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ViajeTarificacionRecargoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ViajeTarificacionRecargoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una nueva entidad inicializada y pendiente de almacenar en base de datos.
     * @param accept_Language (optional) 
     * @return OK
     */
    getNewEntity(accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/GetNewEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionRecargoView>;
        }));
    }

    protected processGetNewEntity(response: HttpResponseBase): Observable<ViajeTarificacionRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("No Content", status, _responseText, _headers);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene una entidad en base a su identificador esté o no de baja lógica.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/GetById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionRecargoView>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ViajeTarificacionRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Inserta una nueva entidad. Devuelve la entidad insertada actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    insert(body: ViajeTarificacionRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/Insert?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionRecargoView>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ViajeTarificacionRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Actualiza una entidad. Devuelve la entidad actualizada.
     * @param configurationName (optional) 
     * @param reloadView (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    update(body: ViajeTarificacionRecargoView, configurationName?: string | undefined, reloadView?: boolean | undefined, accept_Language?: string | undefined): Observable<ViajeTarificacionRecargoView> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/Update?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (reloadView === null)
            throw new Error("The parameter 'reloadView' cannot be null.");
        else if (reloadView !== undefined)
            url_ += "reloadView=" + encodeURIComponent("" + reloadView) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ViajeTarificacionRecargoView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ViajeTarificacionRecargoView>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ViajeTarificacionRecargoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ViajeTarificacionRecargoView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Elimina una entidad en base a su identificador esté o no de baja lógica. Devuelve un booleano indicando si la actualización se ha realizado correctamente.
     * @param configurationName (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteById(id: number, configurationName?: string | undefined, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/DeleteById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Da de baja lógica o de alta una entidad en base a su identificador. Devuelve un booleano indicando si la baja lógica o el alta se ha realizado correctamente.
     * @param accept_Language (optional) 
     * @return OK
     */
    deleteUndeleteLogicById(id: number, accept_Language?: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ViajeTarificacionRecargo/DeleteUndeleteLogicById?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUndeleteLogicById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUndeleteLogicById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteUndeleteLogicById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_AjusteLiquidacionClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_AjusteLiquidacionClient implements IVTA_AjusteLiquidacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_AjusteLiquidacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_AttachmentClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_AttachmentClient implements IVTA_AttachmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Attachment/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_ConceptosTarificacionClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_ConceptosTarificacionView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConceptosTarificacion(conceptoId: number, accept_Language?: string | undefined): Observable<VTA_ConceptosTarificacionView[]>;
}

@Injectable()
export class VTA_ConceptosTarificacionClient implements IVTA_ConceptosTarificacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_ConceptosTarificacionView[]> {
        let url_ = this.baseUrl + "/api/VTA_ConceptosTarificacion/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_ConceptosTarificacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_ConceptosTarificacionView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_ConceptosTarificacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_ConceptosTarificacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_ConceptosTarificacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getConceptosTarificacion(conceptoId: number, accept_Language?: string | undefined): Observable<VTA_ConceptosTarificacionView[]> {
        let url_ = this.baseUrl + "/api/VTA_ConceptosTarificacion/GetConceptosTarificacion?";
        if (conceptoId === undefined || conceptoId === null)
            throw new Error("The parameter 'conceptoId' must be defined and cannot be null.");
        else
            url_ += "conceptoId=" + encodeURIComponent("" + conceptoId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConceptosTarificacion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConceptosTarificacion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_ConceptosTarificacionView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_ConceptosTarificacionView[]>;
        }));
    }

    protected processGetConceptosTarificacion(response: HttpResponseBase): Observable<VTA_ConceptosTarificacionView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_ConceptosTarificacionView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_DistanciaClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_DistanciaClient implements IVTA_DistanciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Distancia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_EmpleadoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_EmpleadoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_EmpleadoClient implements IVTA_EmpleadoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_EmpleadoView[]> {
        let url_ = this.baseUrl + "/api/VTA_Empleado/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_EmpleadoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_EmpleadoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_EmpleadoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_EmpleadoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Empleado/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_EmpresaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_EmpresaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_EmpresaClient implements IVTA_EmpresaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_EmpresaView[]> {
        let url_ = this.baseUrl + "/api/VTA_Empresa/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_EmpresaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_EmpresaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_EmpresaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_EmpresaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Empresa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_EmpresaAjenaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_EmpresaAjenaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_EmpresaAjenaClient implements IVTA_EmpresaAjenaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_EmpresaAjenaView[]> {
        let url_ = this.baseUrl + "/api/VTA_EmpresaAjena/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_EmpresaAjenaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_EmpresaAjenaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_EmpresaAjenaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_EmpresaAjenaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_EmpresaAjena/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_IntercambioClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_IntercambioView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_IntercambioClient implements IVTA_IntercambioClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_IntercambioView[]> {
        let url_ = this.baseUrl + "/api/VTA_Intercambio/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_IntercambioView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_IntercambioView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_IntercambioView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_IntercambioView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Intercambio/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_LiquidacionClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_LiquidacionClient implements IVTA_LiquidacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Liquidacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_LocalidadClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_LocalidadView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_LocalidadClient implements IVTA_LocalidadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_LocalidadView[]> {
        let url_ = this.baseUrl + "/api/VTA_Localidad/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_LocalidadView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_LocalidadView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_LocalidadView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_LocalidadView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Localidad/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_MensajeClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_MensajeView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllFilterMessages(body: KendoGridFilter, accept_Language?: string | undefined): Observable<string>;
}

@Injectable()
export class VTA_MensajeClient implements IVTA_MensajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_MensajeView[]> {
        let url_ = this.baseUrl + "/api/VTA_Mensaje/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_MensajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_MensajeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_MensajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_MensajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Mensaje/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllFilterMessages(body: KendoGridFilter, accept_Language?: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/VTA_Mensaje/GetAllFilterMessages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFilterMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFilterMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetAllFilterMessages(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_ProvinciaClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_ProvinciaView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_ProvinciaClient implements IVTA_ProvinciaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_ProvinciaView[]> {
        let url_ = this.baseUrl + "/api/VTA_Provincia/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_ProvinciaView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_ProvinciaView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_ProvinciaView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_ProvinciaView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Provincia/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_RecargoClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargoByTipoServicioTipoTarifa(tipoServicioTarificableId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<VTA_RecargoView[]>;
}

@Injectable()
export class VTA_RecargoClient implements IVTA_RecargoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Recargo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param accept_Language (optional) 
     * @return OK
     */
    getRecargoByTipoServicioTipoTarifa(tipoServicioTarificableId: number, tipoTarifaId: number, accept_Language?: string | undefined): Observable<VTA_RecargoView[]> {
        let url_ = this.baseUrl + "/api/VTA_Recargo/GetRecargoByTipoServicioTipoTarifa?";
        if (tipoServicioTarificableId === undefined || tipoServicioTarificableId === null)
            throw new Error("The parameter 'tipoServicioTarificableId' must be defined and cannot be null.");
        else
            url_ += "TipoServicioTarificableId=" + encodeURIComponent("" + tipoServicioTarificableId) + "&";
        if (tipoTarifaId === undefined || tipoTarifaId === null)
            throw new Error("The parameter 'tipoTarifaId' must be defined and cannot be null.");
        else
            url_ += "TipoTarifaId=" + encodeURIComponent("" + tipoTarifaId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecargoByTipoServicioTipoTarifa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecargoByTipoServicioTipoTarifa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_RecargoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_RecargoView[]>;
        }));
    }

    protected processGetRecargoByTipoServicioTipoTarifa(response: HttpResponseBase): Observable<VTA_RecargoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_RecargoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_RegistroDocumentoClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_RegistroDocumentoClient implements IVTA_RegistroDocumentoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_RegistroDocumento/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_SageEmpresaClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_SageEmpresaClient implements IVTA_SageEmpresaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_SageEmpresa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_TarifaClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_TarifaClient implements IVTA_TarifaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Tarifa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_TipoServicioTarificableClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_TipoServicioTarificableView[]>;
}

@Injectable()
export class VTA_TipoServicioTarificableClient implements IVTA_TipoServicioTarificableClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_TipoServicioTarificable/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_TipoServicioTarificableView[]> {
        let url_ = this.baseUrl + "/api/VTA_TipoServicioTarificable/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_TipoServicioTarificableView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_TipoServicioTarificableView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_TipoServicioTarificableView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_TipoServicioTarificableView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_TipoTarifaClient {
    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_TipoTarifaClient implements IVTA_TipoTarifaClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_TipoTarifa/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "ConfigurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "IncludeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_VehiculoClient {
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_VehiculoView[]>;
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_VehiculoClient implements IVTA_VehiculoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_VehiculoView[]> {
        let url_ = this.baseUrl + "/api/VTA_Vehiculo/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_VehiculoView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_VehiculoView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_VehiculoView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_VehiculoView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Vehiculo/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_VehiculoIntervencionTallerClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_VehiculoIntervencionTallerClient implements IVTA_VehiculoIntervencionTallerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_VehiculoIntervencionTaller/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_ViajeClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_ViajeView[]>;
}

@Injectable()
export class VTA_ViajeClient implements IVTA_ViajeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_Viaje/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Obtiene la lista de todas las entidades.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAll(configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<VTA_ViajeView[]> {
        let url_ = this.baseUrl + "/api/VTA_Viaje/GetAll?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VTA_ViajeView[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VTA_ViajeView[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<VTA_ViajeView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VTA_ViajeView.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVTA_ViajeLiquidacionClient {
    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse>;
}

@Injectable()
export class VTA_ViajeLiquidacionClient implements IVTA_ViajeLiquidacionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Obtiene la lista de todas las entidades aplicando un filtro complejo proporcionado por la grid de Kendo Telerik.
     * @param configurationName (optional) 
     * @param includeDeleted (optional) 
     * @param accept_Language (optional) 
     * @return OK
     */
    getAllKendoFilter(body: KendoGridFilter, configurationName?: string | undefined, includeDeleted?: boolean | undefined, accept_Language?: string | undefined): Observable<PagingResponse> {
        let url_ = this.baseUrl + "/api/VTA_ViajeLiquidacion/GetAllKendoFilter?";
        if (configurationName === null)
            throw new Error("The parameter 'configurationName' cannot be null.");
        else if (configurationName !== undefined)
            url_ += "configurationName=" + encodeURIComponent("" + configurationName) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKendoFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKendoFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagingResponse>;
        }));
    }

    protected processGetAllKendoFilter(response: HttpResponseBase): Observable<PagingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class KendoAgregate implements IKendoAgregate {
    aggregate?: string | undefined;
    field?: string | undefined;

    constructor(data?: IKendoAgregate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aggregate = _data["aggregate"];
            this.field = _data["field"];
        }
    }

    static fromJS(data: any): KendoAgregate {
        data = typeof data === 'object' ? data : {};
        let result = new KendoAgregate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregate"] = this.aggregate;
        data["field"] = this.field;
        return data;
    }
}

export interface IKendoAgregate {
    aggregate?: string | undefined;
    field?: string | undefined;
}

export class KendoDataFilter implements IKendoDataFilter {
    filter?: KendoFilters;
    group?: KendoGroup[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
    skip?: number | undefined;
    sort?: KendoSort[] | undefined;
    take?: number | undefined;

    constructor(data?: IKendoDataFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"] ? KendoFilters.fromJS(_data["filter"]) : <any>undefined;
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group!.push(KendoGroup.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.skip = _data["skip"];
            if (Array.isArray(_data["sort"])) {
                this.sort = [] as any;
                for (let item of _data["sort"])
                    this.sort!.push(KendoSort.fromJS(item));
            }
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): KendoDataFilter {
        data = typeof data === 'object' ? data : {};
        let result = new KendoDataFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["skip"] = this.skip;
        if (Array.isArray(this.sort)) {
            data["sort"] = [];
            for (let item of this.sort)
                data["sort"].push(item.toJSON());
        }
        data["take"] = this.take;
        return data;
    }
}

export interface IKendoDataFilter {
    filter?: KendoFilters;
    group?: KendoGroup[] | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
    skip?: number | undefined;
    sort?: KendoSort[] | undefined;
    take?: number | undefined;
}

export class KendoFilter implements IKendoFilter {
    field?: string | undefined;
    ignoreCase?: boolean | undefined;
    operator?: string | undefined;
    value?: any | undefined;
    filters?: KendoFilter[] | undefined;
    logic?: string | undefined;

    constructor(data?: IKendoFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.ignoreCase = _data["ignoreCase"];
            this.operator = _data["operator"];
            this.value = _data["value"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(KendoFilter.fromJS(item));
            }
            this.logic = _data["logic"];
        }
    }

    static fromJS(data: any): KendoFilter {
        data = typeof data === 'object' ? data : {};
        let result = new KendoFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["ignoreCase"] = this.ignoreCase;
        data["operator"] = this.operator;
        data["value"] = this.value;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        data["logic"] = this.logic;
        return data;
    }
}

export interface IKendoFilter {
    field?: string | undefined;
    ignoreCase?: boolean | undefined;
    operator?: string | undefined;
    value?: any | undefined;
    filters?: KendoFilter[] | undefined;
    logic?: string | undefined;
}

export class KendoFilters implements IKendoFilters {
    filters?: KendoFilter[] | undefined;
    logic?: string | undefined;

    constructor(data?: IKendoFilters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(KendoFilter.fromJS(item));
            }
            this.logic = _data["logic"];
        }
    }

    static fromJS(data: any): KendoFilters {
        data = typeof data === 'object' ? data : {};
        let result = new KendoFilters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        data["logic"] = this.logic;
        return data;
    }
}

export interface IKendoFilters {
    filters?: KendoFilter[] | undefined;
    logic?: string | undefined;
}

export class KendoGridFilter implements IKendoGridFilter {
    data?: KendoDataFilter;

    constructor(data?: IKendoGridFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? KendoDataFilter.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KendoGridFilter {
        data = typeof data === 'object' ? data : {};
        let result = new KendoGridFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKendoGridFilter {
    data?: KendoDataFilter;
}

export class KendoGroup implements IKendoGroup {
    aggregates?: KendoAgregate[] | undefined;
    dir?: string | undefined;
    field?: string | undefined;

    constructor(data?: IKendoGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates!.push(KendoAgregate.fromJS(item));
            }
            this.dir = _data["dir"];
            this.field = _data["field"];
        }
    }

    static fromJS(data: any): KendoGroup {
        data = typeof data === 'object' ? data : {};
        let result = new KendoGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["dir"] = this.dir;
        data["field"] = this.field;
        return data;
    }
}

export interface IKendoGroup {
    aggregates?: KendoAgregate[] | undefined;
    dir?: string | undefined;
    field?: string | undefined;
}

export class KendoSort implements IKendoSort {
    compare?: string | undefined;
    dir?: string | undefined;
    field?: string | undefined;

    constructor(data?: IKendoSort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.compare = _data["compare"];
            this.dir = _data["dir"];
            this.field = _data["field"];
        }
    }

    static fromJS(data: any): KendoSort {
        data = typeof data === 'object' ? data : {};
        let result = new KendoSort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["compare"] = this.compare;
        data["dir"] = this.dir;
        data["field"] = this.field;
        return data;
    }
}

export interface IKendoSort {
    compare?: string | undefined;
    dir?: string | undefined;
    field?: string | undefined;
}

export class PagingResponse implements IPagingResponse {
    list?: any[] | undefined;
    count?: number;

    constructor(data?: IPagingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(item);
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): PagingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item);
        }
        data["count"] = this.count;
        return data;
    }
}

export interface IPagingResponse {
    list?: any[] | undefined;
    count?: number;
}

export class AuthApplication implements IAuthApplication {
    readonly application?: string | undefined;
    readonly securityCompanyId?: number;
    readonly roles?: string[] | undefined;
    permissions?: number[] | undefined;

    constructor(data?: IAuthApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).application = _data["application"];
            (<any>this).securityCompanyId = _data["securityCompanyId"];
            if (Array.isArray(_data["roles"])) {
                (<any>this).roles = [] as any;
                for (let item of _data["roles"])
                    (<any>this).roles!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthApplication {
        data = typeof data === 'object' ? data : {};
        let result = new AuthApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application;
        data["securityCompanyId"] = this.securityCompanyId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IAuthApplication {
    application?: string | undefined;
    securityCompanyId?: number;
    roles?: string[] | undefined;
    permissions?: number[] | undefined;
}

export class AuthClaim implements IAuthClaim {
    claim?: string | undefined;
    value?: string | undefined;

    constructor(data?: IAuthClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AuthClaim {
        data = typeof data === 'object' ? data : {};
        let result = new AuthClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["value"] = this.value;
        return data;
    }
}

export interface IAuthClaim {
    claim?: string | undefined;
    value?: string | undefined;
}

export class AuthUser implements IAuthUser {
    readonly id?: string | undefined;
    readonly name?: string | undefined;
    readonly displayName?: string | undefined;
    readonly login?: string | undefined;
    readonly mail?: string | undefined;
    readonly organizationCif?: string | undefined;
    readonly organizationCode?: string | undefined;
    readonly organizationName?: string | undefined;
    readonly isAdmin?: boolean;
    userConfiguration?: AuthUserConfiguration;

    constructor(data?: IAuthUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).displayName = _data["displayName"];
            (<any>this).login = _data["login"];
            (<any>this).mail = _data["mail"];
            (<any>this).organizationCif = _data["organizationCif"];
            (<any>this).organizationCode = _data["organizationCode"];
            (<any>this).organizationName = _data["organizationName"];
            (<any>this).isAdmin = _data["isAdmin"];
            this.userConfiguration = _data["userConfiguration"] ? AuthUserConfiguration.fromJS(_data["userConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthUser {
        data = typeof data === 'object' ? data : {};
        let result = new AuthUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["login"] = this.login;
        data["mail"] = this.mail;
        data["organizationCif"] = this.organizationCif;
        data["organizationCode"] = this.organizationCode;
        data["organizationName"] = this.organizationName;
        data["isAdmin"] = this.isAdmin;
        data["userConfiguration"] = this.userConfiguration ? this.userConfiguration.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAuthUser {
    id?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    login?: string | undefined;
    mail?: string | undefined;
    organizationCif?: string | undefined;
    organizationCode?: string | undefined;
    organizationName?: string | undefined;
    isAdmin?: boolean;
    userConfiguration?: AuthUserConfiguration;
}

export class AuthUserConfiguration implements IAuthUserConfiguration {
    rowsPerPage?: number;
    modalRowsPerPage?: number;
    language?: string | undefined;
    lastConnectionDate?: Date | undefined;

    constructor(data?: IAuthUserConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rowsPerPage = _data["rowsPerPage"];
            this.modalRowsPerPage = _data["modalRowsPerPage"];
            this.language = _data["language"];
            this.lastConnectionDate = _data["lastConnectionDate"] ? new Date(_data["lastConnectionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthUserConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new AuthUserConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowsPerPage"] = this.rowsPerPage;
        data["modalRowsPerPage"] = this.modalRowsPerPage;
        data["language"] = this.language;
        data["lastConnectionDate"] = this.lastConnectionDate ? this.lastConnectionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuthUserConfiguration {
    rowsPerPage?: number;
    modalRowsPerPage?: number;
    language?: string | undefined;
    lastConnectionDate?: Date | undefined;
}

export class UserContext implements IUserContext {
    readonly applications?: AuthApplication[] | undefined;
    readonly authenticationType?: string | undefined;
    claims?: AuthClaim[] | undefined;
    user?: AuthUser;

    constructor(data?: IUserContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["applications"])) {
                (<any>this).applications = [] as any;
                for (let item of _data["applications"])
                    (<any>this).applications!.push(AuthApplication.fromJS(item));
            }
            (<any>this).authenticationType = _data["authenticationType"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(AuthClaim.fromJS(item));
            }
            this.user = _data["user"] ? AuthUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserContext {
        data = typeof data === 'object' ? data : {};
        let result = new UserContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.applications)) {
            data["applications"] = [];
            for (let item of this.applications)
                data["applications"].push(item.toJSON());
        }
        data["authenticationType"] = this.authenticationType;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserContext {
    applications?: AuthApplication[] | undefined;
    authenticationType?: string | undefined;
    claims?: AuthClaim[] | undefined;
    user?: AuthUser;
}

export class AplicacionView implements IAplicacionView {
    id?: number;
    descripcion?: string | undefined;
    codigo?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    recargo?: RecargoView[] | undefined;
    tarifa?: TarifaView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView[] | undefined;

    constructor(data?: IAplicacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.codigo = _data["codigo"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["concepto"])) {
                this.concepto = [] as any;
                for (let item of _data["concepto"])
                    this.concepto!.push(ConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["modoCalculo"])) {
                this.modoCalculo = [] as any;
                for (let item of _data["modoCalculo"])
                    this.modoCalculo!.push(ModoCalculoView.fromJS(item));
            }
            if (Array.isArray(_data["recargo"])) {
                this.recargo = [] as any;
                for (let item of _data["recargo"])
                    this.recargo!.push(RecargoView.fromJS(item));
            }
            if (Array.isArray(_data["tarifa"])) {
                this.tarifa = [] as any;
                for (let item of _data["tarifa"])
                    this.tarifa!.push(TarifaView.fromJS(item));
            }
            if (Array.isArray(_data["tipoServicioTarificable"])) {
                this.tipoServicioTarificable = [] as any;
                for (let item of _data["tipoServicioTarificable"])
                    this.tipoServicioTarificable!.push(TipoServicioTarificableView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AplicacionView {
        data = typeof data === 'object' ? data : {};
        let result = new AplicacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["codigo"] = this.codigo;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.concepto)) {
            data["concepto"] = [];
            for (let item of this.concepto)
                data["concepto"].push(item.toJSON());
        }
        if (Array.isArray(this.modoCalculo)) {
            data["modoCalculo"] = [];
            for (let item of this.modoCalculo)
                data["modoCalculo"].push(item.toJSON());
        }
        if (Array.isArray(this.recargo)) {
            data["recargo"] = [];
            for (let item of this.recargo)
                data["recargo"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifa)) {
            data["tarifa"] = [];
            for (let item of this.tarifa)
                data["tarifa"].push(item.toJSON());
        }
        if (Array.isArray(this.tipoServicioTarificable)) {
            data["tipoServicioTarificable"] = [];
            for (let item of this.tipoServicioTarificable)
                data["tipoServicioTarificable"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAplicacionView {
    id?: number;
    descripcion?: string | undefined;
    codigo?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    recargo?: RecargoView[] | undefined;
    tarifa?: TarifaView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView[] | undefined;
}

export class ConceptoTipoServicioTarificableView implements IConceptoTipoServicioTarificableView {
    id?: number;
    conceptoId?: number;
    tipoServicioTarificableId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    tipoServicioTarificable?: TipoServicioTarificableView;

    constructor(data?: IConceptoTipoServicioTarificableView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.conceptoId = _data["conceptoId"];
            this.tipoServicioTarificableId = _data["tipoServicioTarificableId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.concepto = _data["concepto"] ? ConceptoView.fromJS(_data["concepto"]) : <any>undefined;
            this.tipoServicioTarificable = _data["tipoServicioTarificable"] ? TipoServicioTarificableView.fromJS(_data["tipoServicioTarificable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConceptoTipoServicioTarificableView {
        data = typeof data === 'object' ? data : {};
        let result = new ConceptoTipoServicioTarificableView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["conceptoId"] = this.conceptoId;
        data["tipoServicioTarificableId"] = this.tipoServicioTarificableId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["concepto"] = this.concepto ? this.concepto.toJSON() : <any>undefined;
        data["tipoServicioTarificable"] = this.tipoServicioTarificable ? this.tipoServicioTarificable.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConceptoTipoServicioTarificableView {
    id?: number;
    conceptoId?: number;
    tipoServicioTarificableId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    tipoServicioTarificable?: TipoServicioTarificableView;
}

export class ConceptoView implements IConceptoView {
    id?: number;
    aplicacionId?: number;
    tipoTarifaId?: number | undefined;
    tipoConceptoId?: number;
    descripcion?: string | undefined;
    descripcionCorta?: string | undefined;
    identificadorExterno?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoTipoServicioTarificable?: ConceptoTipoServicioTarificableView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    modoCalculoConcepto?: ModoCalculoConceptoView[] | undefined;
    recargo?: RecargoView[] | undefined;
    recargoTipoServicioTarificableConcepto?: RecargoTipoServicioTarificableConceptoView[] | undefined;
    tarifaCalculoDetalleConcepto?: TarifaCalculoDetalleConceptoView[] | undefined;
    tarifaRecargoDetalleConcepto?: TarifaRecargoDetalleConceptoView[] | undefined;
    tipoConcepto?: TipoConceptoView;
    tipoTarifa?: TipoTarifaView;

    constructor(data?: IConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.tipoTarifaId = _data["tipoTarifaId"];
            this.tipoConceptoId = _data["tipoConceptoId"];
            this.descripcion = _data["descripcion"];
            this.descripcionCorta = _data["descripcionCorta"];
            this.identificadorExterno = _data["identificadorExterno"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.aplicacion = _data["aplicacion"] ? AplicacionView.fromJS(_data["aplicacion"]) : <any>undefined;
            if (Array.isArray(_data["conceptoTipoServicioTarificable"])) {
                this.conceptoTipoServicioTarificable = [] as any;
                for (let item of _data["conceptoTipoServicioTarificable"])
                    this.conceptoTipoServicioTarificable!.push(ConceptoTipoServicioTarificableView.fromJS(item));
            }
            if (Array.isArray(_data["modoCalculo"])) {
                this.modoCalculo = [] as any;
                for (let item of _data["modoCalculo"])
                    this.modoCalculo!.push(ModoCalculoView.fromJS(item));
            }
            if (Array.isArray(_data["modoCalculoConcepto"])) {
                this.modoCalculoConcepto = [] as any;
                for (let item of _data["modoCalculoConcepto"])
                    this.modoCalculoConcepto!.push(ModoCalculoConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["recargo"])) {
                this.recargo = [] as any;
                for (let item of _data["recargo"])
                    this.recargo!.push(RecargoView.fromJS(item));
            }
            if (Array.isArray(_data["recargoTipoServicioTarificableConcepto"])) {
                this.recargoTipoServicioTarificableConcepto = [] as any;
                for (let item of _data["recargoTipoServicioTarificableConcepto"])
                    this.recargoTipoServicioTarificableConcepto!.push(RecargoTipoServicioTarificableConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["tarifaCalculoDetalleConcepto"])) {
                this.tarifaCalculoDetalleConcepto = [] as any;
                for (let item of _data["tarifaCalculoDetalleConcepto"])
                    this.tarifaCalculoDetalleConcepto!.push(TarifaCalculoDetalleConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["tarifaRecargoDetalleConcepto"])) {
                this.tarifaRecargoDetalleConcepto = [] as any;
                for (let item of _data["tarifaRecargoDetalleConcepto"])
                    this.tarifaRecargoDetalleConcepto!.push(TarifaRecargoDetalleConceptoView.fromJS(item));
            }
            this.tipoConcepto = _data["tipoConcepto"] ? TipoConceptoView.fromJS(_data["tipoConcepto"]) : <any>undefined;
            this.tipoTarifa = _data["tipoTarifa"] ? TipoTarifaView.fromJS(_data["tipoTarifa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new ConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["tipoTarifaId"] = this.tipoTarifaId;
        data["tipoConceptoId"] = this.tipoConceptoId;
        data["descripcion"] = this.descripcion;
        data["descripcionCorta"] = this.descripcionCorta;
        data["identificadorExterno"] = this.identificadorExterno;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["aplicacion"] = this.aplicacion ? this.aplicacion.toJSON() : <any>undefined;
        if (Array.isArray(this.conceptoTipoServicioTarificable)) {
            data["conceptoTipoServicioTarificable"] = [];
            for (let item of this.conceptoTipoServicioTarificable)
                data["conceptoTipoServicioTarificable"].push(item.toJSON());
        }
        if (Array.isArray(this.modoCalculo)) {
            data["modoCalculo"] = [];
            for (let item of this.modoCalculo)
                data["modoCalculo"].push(item.toJSON());
        }
        if (Array.isArray(this.modoCalculoConcepto)) {
            data["modoCalculoConcepto"] = [];
            for (let item of this.modoCalculoConcepto)
                data["modoCalculoConcepto"].push(item.toJSON());
        }
        if (Array.isArray(this.recargo)) {
            data["recargo"] = [];
            for (let item of this.recargo)
                data["recargo"].push(item.toJSON());
        }
        if (Array.isArray(this.recargoTipoServicioTarificableConcepto)) {
            data["recargoTipoServicioTarificableConcepto"] = [];
            for (let item of this.recargoTipoServicioTarificableConcepto)
                data["recargoTipoServicioTarificableConcepto"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifaCalculoDetalleConcepto)) {
            data["tarifaCalculoDetalleConcepto"] = [];
            for (let item of this.tarifaCalculoDetalleConcepto)
                data["tarifaCalculoDetalleConcepto"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifaRecargoDetalleConcepto)) {
            data["tarifaRecargoDetalleConcepto"] = [];
            for (let item of this.tarifaRecargoDetalleConcepto)
                data["tarifaRecargoDetalleConcepto"].push(item.toJSON());
        }
        data["tipoConcepto"] = this.tipoConcepto ? this.tipoConcepto.toJSON() : <any>undefined;
        data["tipoTarifa"] = this.tipoTarifa ? this.tipoTarifa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConceptoView {
    id?: number;
    aplicacionId?: number;
    tipoTarifaId?: number | undefined;
    tipoConceptoId?: number;
    descripcion?: string | undefined;
    descripcionCorta?: string | undefined;
    identificadorExterno?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoTipoServicioTarificable?: ConceptoTipoServicioTarificableView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    modoCalculoConcepto?: ModoCalculoConceptoView[] | undefined;
    recargo?: RecargoView[] | undefined;
    recargoTipoServicioTarificableConcepto?: RecargoTipoServicioTarificableConceptoView[] | undefined;
    tarifaCalculoDetalleConcepto?: TarifaCalculoDetalleConceptoView[] | undefined;
    tarifaRecargoDetalleConcepto?: TarifaRecargoDetalleConceptoView[] | undefined;
    tipoConcepto?: TipoConceptoView;
    tipoTarifa?: TipoTarifaView;
}

export class ModoCalculoConceptoView implements IModoCalculoConceptoView {
    id?: number;
    modoCalculoId?: number;
    conceptoId?: number;
    esUnRango?: boolean;
    esOpcional?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    modoCalculo?: ModoCalculoView;

    constructor(data?: IModoCalculoConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.modoCalculoId = _data["modoCalculoId"];
            this.conceptoId = _data["conceptoId"];
            this.esUnRango = _data["esUnRango"];
            this.esOpcional = _data["esOpcional"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.concepto = _data["concepto"] ? ConceptoView.fromJS(_data["concepto"]) : <any>undefined;
            this.modoCalculo = _data["modoCalculo"] ? ModoCalculoView.fromJS(_data["modoCalculo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModoCalculoConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new ModoCalculoConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["modoCalculoId"] = this.modoCalculoId;
        data["conceptoId"] = this.conceptoId;
        data["esUnRango"] = this.esUnRango;
        data["esOpcional"] = this.esOpcional;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["concepto"] = this.concepto ? this.concepto.toJSON() : <any>undefined;
        data["modoCalculo"] = this.modoCalculo ? this.modoCalculo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModoCalculoConceptoView {
    id?: number;
    modoCalculoId?: number;
    conceptoId?: number;
    esUnRango?: boolean;
    esOpcional?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    modoCalculo?: ModoCalculoView;
}

export class ModoCalculoView implements IModoCalculoView {
    id?: number;
    aplicacionId?: number;
    tipoServicioTarificableId?: number;
    tipoTarifaId?: number | undefined;
    descripcion?: string | undefined;
    conceptoVariableId?: number | undefined;
    tienePrecioBase?: boolean;
    rangosNoExcluyentes?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoVariable?: ConceptoView;
    modoCalculoConcepto?: ModoCalculoConceptoView[] | undefined;
    tarifaCalculo?: TarifaCalculoView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView;
    tipoTarifa?: TipoTarifaView;

    constructor(data?: IModoCalculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.tipoServicioTarificableId = _data["tipoServicioTarificableId"];
            this.tipoTarifaId = _data["tipoTarifaId"];
            this.descripcion = _data["descripcion"];
            this.conceptoVariableId = _data["conceptoVariableId"];
            this.tienePrecioBase = _data["tienePrecioBase"];
            this.rangosNoExcluyentes = _data["rangosNoExcluyentes"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.aplicacion = _data["aplicacion"] ? AplicacionView.fromJS(_data["aplicacion"]) : <any>undefined;
            this.conceptoVariable = _data["conceptoVariable"] ? ConceptoView.fromJS(_data["conceptoVariable"]) : <any>undefined;
            if (Array.isArray(_data["modoCalculoConcepto"])) {
                this.modoCalculoConcepto = [] as any;
                for (let item of _data["modoCalculoConcepto"])
                    this.modoCalculoConcepto!.push(ModoCalculoConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["tarifaCalculo"])) {
                this.tarifaCalculo = [] as any;
                for (let item of _data["tarifaCalculo"])
                    this.tarifaCalculo!.push(TarifaCalculoView.fromJS(item));
            }
            this.tipoServicioTarificable = _data["tipoServicioTarificable"] ? TipoServicioTarificableView.fromJS(_data["tipoServicioTarificable"]) : <any>undefined;
            this.tipoTarifa = _data["tipoTarifa"] ? TipoTarifaView.fromJS(_data["tipoTarifa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModoCalculoView {
        data = typeof data === 'object' ? data : {};
        let result = new ModoCalculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["tipoServicioTarificableId"] = this.tipoServicioTarificableId;
        data["tipoTarifaId"] = this.tipoTarifaId;
        data["descripcion"] = this.descripcion;
        data["conceptoVariableId"] = this.conceptoVariableId;
        data["tienePrecioBase"] = this.tienePrecioBase;
        data["rangosNoExcluyentes"] = this.rangosNoExcluyentes;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["aplicacion"] = this.aplicacion ? this.aplicacion.toJSON() : <any>undefined;
        data["conceptoVariable"] = this.conceptoVariable ? this.conceptoVariable.toJSON() : <any>undefined;
        if (Array.isArray(this.modoCalculoConcepto)) {
            data["modoCalculoConcepto"] = [];
            for (let item of this.modoCalculoConcepto)
                data["modoCalculoConcepto"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifaCalculo)) {
            data["tarifaCalculo"] = [];
            for (let item of this.tarifaCalculo)
                data["tarifaCalculo"].push(item.toJSON());
        }
        data["tipoServicioTarificable"] = this.tipoServicioTarificable ? this.tipoServicioTarificable.toJSON() : <any>undefined;
        data["tipoTarifa"] = this.tipoTarifa ? this.tipoTarifa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModoCalculoView {
    id?: number;
    aplicacionId?: number;
    tipoServicioTarificableId?: number;
    tipoTarifaId?: number | undefined;
    descripcion?: string | undefined;
    conceptoVariableId?: number | undefined;
    tienePrecioBase?: boolean;
    rangosNoExcluyentes?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoVariable?: ConceptoView;
    modoCalculoConcepto?: ModoCalculoConceptoView[] | undefined;
    tarifaCalculo?: TarifaCalculoView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView;
    tipoTarifa?: TipoTarifaView;
}

export class RecargoTipoServicioTarificableConceptoView implements IRecargoTipoServicioTarificableConceptoView {
    id?: number;
    recargoTipoServicioTarificableId?: number;
    conceptoId?: number;
    esUnRango?: boolean;
    esOpcional?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    recargoTipoServicioTarificable?: RecargoTipoServicioTarificableView;

    constructor(data?: IRecargoTipoServicioTarificableConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recargoTipoServicioTarificableId = _data["recargoTipoServicioTarificableId"];
            this.conceptoId = _data["conceptoId"];
            this.esUnRango = _data["esUnRango"];
            this.esOpcional = _data["esOpcional"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.concepto = _data["concepto"] ? ConceptoView.fromJS(_data["concepto"]) : <any>undefined;
            this.recargoTipoServicioTarificable = _data["recargoTipoServicioTarificable"] ? RecargoTipoServicioTarificableView.fromJS(_data["recargoTipoServicioTarificable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecargoTipoServicioTarificableConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new RecargoTipoServicioTarificableConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recargoTipoServicioTarificableId"] = this.recargoTipoServicioTarificableId;
        data["conceptoId"] = this.conceptoId;
        data["esUnRango"] = this.esUnRango;
        data["esOpcional"] = this.esOpcional;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["concepto"] = this.concepto ? this.concepto.toJSON() : <any>undefined;
        data["recargoTipoServicioTarificable"] = this.recargoTipoServicioTarificable ? this.recargoTipoServicioTarificable.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRecargoTipoServicioTarificableConceptoView {
    id?: number;
    recargoTipoServicioTarificableId?: number;
    conceptoId?: number;
    esUnRango?: boolean;
    esOpcional?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    recargoTipoServicioTarificable?: RecargoTipoServicioTarificableView;
}

export class RecargoTipoServicioTarificableView implements IRecargoTipoServicioTarificableView {
    id?: number;
    recargoId?: number;
    tipoServicioTarificableId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    recargo?: RecargoView;
    recargoTipoServicioTarificableConcepto?: RecargoTipoServicioTarificableConceptoView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView;

    constructor(data?: IRecargoTipoServicioTarificableView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recargoId = _data["recargoId"];
            this.tipoServicioTarificableId = _data["tipoServicioTarificableId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.recargo = _data["recargo"] ? RecargoView.fromJS(_data["recargo"]) : <any>undefined;
            if (Array.isArray(_data["recargoTipoServicioTarificableConcepto"])) {
                this.recargoTipoServicioTarificableConcepto = [] as any;
                for (let item of _data["recargoTipoServicioTarificableConcepto"])
                    this.recargoTipoServicioTarificableConcepto!.push(RecargoTipoServicioTarificableConceptoView.fromJS(item));
            }
            this.tipoServicioTarificable = _data["tipoServicioTarificable"] ? TipoServicioTarificableView.fromJS(_data["tipoServicioTarificable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecargoTipoServicioTarificableView {
        data = typeof data === 'object' ? data : {};
        let result = new RecargoTipoServicioTarificableView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recargoId"] = this.recargoId;
        data["tipoServicioTarificableId"] = this.tipoServicioTarificableId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["recargo"] = this.recargo ? this.recargo.toJSON() : <any>undefined;
        if (Array.isArray(this.recargoTipoServicioTarificableConcepto)) {
            data["recargoTipoServicioTarificableConcepto"] = [];
            for (let item of this.recargoTipoServicioTarificableConcepto)
                data["recargoTipoServicioTarificableConcepto"].push(item.toJSON());
        }
        data["tipoServicioTarificable"] = this.tipoServicioTarificable ? this.tipoServicioTarificable.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRecargoTipoServicioTarificableView {
    id?: number;
    recargoId?: number;
    tipoServicioTarificableId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    recargo?: RecargoView;
    recargoTipoServicioTarificableConcepto?: RecargoTipoServicioTarificableConceptoView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView;
}

export class RecargoView implements IRecargoView {
    id?: number;
    aplicacionId?: number;
    securityCompanyId?: number;
    tipoTarifaId?: number | undefined;
    tipoRecargoId?: number;
    descripcion?: string | undefined;
    codigo?: string | undefined;
    conceptoVariableId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoVariable?: ConceptoView;
    recargoTipoServicioTarificable?: RecargoTipoServicioTarificableView[] | undefined;
    tarifaRecargo?: TarifaRecargoView[] | undefined;
    tipoRecargo?: TipoRecargoView;
    tipoTarifa?: TipoTarifaView;

    constructor(data?: IRecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.tipoTarifaId = _data["tipoTarifaId"];
            this.tipoRecargoId = _data["tipoRecargoId"];
            this.descripcion = _data["descripcion"];
            this.codigo = _data["codigo"];
            this.conceptoVariableId = _data["conceptoVariableId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.aplicacion = _data["aplicacion"] ? AplicacionView.fromJS(_data["aplicacion"]) : <any>undefined;
            this.conceptoVariable = _data["conceptoVariable"] ? ConceptoView.fromJS(_data["conceptoVariable"]) : <any>undefined;
            if (Array.isArray(_data["recargoTipoServicioTarificable"])) {
                this.recargoTipoServicioTarificable = [] as any;
                for (let item of _data["recargoTipoServicioTarificable"])
                    this.recargoTipoServicioTarificable!.push(RecargoTipoServicioTarificableView.fromJS(item));
            }
            if (Array.isArray(_data["tarifaRecargo"])) {
                this.tarifaRecargo = [] as any;
                for (let item of _data["tarifaRecargo"])
                    this.tarifaRecargo!.push(TarifaRecargoView.fromJS(item));
            }
            this.tipoRecargo = _data["tipoRecargo"] ? TipoRecargoView.fromJS(_data["tipoRecargo"]) : <any>undefined;
            this.tipoTarifa = _data["tipoTarifa"] ? TipoTarifaView.fromJS(_data["tipoTarifa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new RecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["securityCompanyId"] = this.securityCompanyId;
        data["tipoTarifaId"] = this.tipoTarifaId;
        data["tipoRecargoId"] = this.tipoRecargoId;
        data["descripcion"] = this.descripcion;
        data["codigo"] = this.codigo;
        data["conceptoVariableId"] = this.conceptoVariableId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["aplicacion"] = this.aplicacion ? this.aplicacion.toJSON() : <any>undefined;
        data["conceptoVariable"] = this.conceptoVariable ? this.conceptoVariable.toJSON() : <any>undefined;
        if (Array.isArray(this.recargoTipoServicioTarificable)) {
            data["recargoTipoServicioTarificable"] = [];
            for (let item of this.recargoTipoServicioTarificable)
                data["recargoTipoServicioTarificable"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifaRecargo)) {
            data["tarifaRecargo"] = [];
            for (let item of this.tarifaRecargo)
                data["tarifaRecargo"].push(item.toJSON());
        }
        data["tipoRecargo"] = this.tipoRecargo ? this.tipoRecargo.toJSON() : <any>undefined;
        data["tipoTarifa"] = this.tipoTarifa ? this.tipoTarifa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRecargoView {
    id?: number;
    aplicacionId?: number;
    securityCompanyId?: number;
    tipoTarifaId?: number | undefined;
    tipoRecargoId?: number;
    descripcion?: string | undefined;
    codigo?: string | undefined;
    conceptoVariableId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoVariable?: ConceptoView;
    recargoTipoServicioTarificable?: RecargoTipoServicioTarificableView[] | undefined;
    tarifaRecargo?: TarifaRecargoView[] | undefined;
    tipoRecargo?: TipoRecargoView;
    tipoTarifa?: TipoTarifaView;
}

export class TarifaCalculoDetalleConceptoView implements ITarifaCalculoDetalleConceptoView {
    valor?: string | undefined;
    valorHasta?: string | undefined;
    esOpcional?: boolean;
    esUnRango?: boolean;
    id?: number;
    tarifaCalculoDetalleId?: number;
    conceptoId?: number;
    elementoId?: number | undefined;
    valorCadena?: string | undefined;
    valorLogico?: boolean | undefined;
    valorEntero?: number | undefined;
    valorEnteroHasta?: number | undefined;
    valorDecimal?: number | undefined;
    valorDecimalHasta?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    tarifaCalculoDetalle?: TarifaCalculoDetalleView;

    constructor(data?: ITarifaCalculoDetalleConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valor = _data["valor"];
            this.valorHasta = _data["valorHasta"];
            this.esOpcional = _data["esOpcional"];
            this.esUnRango = _data["esUnRango"];
            this.id = _data["id"];
            this.tarifaCalculoDetalleId = _data["tarifaCalculoDetalleId"];
            this.conceptoId = _data["conceptoId"];
            this.elementoId = _data["elementoId"];
            this.valorCadena = _data["valorCadena"];
            this.valorLogico = _data["valorLogico"];
            this.valorEntero = _data["valorEntero"];
            this.valorEnteroHasta = _data["valorEnteroHasta"];
            this.valorDecimal = _data["valorDecimal"];
            this.valorDecimalHasta = _data["valorDecimalHasta"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.concepto = _data["concepto"] ? ConceptoView.fromJS(_data["concepto"]) : <any>undefined;
            this.tarifaCalculoDetalle = _data["tarifaCalculoDetalle"] ? TarifaCalculoDetalleView.fromJS(_data["tarifaCalculoDetalle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TarifaCalculoDetalleConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaCalculoDetalleConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valor"] = this.valor;
        data["valorHasta"] = this.valorHasta;
        data["esOpcional"] = this.esOpcional;
        data["esUnRango"] = this.esUnRango;
        data["id"] = this.id;
        data["tarifaCalculoDetalleId"] = this.tarifaCalculoDetalleId;
        data["conceptoId"] = this.conceptoId;
        data["elementoId"] = this.elementoId;
        data["valorCadena"] = this.valorCadena;
        data["valorLogico"] = this.valorLogico;
        data["valorEntero"] = this.valorEntero;
        data["valorEnteroHasta"] = this.valorEnteroHasta;
        data["valorDecimal"] = this.valorDecimal;
        data["valorDecimalHasta"] = this.valorDecimalHasta;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["concepto"] = this.concepto ? this.concepto.toJSON() : <any>undefined;
        data["tarifaCalculoDetalle"] = this.tarifaCalculoDetalle ? this.tarifaCalculoDetalle.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITarifaCalculoDetalleConceptoView {
    valor?: string | undefined;
    valorHasta?: string | undefined;
    esOpcional?: boolean;
    esUnRango?: boolean;
    id?: number;
    tarifaCalculoDetalleId?: number;
    conceptoId?: number;
    elementoId?: number | undefined;
    valorCadena?: string | undefined;
    valorLogico?: boolean | undefined;
    valorEntero?: number | undefined;
    valorEnteroHasta?: number | undefined;
    valorDecimal?: number | undefined;
    valorDecimalHasta?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    tarifaCalculoDetalle?: TarifaCalculoDetalleView;
}

export class TarifaCalculoDetalleView implements ITarifaCalculoDetalleView {
    condicionAplicacion?: string | undefined;
    id?: number;
    tarifaCalculoId?: number;
    orden?: number;
    aplicaCalculoVariable?: boolean;
    valorCalculo?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tarifaCalculo?: TarifaCalculoView;
    tarifaCalculoDetalleConcepto?: TarifaCalculoDetalleConceptoView[] | undefined;

    constructor(data?: ITarifaCalculoDetalleView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.condicionAplicacion = _data["condicionAplicacion"];
            this.id = _data["id"];
            this.tarifaCalculoId = _data["tarifaCalculoId"];
            this.orden = _data["orden"];
            this.aplicaCalculoVariable = _data["aplicaCalculoVariable"];
            this.valorCalculo = _data["valorCalculo"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tarifaCalculo = _data["tarifaCalculo"] ? TarifaCalculoView.fromJS(_data["tarifaCalculo"]) : <any>undefined;
            if (Array.isArray(_data["tarifaCalculoDetalleConcepto"])) {
                this.tarifaCalculoDetalleConcepto = [] as any;
                for (let item of _data["tarifaCalculoDetalleConcepto"])
                    this.tarifaCalculoDetalleConcepto!.push(TarifaCalculoDetalleConceptoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TarifaCalculoDetalleView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaCalculoDetalleView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condicionAplicacion"] = this.condicionAplicacion;
        data["id"] = this.id;
        data["tarifaCalculoId"] = this.tarifaCalculoId;
        data["orden"] = this.orden;
        data["aplicaCalculoVariable"] = this.aplicaCalculoVariable;
        data["valorCalculo"] = this.valorCalculo;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tarifaCalculo"] = this.tarifaCalculo ? this.tarifaCalculo.toJSON() : <any>undefined;
        if (Array.isArray(this.tarifaCalculoDetalleConcepto)) {
            data["tarifaCalculoDetalleConcepto"] = [];
            for (let item of this.tarifaCalculoDetalleConcepto)
                data["tarifaCalculoDetalleConcepto"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITarifaCalculoDetalleView {
    condicionAplicacion?: string | undefined;
    id?: number;
    tarifaCalculoId?: number;
    orden?: number;
    aplicaCalculoVariable?: boolean;
    valorCalculo?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tarifaCalculo?: TarifaCalculoView;
    tarifaCalculoDetalleConcepto?: TarifaCalculoDetalleConceptoView[] | undefined;
}

export class TarifaCalculoView implements ITarifaCalculoView {
    id?: number;
    tarifaServicioId?: number;
    modoCalculoId?: number;
    orden?: number;
    precioBase?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    modoCalculo?: ModoCalculoView;
    tarifaCalculoDetalle?: TarifaCalculoDetalleView[] | undefined;
    tarifaServicio?: TarifaServicioView;

    constructor(data?: ITarifaCalculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tarifaServicioId = _data["tarifaServicioId"];
            this.modoCalculoId = _data["modoCalculoId"];
            this.orden = _data["orden"];
            this.precioBase = _data["precioBase"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.modoCalculo = _data["modoCalculo"] ? ModoCalculoView.fromJS(_data["modoCalculo"]) : <any>undefined;
            if (Array.isArray(_data["tarifaCalculoDetalle"])) {
                this.tarifaCalculoDetalle = [] as any;
                for (let item of _data["tarifaCalculoDetalle"])
                    this.tarifaCalculoDetalle!.push(TarifaCalculoDetalleView.fromJS(item));
            }
            this.tarifaServicio = _data["tarifaServicio"] ? TarifaServicioView.fromJS(_data["tarifaServicio"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TarifaCalculoView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaCalculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tarifaServicioId"] = this.tarifaServicioId;
        data["modoCalculoId"] = this.modoCalculoId;
        data["orden"] = this.orden;
        data["precioBase"] = this.precioBase;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["modoCalculo"] = this.modoCalculo ? this.modoCalculo.toJSON() : <any>undefined;
        if (Array.isArray(this.tarifaCalculoDetalle)) {
            data["tarifaCalculoDetalle"] = [];
            for (let item of this.tarifaCalculoDetalle)
                data["tarifaCalculoDetalle"].push(item.toJSON());
        }
        data["tarifaServicio"] = this.tarifaServicio ? this.tarifaServicio.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITarifaCalculoView {
    id?: number;
    tarifaServicioId?: number;
    modoCalculoId?: number;
    orden?: number;
    precioBase?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    modoCalculo?: ModoCalculoView;
    tarifaCalculoDetalle?: TarifaCalculoDetalleView[] | undefined;
    tarifaServicio?: TarifaServicioView;
}

export class TarifaRecargoDetalleConceptoView implements ITarifaRecargoDetalleConceptoView {
    valor?: string | undefined;
    valorHasta?: string | undefined;
    esOpcional?: boolean;
    esUnRango?: boolean;
    id?: number;
    tarifaRecargoDetalleId?: number;
    conceptoId?: number;
    elementoId?: number | undefined;
    valorCadena?: string | undefined;
    valorLogico?: boolean | undefined;
    valorEntero?: number | undefined;
    valorEnteroHasta?: number | undefined;
    valorDecimal?: number | undefined;
    valorDecimalHasta?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    tarifaRecargoDetalle?: TarifaRecargoDetalleView;

    constructor(data?: ITarifaRecargoDetalleConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valor = _data["valor"];
            this.valorHasta = _data["valorHasta"];
            this.esOpcional = _data["esOpcional"];
            this.esUnRango = _data["esUnRango"];
            this.id = _data["id"];
            this.tarifaRecargoDetalleId = _data["tarifaRecargoDetalleId"];
            this.conceptoId = _data["conceptoId"];
            this.elementoId = _data["elementoId"];
            this.valorCadena = _data["valorCadena"];
            this.valorLogico = _data["valorLogico"];
            this.valorEntero = _data["valorEntero"];
            this.valorEnteroHasta = _data["valorEnteroHasta"];
            this.valorDecimal = _data["valorDecimal"];
            this.valorDecimalHasta = _data["valorDecimalHasta"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.concepto = _data["concepto"] ? ConceptoView.fromJS(_data["concepto"]) : <any>undefined;
            this.tarifaRecargoDetalle = _data["tarifaRecargoDetalle"] ? TarifaRecargoDetalleView.fromJS(_data["tarifaRecargoDetalle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TarifaRecargoDetalleConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaRecargoDetalleConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valor"] = this.valor;
        data["valorHasta"] = this.valorHasta;
        data["esOpcional"] = this.esOpcional;
        data["esUnRango"] = this.esUnRango;
        data["id"] = this.id;
        data["tarifaRecargoDetalleId"] = this.tarifaRecargoDetalleId;
        data["conceptoId"] = this.conceptoId;
        data["elementoId"] = this.elementoId;
        data["valorCadena"] = this.valorCadena;
        data["valorLogico"] = this.valorLogico;
        data["valorEntero"] = this.valorEntero;
        data["valorEnteroHasta"] = this.valorEnteroHasta;
        data["valorDecimal"] = this.valorDecimal;
        data["valorDecimalHasta"] = this.valorDecimalHasta;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["concepto"] = this.concepto ? this.concepto.toJSON() : <any>undefined;
        data["tarifaRecargoDetalle"] = this.tarifaRecargoDetalle ? this.tarifaRecargoDetalle.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITarifaRecargoDetalleConceptoView {
    valor?: string | undefined;
    valorHasta?: string | undefined;
    esOpcional?: boolean;
    esUnRango?: boolean;
    id?: number;
    tarifaRecargoDetalleId?: number;
    conceptoId?: number;
    elementoId?: number | undefined;
    valorCadena?: string | undefined;
    valorLogico?: boolean | undefined;
    valorEntero?: number | undefined;
    valorEnteroHasta?: number | undefined;
    valorDecimal?: number | undefined;
    valorDecimalHasta?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView;
    tarifaRecargoDetalle?: TarifaRecargoDetalleView;
}

export class TarifaRecargoDetalleView implements ITarifaRecargoDetalleView {
    condicionAplicacion?: string | undefined;
    id?: number;
    tarifaRecargoId?: number;
    orden?: number;
    aplicaCalculoVariable?: boolean;
    valorRecargo?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tarifaRecargo?: TarifaRecargoView;
    tarifaRecargoDetalleConcepto?: TarifaRecargoDetalleConceptoView[] | undefined;

    constructor(data?: ITarifaRecargoDetalleView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.condicionAplicacion = _data["condicionAplicacion"];
            this.id = _data["id"];
            this.tarifaRecargoId = _data["tarifaRecargoId"];
            this.orden = _data["orden"];
            this.aplicaCalculoVariable = _data["aplicaCalculoVariable"];
            this.valorRecargo = _data["valorRecargo"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tarifaRecargo = _data["tarifaRecargo"] ? TarifaRecargoView.fromJS(_data["tarifaRecargo"]) : <any>undefined;
            if (Array.isArray(_data["tarifaRecargoDetalleConcepto"])) {
                this.tarifaRecargoDetalleConcepto = [] as any;
                for (let item of _data["tarifaRecargoDetalleConcepto"])
                    this.tarifaRecargoDetalleConcepto!.push(TarifaRecargoDetalleConceptoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TarifaRecargoDetalleView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaRecargoDetalleView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["condicionAplicacion"] = this.condicionAplicacion;
        data["id"] = this.id;
        data["tarifaRecargoId"] = this.tarifaRecargoId;
        data["orden"] = this.orden;
        data["aplicaCalculoVariable"] = this.aplicaCalculoVariable;
        data["valorRecargo"] = this.valorRecargo;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tarifaRecargo"] = this.tarifaRecargo ? this.tarifaRecargo.toJSON() : <any>undefined;
        if (Array.isArray(this.tarifaRecargoDetalleConcepto)) {
            data["tarifaRecargoDetalleConcepto"] = [];
            for (let item of this.tarifaRecargoDetalleConcepto)
                data["tarifaRecargoDetalleConcepto"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITarifaRecargoDetalleView {
    condicionAplicacion?: string | undefined;
    id?: number;
    tarifaRecargoId?: number;
    orden?: number;
    aplicaCalculoVariable?: boolean;
    valorRecargo?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tarifaRecargo?: TarifaRecargoView;
    tarifaRecargoDetalleConcepto?: TarifaRecargoDetalleConceptoView[] | undefined;
}

export class TarifaRecargoView implements ITarifaRecargoView {
    id?: number;
    tarifaServicioId?: number;
    recargoId?: number;
    valorDefecto?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    recargo?: RecargoView;
    tarifaRecargoDetalle?: TarifaRecargoDetalleView[] | undefined;
    tarifaServicio?: TarifaServicioView;

    constructor(data?: ITarifaRecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tarifaServicioId = _data["tarifaServicioId"];
            this.recargoId = _data["recargoId"];
            this.valorDefecto = _data["valorDefecto"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.recargo = _data["recargo"] ? RecargoView.fromJS(_data["recargo"]) : <any>undefined;
            if (Array.isArray(_data["tarifaRecargoDetalle"])) {
                this.tarifaRecargoDetalle = [] as any;
                for (let item of _data["tarifaRecargoDetalle"])
                    this.tarifaRecargoDetalle!.push(TarifaRecargoDetalleView.fromJS(item));
            }
            this.tarifaServicio = _data["tarifaServicio"] ? TarifaServicioView.fromJS(_data["tarifaServicio"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TarifaRecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaRecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tarifaServicioId"] = this.tarifaServicioId;
        data["recargoId"] = this.recargoId;
        data["valorDefecto"] = this.valorDefecto;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["recargo"] = this.recargo ? this.recargo.toJSON() : <any>undefined;
        if (Array.isArray(this.tarifaRecargoDetalle)) {
            data["tarifaRecargoDetalle"] = [];
            for (let item of this.tarifaRecargoDetalle)
                data["tarifaRecargoDetalle"].push(item.toJSON());
        }
        data["tarifaServicio"] = this.tarifaServicio ? this.tarifaServicio.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITarifaRecargoView {
    id?: number;
    tarifaServicioId?: number;
    recargoId?: number;
    valorDefecto?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    recargo?: RecargoView;
    tarifaRecargoDetalle?: TarifaRecargoDetalleView[] | undefined;
    tarifaServicio?: TarifaServicioView;
}

export class TarifaServicioView implements ITarifaServicioView {
    id?: number;
    tarifaId?: number;
    tipoServicioTarificableId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tarifa?: TarifaView;
    tarifaCalculo?: TarifaCalculoView[] | undefined;
    tarifaRecargo?: TarifaRecargoView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView;

    constructor(data?: ITarifaServicioView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tarifaId = _data["tarifaId"];
            this.tipoServicioTarificableId = _data["tipoServicioTarificableId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tarifa = _data["tarifa"] ? TarifaView.fromJS(_data["tarifa"]) : <any>undefined;
            if (Array.isArray(_data["tarifaCalculo"])) {
                this.tarifaCalculo = [] as any;
                for (let item of _data["tarifaCalculo"])
                    this.tarifaCalculo!.push(TarifaCalculoView.fromJS(item));
            }
            if (Array.isArray(_data["tarifaRecargo"])) {
                this.tarifaRecargo = [] as any;
                for (let item of _data["tarifaRecargo"])
                    this.tarifaRecargo!.push(TarifaRecargoView.fromJS(item));
            }
            this.tipoServicioTarificable = _data["tipoServicioTarificable"] ? TipoServicioTarificableView.fromJS(_data["tipoServicioTarificable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TarifaServicioView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaServicioView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tarifaId"] = this.tarifaId;
        data["tipoServicioTarificableId"] = this.tipoServicioTarificableId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tarifa"] = this.tarifa ? this.tarifa.toJSON() : <any>undefined;
        if (Array.isArray(this.tarifaCalculo)) {
            data["tarifaCalculo"] = [];
            for (let item of this.tarifaCalculo)
                data["tarifaCalculo"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifaRecargo)) {
            data["tarifaRecargo"] = [];
            for (let item of this.tarifaRecargo)
                data["tarifaRecargo"].push(item.toJSON());
        }
        data["tipoServicioTarificable"] = this.tipoServicioTarificable ? this.tipoServicioTarificable.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITarifaServicioView {
    id?: number;
    tarifaId?: number;
    tipoServicioTarificableId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tarifa?: TarifaView;
    tarifaCalculo?: TarifaCalculoView[] | undefined;
    tarifaRecargo?: TarifaRecargoView[] | undefined;
    tipoServicioTarificable?: TipoServicioTarificableView;
}

export class TarifaView implements ITarifaView {
    id?: number;
    aplicacionId?: number;
    securityCompanyId?: number;
    tipoTarifaId?: number;
    descripcion?: string | undefined;
    versionKey?: string | undefined;
    versionNumber?: number;
    validityFrom?: Date;
    validityTo?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    tarifaServicio?: TarifaServicioView[] | undefined;
    tipoTarifa?: TipoTarifaView;

    constructor(data?: ITarifaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.tipoTarifaId = _data["tipoTarifaId"];
            this.descripcion = _data["descripcion"];
            this.versionKey = _data["versionKey"];
            this.versionNumber = _data["versionNumber"];
            this.validityFrom = _data["validityFrom"] ? new Date(_data["validityFrom"].toString()) : <any>undefined;
            this.validityTo = _data["validityTo"] ? new Date(_data["validityTo"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.aplicacion = _data["aplicacion"] ? AplicacionView.fromJS(_data["aplicacion"]) : <any>undefined;
            if (Array.isArray(_data["tarifaServicio"])) {
                this.tarifaServicio = [] as any;
                for (let item of _data["tarifaServicio"])
                    this.tarifaServicio!.push(TarifaServicioView.fromJS(item));
            }
            this.tipoTarifa = _data["tipoTarifa"] ? TipoTarifaView.fromJS(_data["tipoTarifa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TarifaView {
        data = typeof data === 'object' ? data : {};
        let result = new TarifaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["securityCompanyId"] = this.securityCompanyId;
        data["tipoTarifaId"] = this.tipoTarifaId;
        data["descripcion"] = this.descripcion;
        data["versionKey"] = this.versionKey;
        data["versionNumber"] = this.versionNumber;
        data["validityFrom"] = this.validityFrom ? this.validityFrom.toISOString() : <any>undefined;
        data["validityTo"] = this.validityTo ? this.validityTo.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["aplicacion"] = this.aplicacion ? this.aplicacion.toJSON() : <any>undefined;
        if (Array.isArray(this.tarifaServicio)) {
            data["tarifaServicio"] = [];
            for (let item of this.tarifaServicio)
                data["tarifaServicio"].push(item.toJSON());
        }
        data["tipoTarifa"] = this.tipoTarifa ? this.tipoTarifa.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITarifaView {
    id?: number;
    aplicacionId?: number;
    securityCompanyId?: number;
    tipoTarifaId?: number;
    descripcion?: string | undefined;
    versionKey?: string | undefined;
    versionNumber?: number;
    validityFrom?: Date;
    validityTo?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    tarifaServicio?: TarifaServicioView[] | undefined;
    tipoTarifa?: TipoTarifaView;
}

export class TipoConceptoView implements ITipoConceptoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView[] | undefined;

    constructor(data?: ITipoConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["concepto"])) {
                this.concepto = [] as any;
                for (let item of _data["concepto"])
                    this.concepto!.push(ConceptoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.concepto)) {
            data["concepto"] = [];
            for (let item of this.concepto)
                data["concepto"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoConceptoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView[] | undefined;
}

export class TipoRecargoView implements ITipoRecargoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    recargo?: RecargoView[] | undefined;

    constructor(data?: ITipoRecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recargo"])) {
                this.recargo = [] as any;
                for (let item of _data["recargo"])
                    this.recargo!.push(RecargoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoRecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoRecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.recargo)) {
            data["recargo"] = [];
            for (let item of this.recargo)
                data["recargo"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoRecargoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    recargo?: RecargoView[] | undefined;
}

export class TipoServicioTarificableView implements ITipoServicioTarificableView {
    id?: number;
    aplicacionId?: number | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoTipoServicioTarificable?: ConceptoTipoServicioTarificableView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    recargoTipoServicioTarificable?: RecargoTipoServicioTarificableView[] | undefined;
    tarifaServicio?: TarifaServicioView[] | undefined;

    constructor(data?: ITipoServicioTarificableView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.aplicacion = _data["aplicacion"] ? AplicacionView.fromJS(_data["aplicacion"]) : <any>undefined;
            if (Array.isArray(_data["conceptoTipoServicioTarificable"])) {
                this.conceptoTipoServicioTarificable = [] as any;
                for (let item of _data["conceptoTipoServicioTarificable"])
                    this.conceptoTipoServicioTarificable!.push(ConceptoTipoServicioTarificableView.fromJS(item));
            }
            if (Array.isArray(_data["modoCalculo"])) {
                this.modoCalculo = [] as any;
                for (let item of _data["modoCalculo"])
                    this.modoCalculo!.push(ModoCalculoView.fromJS(item));
            }
            if (Array.isArray(_data["recargoTipoServicioTarificable"])) {
                this.recargoTipoServicioTarificable = [] as any;
                for (let item of _data["recargoTipoServicioTarificable"])
                    this.recargoTipoServicioTarificable!.push(RecargoTipoServicioTarificableView.fromJS(item));
            }
            if (Array.isArray(_data["tarifaServicio"])) {
                this.tarifaServicio = [] as any;
                for (let item of _data["tarifaServicio"])
                    this.tarifaServicio!.push(TarifaServicioView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoServicioTarificableView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoServicioTarificableView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["aplicacion"] = this.aplicacion ? this.aplicacion.toJSON() : <any>undefined;
        if (Array.isArray(this.conceptoTipoServicioTarificable)) {
            data["conceptoTipoServicioTarificable"] = [];
            for (let item of this.conceptoTipoServicioTarificable)
                data["conceptoTipoServicioTarificable"].push(item.toJSON());
        }
        if (Array.isArray(this.modoCalculo)) {
            data["modoCalculo"] = [];
            for (let item of this.modoCalculo)
                data["modoCalculo"].push(item.toJSON());
        }
        if (Array.isArray(this.recargoTipoServicioTarificable)) {
            data["recargoTipoServicioTarificable"] = [];
            for (let item of this.recargoTipoServicioTarificable)
                data["recargoTipoServicioTarificable"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifaServicio)) {
            data["tarifaServicio"] = [];
            for (let item of this.tarifaServicio)
                data["tarifaServicio"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoServicioTarificableView {
    id?: number;
    aplicacionId?: number | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    aplicacion?: AplicacionView;
    conceptoTipoServicioTarificable?: ConceptoTipoServicioTarificableView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    recargoTipoServicioTarificable?: RecargoTipoServicioTarificableView[] | undefined;
    tarifaServicio?: TarifaServicioView[] | undefined;
}

export class TipoTarifaView implements ITipoTarifaView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    recargo?: RecargoView[] | undefined;
    tarifa?: TarifaView[] | undefined;

    constructor(data?: ITipoTarifaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["concepto"])) {
                this.concepto = [] as any;
                for (let item of _data["concepto"])
                    this.concepto!.push(ConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["modoCalculo"])) {
                this.modoCalculo = [] as any;
                for (let item of _data["modoCalculo"])
                    this.modoCalculo!.push(ModoCalculoView.fromJS(item));
            }
            if (Array.isArray(_data["recargo"])) {
                this.recargo = [] as any;
                for (let item of _data["recargo"])
                    this.recargo!.push(RecargoView.fromJS(item));
            }
            if (Array.isArray(_data["tarifa"])) {
                this.tarifa = [] as any;
                for (let item of _data["tarifa"])
                    this.tarifa!.push(TarifaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoTarifaView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoTarifaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.concepto)) {
            data["concepto"] = [];
            for (let item of this.concepto)
                data["concepto"].push(item.toJSON());
        }
        if (Array.isArray(this.modoCalculo)) {
            data["modoCalculo"] = [];
            for (let item of this.modoCalculo)
                data["modoCalculo"].push(item.toJSON());
        }
        if (Array.isArray(this.recargo)) {
            data["recargo"] = [];
            for (let item of this.recargo)
                data["recargo"].push(item.toJSON());
        }
        if (Array.isArray(this.tarifa)) {
            data["tarifa"] = [];
            for (let item of this.tarifa)
                data["tarifa"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoTarifaView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    concepto?: ConceptoView[] | undefined;
    modoCalculo?: ModoCalculoView[] | undefined;
    recargo?: RecargoView[] | undefined;
    tarifa?: TarifaView[] | undefined;
}

export class VTA_RecargoView implements IVTA_RecargoView {
    id?: number;
    aplicacionId?: number;
    aplicacion?: string | undefined;
    securityCompanyId?: number;
    securityCompany?: string | undefined;
    descripcion?: string | undefined;
    codigo?: string | undefined;
    tipoRecargoId?: number;
    tipoRecargo?: string | undefined;
    tipoTarifaId?: number | undefined;
    tipoTarifa?: string | undefined;
    conceptoVariableId?: number | undefined;
    conceptoVariable?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IVTA_RecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.aplicacion = _data["aplicacion"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.securityCompany = _data["securityCompany"];
            this.descripcion = _data["descripcion"];
            this.codigo = _data["codigo"];
            this.tipoRecargoId = _data["tipoRecargoId"];
            this.tipoRecargo = _data["tipoRecargo"];
            this.tipoTarifaId = _data["tipoTarifaId"];
            this.tipoTarifa = _data["tipoTarifa"];
            this.conceptoVariableId = _data["conceptoVariableId"];
            this.conceptoVariable = _data["conceptoVariable"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_RecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_RecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["aplicacion"] = this.aplicacion;
        data["securityCompanyId"] = this.securityCompanyId;
        data["securityCompany"] = this.securityCompany;
        data["descripcion"] = this.descripcion;
        data["codigo"] = this.codigo;
        data["tipoRecargoId"] = this.tipoRecargoId;
        data["tipoRecargo"] = this.tipoRecargo;
        data["tipoTarifaId"] = this.tipoTarifaId;
        data["tipoTarifa"] = this.tipoTarifa;
        data["conceptoVariableId"] = this.conceptoVariableId;
        data["conceptoVariable"] = this.conceptoVariable;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_RecargoView {
    id?: number;
    aplicacionId?: number;
    aplicacion?: string | undefined;
    securityCompanyId?: number;
    securityCompany?: string | undefined;
    descripcion?: string | undefined;
    codigo?: string | undefined;
    tipoRecargoId?: number;
    tipoRecargo?: string | undefined;
    tipoTarifaId?: number | undefined;
    tipoTarifa?: string | undefined;
    conceptoVariableId?: number | undefined;
    conceptoVariable?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class VTA_TipoServicioTarificableView implements IVTA_TipoServicioTarificableView {
    id?: number;
    aplicacionId?: number;
    aplicationName?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IVTA_TipoServicioTarificableView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.aplicacionId = _data["aplicacionId"];
            this.aplicationName = _data["aplicationName"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_TipoServicioTarificableView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_TipoServicioTarificableView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["aplicacionId"] = this.aplicacionId;
        data["aplicationName"] = this.aplicationName;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_TipoServicioTarificableView {
    id?: number;
    aplicacionId?: number;
    aplicationName?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class EnvioDocumentoExterno implements IEnvioDocumentoExterno {
    serie?: string | undefined;
    numero?: number | undefined;
    numeroAlbaranInicial?: number | undefined;
    inicioPeriodo?: Date | undefined;
    finPeriodo?: Date | undefined;
    agruparPorCliente?: boolean;
    viajesIdList?: number[] | undefined;

    constructor(data?: IEnvioDocumentoExterno) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serie = _data["serie"];
            this.numero = _data["numero"];
            this.numeroAlbaranInicial = _data["numeroAlbaranInicial"];
            this.inicioPeriodo = _data["inicioPeriodo"] ? new Date(_data["inicioPeriodo"].toString()) : <any>undefined;
            this.finPeriodo = _data["finPeriodo"] ? new Date(_data["finPeriodo"].toString()) : <any>undefined;
            this.agruparPorCliente = _data["agruparPorCliente"];
            if (Array.isArray(_data["viajesIdList"])) {
                this.viajesIdList = [] as any;
                for (let item of _data["viajesIdList"])
                    this.viajesIdList!.push(item);
            }
        }
    }

    static fromJS(data: any): EnvioDocumentoExterno {
        data = typeof data === 'object' ? data : {};
        let result = new EnvioDocumentoExterno();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serie"] = this.serie;
        data["numero"] = this.numero;
        data["numeroAlbaranInicial"] = this.numeroAlbaranInicial;
        data["inicioPeriodo"] = this.inicioPeriodo ? formatDate(this.inicioPeriodo) : <any>undefined;
        data["finPeriodo"] = this.finPeriodo ? formatDate(this.finPeriodo) : <any>undefined;
        data["agruparPorCliente"] = this.agruparPorCliente;
        if (Array.isArray(this.viajesIdList)) {
            data["viajesIdList"] = [];
            for (let item of this.viajesIdList)
                data["viajesIdList"].push(item);
        }
        return data;
    }
}

export interface IEnvioDocumentoExterno {
    serie?: string | undefined;
    numero?: number | undefined;
    numeroAlbaranInicial?: number | undefined;
    inicioPeriodo?: Date | undefined;
    finPeriodo?: Date | undefined;
    agruparPorCliente?: boolean;
    viajesIdList?: number[] | undefined;
}

export enum Provider {
    _1 = 1,
    _2 = 2,
}

export class ResultadoEnvioFacturadorExterno implements IResultadoEnvioFacturadorExterno {
    exitoso?: boolean;
    mensaje?: string | undefined;
    mensajeError?: string | undefined;
    archivoContenido?: string | undefined;
    archivoNombre?: string | undefined;
    archivoContentType?: string | undefined;

    constructor(data?: IResultadoEnvioFacturadorExterno) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exitoso = _data["exitoso"];
            this.mensaje = _data["mensaje"];
            this.mensajeError = _data["mensajeError"];
            this.archivoContenido = _data["archivoContenido"];
            this.archivoNombre = _data["archivoNombre"];
            this.archivoContentType = _data["archivoContentType"];
        }
    }

    static fromJS(data: any): ResultadoEnvioFacturadorExterno {
        data = typeof data === 'object' ? data : {};
        let result = new ResultadoEnvioFacturadorExterno();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exitoso"] = this.exitoso;
        data["mensaje"] = this.mensaje;
        data["mensajeError"] = this.mensajeError;
        data["archivoContenido"] = this.archivoContenido;
        data["archivoNombre"] = this.archivoNombre;
        data["archivoContentType"] = this.archivoContentType;
        return data;
    }
}

export interface IResultadoEnvioFacturadorExterno {
    exitoso?: boolean;
    mensaje?: string | undefined;
    mensajeError?: string | undefined;
    archivoContenido?: string | undefined;
    archivoNombre?: string | undefined;
    archivoContentType?: string | undefined;
}

export class CalendarDataDTO implements ICalendarDataDTO {
    eventos?: Eventos[] | undefined;

    constructor(data?: ICalendarDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["eventos"])) {
                this.eventos = [] as any;
                for (let item of _data["eventos"])
                    this.eventos!.push(Eventos.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CalendarDataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarDataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.eventos)) {
            data["eventos"] = [];
            for (let item of this.eventos)
                data["eventos"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICalendarDataDTO {
    eventos?: Eventos[] | undefined;
}

export class Eventos implements IEventos {
    titulo?: string | undefined;
    todoElDia?: boolean;
    tipoEvento?: TipoEventoCalendario;
    inicio?: Date;
    fin?: Date;
    numeroItems?: number;

    constructor(data?: IEventos) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.titulo = _data["titulo"];
            this.todoElDia = _data["todoElDia"];
            this.tipoEvento = _data["tipoEvento"];
            this.inicio = _data["inicio"] ? new Date(_data["inicio"].toString()) : <any>undefined;
            this.fin = _data["fin"] ? new Date(_data["fin"].toString()) : <any>undefined;
            this.numeroItems = _data["numeroItems"];
        }
    }

    static fromJS(data: any): Eventos {
        data = typeof data === 'object' ? data : {};
        let result = new Eventos();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["titulo"] = this.titulo;
        data["todoElDia"] = this.todoElDia;
        data["tipoEvento"] = this.tipoEvento;
        data["inicio"] = this.inicio ? this.inicio.toISOString() : <any>undefined;
        data["fin"] = this.fin ? this.fin.toISOString() : <any>undefined;
        data["numeroItems"] = this.numeroItems;
        return data;
    }
}

export interface IEventos {
    titulo?: string | undefined;
    todoElDia?: boolean;
    tipoEvento?: TipoEventoCalendario;
    inicio?: Date;
    fin?: Date;
    numeroItems?: number;
}

export class RecursosDisponibles implements IRecursosDisponibles {
    empleadoId?: number;
    empleadoNombre?: string | undefined;

    constructor(data?: IRecursosDisponibles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.empleadoId = _data["empleadoId"];
            this.empleadoNombre = _data["empleadoNombre"];
        }
    }

    static fromJS(data: any): RecursosDisponibles {
        data = typeof data === 'object' ? data : {};
        let result = new RecursosDisponibles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empleadoId"] = this.empleadoId;
        data["empleadoNombre"] = this.empleadoNombre;
        return data;
    }
}

export interface IRecursosDisponibles {
    empleadoId?: number;
    empleadoNombre?: string | undefined;
}

export class RecursosUtilizados implements IRecursosUtilizados {
    empleadoId?: number;
    empleadoNombre?: string | undefined;
    fechaInicio?: Date;
    fechaFin?: Date;
    horas?: number;
    mmpp?: boolean;

    constructor(data?: IRecursosUtilizados) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.empleadoId = _data["empleadoId"];
            this.empleadoNombre = _data["empleadoNombre"];
            this.fechaInicio = _data["fechaInicio"] ? new Date(_data["fechaInicio"].toString()) : <any>undefined;
            this.fechaFin = _data["fechaFin"] ? new Date(_data["fechaFin"].toString()) : <any>undefined;
            this.horas = _data["horas"];
            this.mmpp = _data["mmpp"];
        }
    }

    static fromJS(data: any): RecursosUtilizados {
        data = typeof data === 'object' ? data : {};
        let result = new RecursosUtilizados();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["empleadoId"] = this.empleadoId;
        data["empleadoNombre"] = this.empleadoNombre;
        data["fechaInicio"] = this.fechaInicio ? this.fechaInicio.toISOString() : <any>undefined;
        data["fechaFin"] = this.fechaFin ? this.fechaFin.toISOString() : <any>undefined;
        data["horas"] = this.horas;
        data["mmpp"] = this.mmpp;
        return data;
    }
}

export interface IRecursosUtilizados {
    empleadoId?: number;
    empleadoNombre?: string | undefined;
    fechaInicio?: Date;
    fechaFin?: Date;
    horas?: number;
    mmpp?: boolean;
}

export class RevealValueResponse implements IRevealValueResponse {
    value?: string | undefined;

    constructor(data?: IRevealValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): RevealValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RevealValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IRevealValueResponse {
    value?: string | undefined;
}

export class SchedulerDataDTO implements ISchedulerDataDTO {
    recursosUtilizados?: RecursosUtilizados[] | undefined;
    recursosDisponibles?: RecursosDisponibles[] | undefined;

    constructor(data?: ISchedulerDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["recursosUtilizados"])) {
                this.recursosUtilizados = [] as any;
                for (let item of _data["recursosUtilizados"])
                    this.recursosUtilizados!.push(RecursosUtilizados.fromJS(item));
            }
            if (Array.isArray(_data["recursosDisponibles"])) {
                this.recursosDisponibles = [] as any;
                for (let item of _data["recursosDisponibles"])
                    this.recursosDisponibles!.push(RecursosDisponibles.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SchedulerDataDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulerDataDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recursosUtilizados)) {
            data["recursosUtilizados"] = [];
            for (let item of this.recursosUtilizados)
                data["recursosUtilizados"].push(item.toJSON());
        }
        if (Array.isArray(this.recursosDisponibles)) {
            data["recursosDisponibles"] = [];
            for (let item of this.recursosDisponibles)
                data["recursosDisponibles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISchedulerDataDTO {
    recursosUtilizados?: RecursosUtilizados[] | undefined;
    recursosDisponibles?: RecursosDisponibles[] | undefined;
}

export class SendIOAssignmentBatchResponse implements ISendIOAssignmentBatchResponse {
    totalProcessed?: number;
    totalSuccess?: number;
    totalErrors?: number;
    results?: SendIOAssignmentResult[] | undefined;

    constructor(data?: ISendIOAssignmentBatchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProcessed = _data["totalProcessed"];
            this.totalSuccess = _data["totalSuccess"];
            this.totalErrors = _data["totalErrors"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SendIOAssignmentResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendIOAssignmentBatchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SendIOAssignmentBatchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProcessed"] = this.totalProcessed;
        data["totalSuccess"] = this.totalSuccess;
        data["totalErrors"] = this.totalErrors;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendIOAssignmentBatchResponse {
    totalProcessed?: number;
    totalSuccess?: number;
    totalErrors?: number;
    results?: SendIOAssignmentResult[] | undefined;
}

export class SendIOAssignmentResult implements ISendIOAssignmentResult {
    viajeId?: number;
    numeroViaje?: string | undefined;
    success?: boolean;
    errors?: string[] | undefined;
    message?: string | undefined;

    constructor(data?: ISendIOAssignmentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viajeId = _data["viajeId"];
            this.numeroViaje = _data["numeroViaje"];
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): SendIOAssignmentResult {
        data = typeof data === 'object' ? data : {};
        let result = new SendIOAssignmentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viajeId"] = this.viajeId;
        data["numeroViaje"] = this.numeroViaje;
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["message"] = this.message;
        return data;
    }
}

export interface ISendIOAssignmentResult {
    viajeId?: number;
    numeroViaje?: string | undefined;
    success?: boolean;
    errors?: string[] | undefined;
    message?: string | undefined;
}

export enum TipoEventoCalendario {
    _1 = 1,
    _2 = 2,
}

export enum EnumTipoAdjunto {
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class IssueItem implements IIssueItem {
    type?: string | undefined;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    solutions?: string | undefined;

    constructor(data?: IIssueItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.solutions = _data["solutions"];
        }
    }

    static fromJS(data: any): IssueItem {
        data = typeof data === 'object' ? data : {};
        let result = new IssueItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["solutions"] = this.solutions;
        return data;
    }
}

export interface IIssueItem {
    type?: string | undefined;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    solutions?: string | undefined;
}

export class IssueResponseView implements IIssueResponseView {
    issues?: IssueItem[] | undefined;

    constructor(data?: IIssueResponseView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(IssueItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueResponseView {
        data = typeof data === 'object' ? data : {};
        let result = new IssueResponseView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssueResponseView {
    issues?: IssueItem[] | undefined;
}

export class SecurityProfile_SecurityAccessOptionView implements ISecurityProfile_SecurityAccessOptionView {
    id?: number;
    securityProfileId?: number;
    securityAccessOptionId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOption?: SecurityAccessOptionView;
    securityProfile?: SecurityProfileView;

    constructor(data?: ISecurityProfile_SecurityAccessOptionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityProfileId = _data["securityProfileId"];
            this.securityAccessOptionId = _data["securityAccessOptionId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityAccessOption = _data["securityAccessOption"] ? SecurityAccessOptionView.fromJS(_data["securityAccessOption"]) : <any>undefined;
            this.securityProfile = _data["securityProfile"] ? SecurityProfileView.fromJS(_data["securityProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecurityProfile_SecurityAccessOptionView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityProfile_SecurityAccessOptionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityProfileId"] = this.securityProfileId;
        data["securityAccessOptionId"] = this.securityAccessOptionId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityAccessOption"] = this.securityAccessOption ? this.securityAccessOption.toJSON() : <any>undefined;
        data["securityProfile"] = this.securityProfile ? this.securityProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecurityProfile_SecurityAccessOptionView {
    id?: number;
    securityProfileId?: number;
    securityAccessOptionId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOption?: SecurityAccessOptionView;
    securityProfile?: SecurityProfileView;
}

export class AjusteLiquidacionView implements IAjusteLiquidacionView {
    id?: number;
    conductorId?: number;
    descripcion?: string | undefined;
    valor?: number;
    liquidacionId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    conductor?: EmpleadoView;
    liquidacion?: LiquidacionView;

    constructor(data?: IAjusteLiquidacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.conductorId = _data["conductorId"];
            this.descripcion = _data["descripcion"];
            this.valor = _data["valor"];
            this.liquidacionId = _data["liquidacionId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.conductor = _data["conductor"] ? EmpleadoView.fromJS(_data["conductor"]) : <any>undefined;
            this.liquidacion = _data["liquidacion"] ? LiquidacionView.fromJS(_data["liquidacion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AjusteLiquidacionView {
        data = typeof data === 'object' ? data : {};
        let result = new AjusteLiquidacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["conductorId"] = this.conductorId;
        data["descripcion"] = this.descripcion;
        data["valor"] = this.valor;
        data["liquidacionId"] = this.liquidacionId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["conductor"] = this.conductor ? this.conductor.toJSON() : <any>undefined;
        data["liquidacion"] = this.liquidacion ? this.liquidacion.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAjusteLiquidacionView {
    id?: number;
    conductorId?: number;
    descripcion?: string | undefined;
    valor?: number;
    liquidacionId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    conductor?: EmpleadoView;
    liquidacion?: LiquidacionView;
}

export class AreaEmpresaView implements IAreaEmpresaView {
    id?: number;
    areaId?: number;
    empresaId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    area?: AreaView;
    empresa?: EmpresaView;

    constructor(data?: IAreaEmpresaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.empresaId = _data["empresaId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.area = _data["area"] ? AreaView.fromJS(_data["area"]) : <any>undefined;
            this.empresa = _data["empresa"] ? EmpresaView.fromJS(_data["empresa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AreaEmpresaView {
        data = typeof data === 'object' ? data : {};
        let result = new AreaEmpresaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["empresaId"] = this.empresaId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        data["empresa"] = this.empresa ? this.empresa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAreaEmpresaView {
    id?: number;
    areaId?: number;
    empresaId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    area?: AreaView;
    empresa?: EmpresaView;
}

export class AreaLocalidadView implements IAreaLocalidadView {
    id?: number;
    areaId?: number;
    localidadId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    area?: AreaView;
    localidad?: LocalidadView;

    constructor(data?: IAreaLocalidadView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.areaId = _data["areaId"];
            this.localidadId = _data["localidadId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.area = _data["area"] ? AreaView.fromJS(_data["area"]) : <any>undefined;
            this.localidad = _data["localidad"] ? LocalidadView.fromJS(_data["localidad"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AreaLocalidadView {
        data = typeof data === 'object' ? data : {};
        let result = new AreaLocalidadView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["areaId"] = this.areaId;
        data["localidadId"] = this.localidadId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["area"] = this.area ? this.area.toJSON() : <any>undefined;
        data["localidad"] = this.localidad ? this.localidad.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAreaLocalidadView {
    id?: number;
    areaId?: number;
    localidadId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    area?: AreaView;
    localidad?: LocalidadView;
}

export class AreaView implements IAreaView {
    id?: number;
    securityCompanyId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    areaEmpresa?: AreaEmpresaView[] | undefined;
    areaLocalidad?: AreaLocalidadView[] | undefined;

    constructor(data?: IAreaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["areaEmpresa"])) {
                this.areaEmpresa = [] as any;
                for (let item of _data["areaEmpresa"])
                    this.areaEmpresa!.push(AreaEmpresaView.fromJS(item));
            }
            if (Array.isArray(_data["areaLocalidad"])) {
                this.areaLocalidad = [] as any;
                for (let item of _data["areaLocalidad"])
                    this.areaLocalidad!.push(AreaLocalidadView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AreaView {
        data = typeof data === 'object' ? data : {};
        let result = new AreaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.areaEmpresa)) {
            data["areaEmpresa"] = [];
            for (let item of this.areaEmpresa)
                data["areaEmpresa"].push(item.toJSON());
        }
        if (Array.isArray(this.areaLocalidad)) {
            data["areaLocalidad"] = [];
            for (let item of this.areaLocalidad)
                data["areaLocalidad"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAreaView {
    id?: number;
    securityCompanyId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    areaEmpresa?: AreaEmpresaView[] | undefined;
    areaLocalidad?: AreaLocalidadView[] | undefined;
}

export class B2BRouterConfiguracionView implements IB2BRouterConfiguracionView {
    id?: number;
    securityCompanyId?: number;
    esTest?: boolean;
    accountId?: string | undefined;
    accountIdTest?: string | undefined;
    apiKey?: string | undefined;
    apiKeyTest?: string | undefined;
    url?: string | undefined;
    urlTest?: string | undefined;
    webHooksSecretKey?: string | undefined;
    webHooksSecretKeyTest?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IB2BRouterConfiguracionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.esTest = _data["esTest"];
            this.accountId = _data["accountId"];
            this.accountIdTest = _data["accountIdTest"];
            this.apiKey = _data["apiKey"];
            this.apiKeyTest = _data["apiKeyTest"];
            this.url = _data["url"];
            this.urlTest = _data["urlTest"];
            this.webHooksSecretKey = _data["webHooksSecretKey"];
            this.webHooksSecretKeyTest = _data["webHooksSecretKeyTest"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): B2BRouterConfiguracionView {
        data = typeof data === 'object' ? data : {};
        let result = new B2BRouterConfiguracionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["esTest"] = this.esTest;
        data["accountId"] = this.accountId;
        data["accountIdTest"] = this.accountIdTest;
        data["apiKey"] = this.apiKey;
        data["apiKeyTest"] = this.apiKeyTest;
        data["url"] = this.url;
        data["urlTest"] = this.urlTest;
        data["webHooksSecretKey"] = this.webHooksSecretKey;
        data["webHooksSecretKeyTest"] = this.webHooksSecretKeyTest;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IB2BRouterConfiguracionView {
    id?: number;
    securityCompanyId?: number;
    esTest?: boolean;
    accountId?: string | undefined;
    accountIdTest?: string | undefined;
    apiKey?: string | undefined;
    apiKeyTest?: string | undefined;
    url?: string | undefined;
    urlTest?: string | undefined;
    webHooksSecretKey?: string | undefined;
    webHooksSecretKeyTest?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class AttachmentFileView implements IAttachmentFileView {
    id?: number;
    fileContent?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    attachment?: AttachmentView[] | undefined;

    constructor(data?: IAttachmentFileView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileContent = _data["fileContent"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachment"])) {
                this.attachment = [] as any;
                for (let item of _data["attachment"])
                    this.attachment!.push(AttachmentView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttachmentFileView {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentFileView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileContent"] = this.fileContent;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachment)) {
            data["attachment"] = [];
            for (let item of this.attachment)
                data["attachment"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAttachmentFileView {
    id?: number;
    fileContent?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    attachment?: AttachmentView[] | undefined;
}

export class AttachmentTypeView implements IAttachmentTypeView {
    id?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    attachment?: AttachmentView[] | undefined;

    constructor(data?: IAttachmentTypeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachment"])) {
                this.attachment = [] as any;
                for (let item of _data["attachment"])
                    this.attachment!.push(AttachmentView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttachmentTypeView {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentTypeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachment)) {
            data["attachment"] = [];
            for (let item of this.attachment)
                data["attachment"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAttachmentTypeView {
    id?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    attachment?: AttachmentView[] | undefined;
}

export class AttachmentView implements IAttachmentView {
    fileContent?: string | undefined;
    id?: number;
    entityId?: number;
    entityName?: string | undefined;
    entityDescription?: string | undefined;
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    fileSizeKb?: number | undefined;
    attachmentTypeId?: number | undefined;
    attachmentDescription?: string | undefined;
    attachmentFileId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    attachmentFile?: AttachmentFileView;
    attachmentType?: AttachmentTypeView;

    constructor(data?: IAttachmentView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileContent = _data["fileContent"];
            this.id = _data["id"];
            this.entityId = _data["entityId"];
            this.entityName = _data["entityName"];
            this.entityDescription = _data["entityDescription"];
            this.fileName = _data["fileName"];
            this.fileExtension = _data["fileExtension"];
            this.fileSizeKb = _data["fileSizeKb"];
            this.attachmentTypeId = _data["attachmentTypeId"];
            this.attachmentDescription = _data["attachmentDescription"];
            this.attachmentFileId = _data["attachmentFileId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.attachmentFile = _data["attachmentFile"] ? AttachmentFileView.fromJS(_data["attachmentFile"]) : <any>undefined;
            this.attachmentType = _data["attachmentType"] ? AttachmentTypeView.fromJS(_data["attachmentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AttachmentView {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileContent"] = this.fileContent;
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        data["entityName"] = this.entityName;
        data["entityDescription"] = this.entityDescription;
        data["fileName"] = this.fileName;
        data["fileExtension"] = this.fileExtension;
        data["fileSizeKb"] = this.fileSizeKb;
        data["attachmentTypeId"] = this.attachmentTypeId;
        data["attachmentDescription"] = this.attachmentDescription;
        data["attachmentFileId"] = this.attachmentFileId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["attachmentFile"] = this.attachmentFile ? this.attachmentFile.toJSON() : <any>undefined;
        data["attachmentType"] = this.attachmentType ? this.attachmentType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAttachmentView {
    fileContent?: string | undefined;
    id?: number;
    entityId?: number;
    entityName?: string | undefined;
    entityDescription?: string | undefined;
    fileName?: string | undefined;
    fileExtension?: string | undefined;
    fileSizeKb?: number | undefined;
    attachmentTypeId?: number | undefined;
    attachmentDescription?: string | undefined;
    attachmentFileId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    attachmentFile?: AttachmentFileView;
    attachmentType?: AttachmentTypeView;
}

export class SecurityAccessOptionLevelView implements ISecurityAccessOptionLevelView {
    id?: number;
    securityAccessOptionId?: number;
    controller?: string | undefined;
    securityLevel?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOption?: SecurityAccessOptionView;

    constructor(data?: ISecurityAccessOptionLevelView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityAccessOptionId = _data["securityAccessOptionId"];
            this.controller = _data["controller"];
            this.securityLevel = _data["securityLevel"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityAccessOption = _data["securityAccessOption"] ? SecurityAccessOptionView.fromJS(_data["securityAccessOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecurityAccessOptionLevelView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityAccessOptionLevelView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityAccessOptionId"] = this.securityAccessOptionId;
        data["controller"] = this.controller;
        data["securityLevel"] = this.securityLevel;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityAccessOption"] = this.securityAccessOption ? this.securityAccessOption.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecurityAccessOptionLevelView {
    id?: number;
    securityAccessOptionId?: number;
    controller?: string | undefined;
    securityLevel?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOption?: SecurityAccessOptionView;
}

export class SecurityAccessOptionView implements ISecurityAccessOptionView {
    includedInProfile?: boolean | undefined;
    id?: number;
    securityModuleId?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOptionLevel?: SecurityAccessOptionLevelView[] | undefined;
    securityModule?: SecurityModuleView;
    securityProfile_SecurityAccessOption?: SecurityProfile_SecurityAccessOptionView[] | undefined;

    constructor(data?: ISecurityAccessOptionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includedInProfile = _data["includedInProfile"];
            this.id = _data["id"];
            this.securityModuleId = _data["securityModuleId"];
            this.description = _data["description"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["securityAccessOptionLevel"])) {
                this.securityAccessOptionLevel = [] as any;
                for (let item of _data["securityAccessOptionLevel"])
                    this.securityAccessOptionLevel!.push(SecurityAccessOptionLevelView.fromJS(item));
            }
            this.securityModule = _data["securityModule"] ? SecurityModuleView.fromJS(_data["securityModule"]) : <any>undefined;
            if (Array.isArray(_data["securityProfile_SecurityAccessOption"])) {
                this.securityProfile_SecurityAccessOption = [] as any;
                for (let item of _data["securityProfile_SecurityAccessOption"])
                    this.securityProfile_SecurityAccessOption!.push(SecurityProfile_SecurityAccessOptionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityAccessOptionView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityAccessOptionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includedInProfile"] = this.includedInProfile;
        data["id"] = this.id;
        data["securityModuleId"] = this.securityModuleId;
        data["description"] = this.description;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.securityAccessOptionLevel)) {
            data["securityAccessOptionLevel"] = [];
            for (let item of this.securityAccessOptionLevel)
                data["securityAccessOptionLevel"].push(item.toJSON());
        }
        data["securityModule"] = this.securityModule ? this.securityModule.toJSON() : <any>undefined;
        if (Array.isArray(this.securityProfile_SecurityAccessOption)) {
            data["securityProfile_SecurityAccessOption"] = [];
            for (let item of this.securityProfile_SecurityAccessOption)
                data["securityProfile_SecurityAccessOption"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityAccessOptionView {
    includedInProfile?: boolean | undefined;
    id?: number;
    securityModuleId?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOptionLevel?: SecurityAccessOptionLevelView[] | undefined;
    securityModule?: SecurityModuleView;
    securityProfile_SecurityAccessOption?: SecurityProfile_SecurityAccessOptionView[] | undefined;
}

export class SecurityCompanyConfigurationView implements ISecurityCompanyConfigurationView {
    id?: number;
    hostEmail?: string | undefined;
    portEmail?: number | undefined;
    userEmail?: string | undefined;
    passwordEmail?: string | undefined;
    defaultCredentialsEmail?: boolean | undefined;
    sslEmail?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView[] | undefined;

    constructor(data?: ISecurityCompanyConfigurationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.hostEmail = _data["hostEmail"];
            this.portEmail = _data["portEmail"];
            this.userEmail = _data["userEmail"];
            this.passwordEmail = _data["passwordEmail"];
            this.defaultCredentialsEmail = _data["defaultCredentialsEmail"];
            this.sslEmail = _data["sslEmail"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["securityCompany"])) {
                this.securityCompany = [] as any;
                for (let item of _data["securityCompany"])
                    this.securityCompany!.push(SecurityCompanyView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityCompanyConfigurationView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityCompanyConfigurationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["hostEmail"] = this.hostEmail;
        data["portEmail"] = this.portEmail;
        data["userEmail"] = this.userEmail;
        data["passwordEmail"] = this.passwordEmail;
        data["defaultCredentialsEmail"] = this.defaultCredentialsEmail;
        data["sslEmail"] = this.sslEmail;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.securityCompany)) {
            data["securityCompany"] = [];
            for (let item of this.securityCompany)
                data["securityCompany"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityCompanyConfigurationView {
    id?: number;
    hostEmail?: string | undefined;
    portEmail?: number | undefined;
    userEmail?: string | undefined;
    passwordEmail?: string | undefined;
    defaultCredentialsEmail?: boolean | undefined;
    sslEmail?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView[] | undefined;
}

export class SecurityCompanyGroupView implements ISecurityCompanyGroupView {
    id?: number;
    name?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView[] | undefined;

    constructor(data?: ISecurityCompanyGroupView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["securityCompany"])) {
                this.securityCompany = [] as any;
                for (let item of _data["securityCompany"])
                    this.securityCompany!.push(SecurityCompanyView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityCompanyGroupView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityCompanyGroupView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.securityCompany)) {
            data["securityCompany"] = [];
            for (let item of this.securityCompany)
                data["securityCompany"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityCompanyGroupView {
    id?: number;
    name?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView[] | undefined;
}

export class SecurityCompanyView implements ISecurityCompanyView {
    id?: number;
    securityCompanyGroupId?: number;
    name?: string | undefined;
    cif?: string | undefined;
    securityCompanyConfigurationId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompanyConfiguration?: SecurityCompanyConfigurationView;
    securityCompanyGroup?: SecurityCompanyGroupView;
    securityProfile?: SecurityProfileView[] | undefined;
    securityUser?: SecurityUserView[] | undefined;

    constructor(data?: ISecurityCompanyView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyGroupId = _data["securityCompanyGroupId"];
            this.name = _data["name"];
            this.cif = _data["cif"];
            this.securityCompanyConfigurationId = _data["securityCompanyConfigurationId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityCompanyConfiguration = _data["securityCompanyConfiguration"] ? SecurityCompanyConfigurationView.fromJS(_data["securityCompanyConfiguration"]) : <any>undefined;
            this.securityCompanyGroup = _data["securityCompanyGroup"] ? SecurityCompanyGroupView.fromJS(_data["securityCompanyGroup"]) : <any>undefined;
            if (Array.isArray(_data["securityProfile"])) {
                this.securityProfile = [] as any;
                for (let item of _data["securityProfile"])
                    this.securityProfile!.push(SecurityProfileView.fromJS(item));
            }
            if (Array.isArray(_data["securityUser"])) {
                this.securityUser = [] as any;
                for (let item of _data["securityUser"])
                    this.securityUser!.push(SecurityUserView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityCompanyView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityCompanyView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyGroupId"] = this.securityCompanyGroupId;
        data["name"] = this.name;
        data["cif"] = this.cif;
        data["securityCompanyConfigurationId"] = this.securityCompanyConfigurationId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityCompanyConfiguration"] = this.securityCompanyConfiguration ? this.securityCompanyConfiguration.toJSON() : <any>undefined;
        data["securityCompanyGroup"] = this.securityCompanyGroup ? this.securityCompanyGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.securityProfile)) {
            data["securityProfile"] = [];
            for (let item of this.securityProfile)
                data["securityProfile"].push(item.toJSON());
        }
        if (Array.isArray(this.securityUser)) {
            data["securityUser"] = [];
            for (let item of this.securityUser)
                data["securityUser"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityCompanyView {
    id?: number;
    securityCompanyGroupId?: number;
    name?: string | undefined;
    cif?: string | undefined;
    securityCompanyConfigurationId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompanyConfiguration?: SecurityCompanyConfigurationView;
    securityCompanyGroup?: SecurityCompanyGroupView;
    securityProfile?: SecurityProfileView[] | undefined;
    securityUser?: SecurityUserView[] | undefined;
}

export class SecurityModuleView implements ISecurityModuleView {
    id?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOption?: SecurityAccessOptionView[] | undefined;

    constructor(data?: ISecurityModuleView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["securityAccessOption"])) {
                this.securityAccessOption = [] as any;
                for (let item of _data["securityAccessOption"])
                    this.securityAccessOption!.push(SecurityAccessOptionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityModuleView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityModuleView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.securityAccessOption)) {
            data["securityAccessOption"] = [];
            for (let item of this.securityAccessOption)
                data["securityAccessOption"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityModuleView {
    id?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityAccessOption?: SecurityAccessOptionView[] | undefined;
}

export class SecurityProfileView implements ISecurityProfileView {
    securityModule?: SecurityModuleView[] | undefined;
    id?: number;
    securityCompanyId?: number;
    description?: string | undefined;
    rol?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView;
    securityProfile_SecurityAccessOption?: SecurityProfile_SecurityAccessOptionView[] | undefined;

    constructor(data?: ISecurityProfileView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["securityModule"])) {
                this.securityModule = [] as any;
                for (let item of _data["securityModule"])
                    this.securityModule!.push(SecurityModuleView.fromJS(item));
            }
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.description = _data["description"];
            this.rol = _data["rol"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityCompany = _data["securityCompany"] ? SecurityCompanyView.fromJS(_data["securityCompany"]) : <any>undefined;
            if (Array.isArray(_data["securityProfile_SecurityAccessOption"])) {
                this.securityProfile_SecurityAccessOption = [] as any;
                for (let item of _data["securityProfile_SecurityAccessOption"])
                    this.securityProfile_SecurityAccessOption!.push(SecurityProfile_SecurityAccessOptionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityProfileView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityProfileView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.securityModule)) {
            data["securityModule"] = [];
            for (let item of this.securityModule)
                data["securityModule"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["description"] = this.description;
        data["rol"] = this.rol;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityCompany"] = this.securityCompany ? this.securityCompany.toJSON() : <any>undefined;
        if (Array.isArray(this.securityProfile_SecurityAccessOption)) {
            data["securityProfile_SecurityAccessOption"] = [];
            for (let item of this.securityProfile_SecurityAccessOption)
                data["securityProfile_SecurityAccessOption"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityProfileView {
    securityModule?: SecurityModuleView[] | undefined;
    id?: number;
    securityCompanyId?: number;
    description?: string | undefined;
    rol?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView;
    securityProfile_SecurityAccessOption?: SecurityProfile_SecurityAccessOptionView[] | undefined;
}

export class SecurityUserConfigurationView implements ISecurityUserConfigurationView {
    id?: number;
    pagination?: number;
    modalPagination?: number;
    language?: string | undefined;
    lastConnectionDate?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityUser?: SecurityUserView[] | undefined;

    constructor(data?: ISecurityUserConfigurationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pagination = _data["pagination"];
            this.modalPagination = _data["modalPagination"];
            this.language = _data["language"];
            this.lastConnectionDate = _data["lastConnectionDate"] ? new Date(_data["lastConnectionDate"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["securityUser"])) {
                this.securityUser = [] as any;
                for (let item of _data["securityUser"])
                    this.securityUser!.push(SecurityUserView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityUserConfigurationView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserConfigurationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pagination"] = this.pagination;
        data["modalPagination"] = this.modalPagination;
        data["language"] = this.language;
        data["lastConnectionDate"] = this.lastConnectionDate ? this.lastConnectionDate.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.securityUser)) {
            data["securityUser"] = [];
            for (let item of this.securityUser)
                data["securityUser"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityUserConfigurationView {
    id?: number;
    pagination?: number;
    modalPagination?: number;
    language?: string | undefined;
    lastConnectionDate?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityUser?: SecurityUserView[] | undefined;
}

export class SecurityUserGridConfigurationView implements ISecurityUserGridConfigurationView {
    id?: number;
    securityUserId?: number;
    entity?: string | undefined;
    description?: string | undefined;
    defaultConfiguration?: boolean;
    configuration?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityUser?: SecurityUserView;

    constructor(data?: ISecurityUserGridConfigurationView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityUserId = _data["securityUserId"];
            this.entity = _data["entity"];
            this.description = _data["description"];
            this.defaultConfiguration = _data["defaultConfiguration"];
            this.configuration = _data["configuration"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityUser = _data["securityUser"] ? SecurityUserView.fromJS(_data["securityUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecurityUserGridConfigurationView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserGridConfigurationView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityUserId"] = this.securityUserId;
        data["entity"] = this.entity;
        data["description"] = this.description;
        data["defaultConfiguration"] = this.defaultConfiguration;
        data["configuration"] = this.configuration;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityUser"] = this.securityUser ? this.securityUser.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecurityUserGridConfigurationView {
    id?: number;
    securityUserId?: number;
    entity?: string | undefined;
    description?: string | undefined;
    defaultConfiguration?: boolean;
    configuration?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityUser?: SecurityUserView;
}

export class SecurityUserView implements ISecurityUserView {
    id?: number;
    securityCompanyId?: number;
    userIdentifier?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    mail?: string | undefined;
    organizationCif?: string | undefined;
    organizationCode?: string | undefined;
    organizationName?: string | undefined;
    securityUserConfigurationId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView;
    securityUserConfiguration?: SecurityUserConfigurationView;
    securityUserGridConfiguration?: SecurityUserGridConfigurationView[] | undefined;

    constructor(data?: ISecurityUserView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.userIdentifier = _data["userIdentifier"];
            this.login = _data["login"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.mail = _data["mail"];
            this.organizationCif = _data["organizationCif"];
            this.organizationCode = _data["organizationCode"];
            this.organizationName = _data["organizationName"];
            this.securityUserConfigurationId = _data["securityUserConfigurationId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityCompany = _data["securityCompany"] ? SecurityCompanyView.fromJS(_data["securityCompany"]) : <any>undefined;
            this.securityUserConfiguration = _data["securityUserConfiguration"] ? SecurityUserConfigurationView.fromJS(_data["securityUserConfiguration"]) : <any>undefined;
            if (Array.isArray(_data["securityUserGridConfiguration"])) {
                this.securityUserGridConfiguration = [] as any;
                for (let item of _data["securityUserGridConfiguration"])
                    this.securityUserGridConfiguration!.push(SecurityUserGridConfigurationView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityUserView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["userIdentifier"] = this.userIdentifier;
        data["login"] = this.login;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["mail"] = this.mail;
        data["organizationCif"] = this.organizationCif;
        data["organizationCode"] = this.organizationCode;
        data["organizationName"] = this.organizationName;
        data["securityUserConfigurationId"] = this.securityUserConfigurationId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityCompany"] = this.securityCompany ? this.securityCompany.toJSON() : <any>undefined;
        data["securityUserConfiguration"] = this.securityUserConfiguration ? this.securityUserConfiguration.toJSON() : <any>undefined;
        if (Array.isArray(this.securityUserGridConfiguration)) {
            data["securityUserGridConfiguration"] = [];
            for (let item of this.securityUserGridConfiguration)
                data["securityUserGridConfiguration"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityUserView {
    id?: number;
    securityCompanyId?: number;
    userIdentifier?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    mail?: string | undefined;
    organizationCif?: string | undefined;
    organizationCode?: string | undefined;
    organizationName?: string | undefined;
    securityUserConfigurationId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompany?: SecurityCompanyView;
    securityUserConfiguration?: SecurityUserConfigurationView;
    securityUserGridConfiguration?: SecurityUserGridConfigurationView[] | undefined;
}

export class SecurityVersionView implements ISecurityVersionView {
    id?: number;
    version?: string | undefined;
    observations?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: ISecurityVersionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.observations = _data["observations"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SecurityVersionView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityVersionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["observations"] = this.observations;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISecurityVersionView {
    id?: number;
    version?: string | undefined;
    observations?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class ClasificacionContenedorView implements IClasificacionContenedorView {
    id?: number;
    descripcion?: string | undefined;
    numTeus?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoCodigoISO?: TipoCodigoISOView[] | undefined;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;

    constructor(data?: IClasificacionContenedorView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.numTeus = _data["numTeus"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["tipoCodigoISO"])) {
                this.tipoCodigoISO = [] as any;
                for (let item of _data["tipoCodigoISO"])
                    this.tipoCodigoISO!.push(TipoCodigoISOView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamiento"])) {
                this.viajeEquipamiento = [] as any;
                for (let item of _data["viajeEquipamiento"])
                    this.viajeEquipamiento!.push(ViajeEquipamientoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClasificacionContenedorView {
        data = typeof data === 'object' ? data : {};
        let result = new ClasificacionContenedorView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["numTeus"] = this.numTeus;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.tipoCodigoISO)) {
            data["tipoCodigoISO"] = [];
            for (let item of this.tipoCodigoISO)
                data["tipoCodigoISO"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamiento)) {
            data["viajeEquipamiento"] = [];
            for (let item of this.viajeEquipamiento)
                data["viajeEquipamiento"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClasificacionContenedorView {
    id?: number;
    descripcion?: string | undefined;
    numTeus?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoCodigoISO?: TipoCodigoISOView[] | undefined;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
}

export class ClasificacionVehiculoView implements IClasificacionVehiculoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView[] | undefined;

    constructor(data?: IClasificacionVehiculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["vehiculo"])) {
                this.vehiculo = [] as any;
                for (let item of _data["vehiculo"])
                    this.vehiculo!.push(VehiculoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClasificacionVehiculoView {
        data = typeof data === 'object' ? data : {};
        let result = new ClasificacionVehiculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.vehiculo)) {
            data["vehiculo"] = [];
            for (let item of this.vehiculo)
                data["vehiculo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClasificacionVehiculoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView[] | undefined;
}

export class DistanciaView implements IDistanciaView {
    id?: number;
    localidadOrigenId?: number;
    localidadDestinoId?: number;
    ruta?: string | undefined;
    km?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidadDestino?: LocalidadView;
    localidadOrigen?: LocalidadView;
    viajeCargador?: ViajeCargadorView[] | undefined;

    constructor(data?: IDistanciaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localidadOrigenId = _data["localidadOrigenId"];
            this.localidadDestinoId = _data["localidadDestinoId"];
            this.ruta = _data["ruta"];
            this.km = _data["km"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.localidadDestino = _data["localidadDestino"] ? LocalidadView.fromJS(_data["localidadDestino"]) : <any>undefined;
            this.localidadOrigen = _data["localidadOrigen"] ? LocalidadView.fromJS(_data["localidadOrigen"]) : <any>undefined;
            if (Array.isArray(_data["viajeCargador"])) {
                this.viajeCargador = [] as any;
                for (let item of _data["viajeCargador"])
                    this.viajeCargador!.push(ViajeCargadorView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DistanciaView {
        data = typeof data === 'object' ? data : {};
        let result = new DistanciaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localidadOrigenId"] = this.localidadOrigenId;
        data["localidadDestinoId"] = this.localidadDestinoId;
        data["ruta"] = this.ruta;
        data["km"] = this.km;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["localidadDestino"] = this.localidadDestino ? this.localidadDestino.toJSON() : <any>undefined;
        data["localidadOrigen"] = this.localidadOrigen ? this.localidadOrigen.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeCargador)) {
            data["viajeCargador"] = [];
            for (let item of this.viajeCargador)
                data["viajeCargador"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDistanciaView {
    id?: number;
    localidadOrigenId?: number;
    localidadDestinoId?: number;
    ruta?: string | undefined;
    km?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidadDestino?: LocalidadView;
    localidadOrigen?: LocalidadView;
    viajeCargador?: ViajeCargadorView[] | undefined;
}

export class EmpleadoContratoView implements IEmpleadoContratoView {
    id?: number;
    empleadoId?: number;
    tipoContrato?: string | undefined;
    puesto?: string | undefined;
    categoria?: string | undefined;
    fechaAlta?: Date;
    fechaBaja?: Date | undefined;
    fechaAntiguedad?: Date | undefined;
    fechaPeriodoPruebaHasta?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;

    constructor(data?: IEmpleadoContratoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empleadoId = _data["empleadoId"];
            this.tipoContrato = _data["tipoContrato"];
            this.puesto = _data["puesto"];
            this.categoria = _data["categoria"];
            this.fechaAlta = _data["fechaAlta"] ? new Date(_data["fechaAlta"].toString()) : <any>undefined;
            this.fechaBaja = _data["fechaBaja"] ? new Date(_data["fechaBaja"].toString()) : <any>undefined;
            this.fechaAntiguedad = _data["fechaAntiguedad"] ? new Date(_data["fechaAntiguedad"].toString()) : <any>undefined;
            this.fechaPeriodoPruebaHasta = _data["fechaPeriodoPruebaHasta"] ? new Date(_data["fechaPeriodoPruebaHasta"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empleado = _data["empleado"] ? EmpleadoView.fromJS(_data["empleado"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmpleadoContratoView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadoContratoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empleadoId"] = this.empleadoId;
        data["tipoContrato"] = this.tipoContrato;
        data["puesto"] = this.puesto;
        data["categoria"] = this.categoria;
        data["fechaAlta"] = this.fechaAlta ? this.fechaAlta.toISOString() : <any>undefined;
        data["fechaBaja"] = this.fechaBaja ? this.fechaBaja.toISOString() : <any>undefined;
        data["fechaAntiguedad"] = this.fechaAntiguedad ? this.fechaAntiguedad.toISOString() : <any>undefined;
        data["fechaPeriodoPruebaHasta"] = this.fechaPeriodoPruebaHasta ? this.fechaPeriodoPruebaHasta.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empleado"] = this.empleado ? this.empleado.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmpleadoContratoView {
    id?: number;
    empleadoId?: number;
    tipoContrato?: string | undefined;
    puesto?: string | undefined;
    categoria?: string | undefined;
    fechaAlta?: Date;
    fechaBaja?: Date | undefined;
    fechaAntiguedad?: Date | undefined;
    fechaPeriodoPruebaHasta?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;
}

export class EmpleadoDatosCarnetView implements IEmpleadoDatosCarnetView {
    id?: number;
    empleadoId?: number;
    tipoCarnetId?: number;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    numeroDocumento?: string | undefined;
    empleado?: EmpleadoView;
    tipoCarnet?: TipoCarnetView;

    constructor(data?: IEmpleadoDatosCarnetView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empleadoId = _data["empleadoId"];
            this.tipoCarnetId = _data["tipoCarnetId"];
            this.fechaCaducidad = _data["fechaCaducidad"] ? new Date(_data["fechaCaducidad"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.numeroDocumento = _data["numeroDocumento"];
            this.empleado = _data["empleado"] ? EmpleadoView.fromJS(_data["empleado"]) : <any>undefined;
            this.tipoCarnet = _data["tipoCarnet"] ? TipoCarnetView.fromJS(_data["tipoCarnet"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmpleadoDatosCarnetView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadoDatosCarnetView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empleadoId"] = this.empleadoId;
        data["tipoCarnetId"] = this.tipoCarnetId;
        data["fechaCaducidad"] = this.fechaCaducidad ? this.fechaCaducidad.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["numeroDocumento"] = this.numeroDocumento;
        data["empleado"] = this.empleado ? this.empleado.toJSON() : <any>undefined;
        data["tipoCarnet"] = this.tipoCarnet ? this.tipoCarnet.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmpleadoDatosCarnetView {
    id?: number;
    empleadoId?: number;
    tipoCarnetId?: number;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    numeroDocumento?: string | undefined;
    empleado?: EmpleadoView;
    tipoCarnet?: TipoCarnetView;
}

export class EmpleadoDireccionView implements IEmpleadoDireccionView {
    id?: number;
    empleadoId?: number;
    direccion?: string | undefined;
    codigoPostal?: string | undefined;
    localidadId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;
    localidad?: LocalidadView;

    constructor(data?: IEmpleadoDireccionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empleadoId = _data["empleadoId"];
            this.direccion = _data["direccion"];
            this.codigoPostal = _data["codigoPostal"];
            this.localidadId = _data["localidadId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empleado = _data["empleado"] ? EmpleadoView.fromJS(_data["empleado"]) : <any>undefined;
            this.localidad = _data["localidad"] ? LocalidadView.fromJS(_data["localidad"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmpleadoDireccionView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadoDireccionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empleadoId"] = this.empleadoId;
        data["direccion"] = this.direccion;
        data["codigoPostal"] = this.codigoPostal;
        data["localidadId"] = this.localidadId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empleado"] = this.empleado ? this.empleado.toJSON() : <any>undefined;
        data["localidad"] = this.localidad ? this.localidad.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmpleadoDireccionView {
    id?: number;
    empleadoId?: number;
    direccion?: string | undefined;
    codigoPostal?: string | undefined;
    localidadId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;
    localidad?: LocalidadView;
}

export class EmpleadoFormacionView implements IEmpleadoFormacionView {
    id?: number;
    empleadoId?: number;
    nombre?: string | undefined;
    lugar?: string | undefined;
    fechaInicio?: Date;
    fechaFin?: Date | undefined;
    fechaVerificacion?: Date | undefined;
    verificacionEficacia?: boolean;
    numTotalHoras?: number;
    programa?: string | undefined;
    observaciones?: string | undefined;
    experienciaPrevia?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;

    constructor(data?: IEmpleadoFormacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empleadoId = _data["empleadoId"];
            this.nombre = _data["nombre"];
            this.lugar = _data["lugar"];
            this.fechaInicio = _data["fechaInicio"] ? new Date(_data["fechaInicio"].toString()) : <any>undefined;
            this.fechaFin = _data["fechaFin"] ? new Date(_data["fechaFin"].toString()) : <any>undefined;
            this.fechaVerificacion = _data["fechaVerificacion"] ? new Date(_data["fechaVerificacion"].toString()) : <any>undefined;
            this.verificacionEficacia = _data["verificacionEficacia"];
            this.numTotalHoras = _data["numTotalHoras"];
            this.programa = _data["programa"];
            this.observaciones = _data["observaciones"];
            this.experienciaPrevia = _data["experienciaPrevia"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empleado = _data["empleado"] ? EmpleadoView.fromJS(_data["empleado"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmpleadoFormacionView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadoFormacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empleadoId"] = this.empleadoId;
        data["nombre"] = this.nombre;
        data["lugar"] = this.lugar;
        data["fechaInicio"] = this.fechaInicio ? this.fechaInicio.toISOString() : <any>undefined;
        data["fechaFin"] = this.fechaFin ? this.fechaFin.toISOString() : <any>undefined;
        data["fechaVerificacion"] = this.fechaVerificacion ? this.fechaVerificacion.toISOString() : <any>undefined;
        data["verificacionEficacia"] = this.verificacionEficacia;
        data["numTotalHoras"] = this.numTotalHoras;
        data["programa"] = this.programa;
        data["observaciones"] = this.observaciones;
        data["experienciaPrevia"] = this.experienciaPrevia;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empleado"] = this.empleado ? this.empleado.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmpleadoFormacionView {
    id?: number;
    empleadoId?: number;
    nombre?: string | undefined;
    lugar?: string | undefined;
    fechaInicio?: Date;
    fechaFin?: Date | undefined;
    fechaVerificacion?: Date | undefined;
    verificacionEficacia?: boolean;
    numTotalHoras?: number;
    programa?: string | undefined;
    observaciones?: string | undefined;
    experienciaPrevia?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;
}

export class EmpleadoTacografoView implements IEmpleadoTacografoView {
    id?: number;
    empleadoId?: number;
    numeroTacografo?: string | undefined;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;

    constructor(data?: IEmpleadoTacografoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empleadoId = _data["empleadoId"];
            this.numeroTacografo = _data["numeroTacografo"];
            this.fechaCaducidad = _data["fechaCaducidad"] ? new Date(_data["fechaCaducidad"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empleado = _data["empleado"] ? EmpleadoView.fromJS(_data["empleado"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmpleadoTacografoView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadoTacografoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empleadoId"] = this.empleadoId;
        data["numeroTacografo"] = this.numeroTacografo;
        data["fechaCaducidad"] = this.fechaCaducidad ? this.fechaCaducidad.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empleado"] = this.empleado ? this.empleado.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmpleadoTacografoView {
    id?: number;
    empleadoId?: number;
    numeroTacografo?: string | undefined;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView;
}

export class EmpleadoView implements IEmpleadoView {
    id?: number;
    securityCompanyId?: number;
    numeroDocumento?: string | undefined;
    nombre?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    tipoEmpleadoId?: number | undefined;
    vehiculoAsociadoId?: number | undefined;
    esPropio?: boolean;
    empresaAjenaId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    liquidarAEmpresaAjena?: boolean;
    versionKeyExtTarifa?: string | undefined;
    numeroSS?: string | undefined;
    estadoCivilId?: number | undefined;
    puntosCarnet?: number | undefined;
    fechaActualizacionPuntos?: Date | undefined;
    graduacionVisual?: string | undefined;
    antecedentes?: boolean;
    observaciones?: string | undefined;
    codigoInterno?: string | undefined;
    telefonoEmpresa?: string | undefined;
    fechaNacimiento?: Date | undefined;
    ajusteLiquidacion?: AjusteLiquidacionView[] | undefined;
    empleadoContrato?: EmpleadoContratoView[] | undefined;
    empleadoDatosCarnet?: EmpleadoDatosCarnetView[] | undefined;
    empleadoDireccion?: EmpleadoDireccionView;
    empleadoFormacion?: EmpleadoFormacionView[] | undefined;
    empleadoTacografo?: EmpleadoTacografoView;
    empresaAjena?: EmpresaView;
    estadoCivil?: EstadoCivilView;
    liquidacion?: LiquidacionView[] | undefined;
    tipoEmpleado?: TipoEmpleadoView;
    vehiculoAsociado?: VehiculoView;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;

    constructor(data?: IEmpleadoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.numeroDocumento = _data["numeroDocumento"];
            this.nombre = _data["nombre"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.tipoEmpleadoId = _data["tipoEmpleadoId"];
            this.vehiculoAsociadoId = _data["vehiculoAsociadoId"];
            this.esPropio = _data["esPropio"];
            this.empresaAjenaId = _data["empresaAjenaId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.liquidarAEmpresaAjena = _data["liquidarAEmpresaAjena"];
            this.versionKeyExtTarifa = _data["versionKeyExtTarifa"];
            this.numeroSS = _data["numeroSS"];
            this.estadoCivilId = _data["estadoCivilId"];
            this.puntosCarnet = _data["puntosCarnet"];
            this.fechaActualizacionPuntos = _data["fechaActualizacionPuntos"] ? new Date(_data["fechaActualizacionPuntos"].toString()) : <any>undefined;
            this.graduacionVisual = _data["graduacionVisual"];
            this.antecedentes = _data["antecedentes"];
            this.observaciones = _data["observaciones"];
            this.codigoInterno = _data["codigoInterno"];
            this.telefonoEmpresa = _data["telefonoEmpresa"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? new Date(_data["fechaNacimiento"].toString()) : <any>undefined;
            if (Array.isArray(_data["ajusteLiquidacion"])) {
                this.ajusteLiquidacion = [] as any;
                for (let item of _data["ajusteLiquidacion"])
                    this.ajusteLiquidacion!.push(AjusteLiquidacionView.fromJS(item));
            }
            if (Array.isArray(_data["empleadoContrato"])) {
                this.empleadoContrato = [] as any;
                for (let item of _data["empleadoContrato"])
                    this.empleadoContrato!.push(EmpleadoContratoView.fromJS(item));
            }
            if (Array.isArray(_data["empleadoDatosCarnet"])) {
                this.empleadoDatosCarnet = [] as any;
                for (let item of _data["empleadoDatosCarnet"])
                    this.empleadoDatosCarnet!.push(EmpleadoDatosCarnetView.fromJS(item));
            }
            this.empleadoDireccion = _data["empleadoDireccion"] ? EmpleadoDireccionView.fromJS(_data["empleadoDireccion"]) : <any>undefined;
            if (Array.isArray(_data["empleadoFormacion"])) {
                this.empleadoFormacion = [] as any;
                for (let item of _data["empleadoFormacion"])
                    this.empleadoFormacion!.push(EmpleadoFormacionView.fromJS(item));
            }
            this.empleadoTacografo = _data["empleadoTacografo"] ? EmpleadoTacografoView.fromJS(_data["empleadoTacografo"]) : <any>undefined;
            this.empresaAjena = _data["empresaAjena"] ? EmpresaView.fromJS(_data["empresaAjena"]) : <any>undefined;
            this.estadoCivil = _data["estadoCivil"] ? EstadoCivilView.fromJS(_data["estadoCivil"]) : <any>undefined;
            if (Array.isArray(_data["liquidacion"])) {
                this.liquidacion = [] as any;
                for (let item of _data["liquidacion"])
                    this.liquidacion!.push(LiquidacionView.fromJS(item));
            }
            this.tipoEmpleado = _data["tipoEmpleado"] ? TipoEmpleadoView.fromJS(_data["tipoEmpleado"]) : <any>undefined;
            this.vehiculoAsociado = _data["vehiculoAsociado"] ? VehiculoView.fromJS(_data["vehiculoAsociado"]) : <any>undefined;
            if (Array.isArray(_data["viajeConductorVehiculo"])) {
                this.viajeConductorVehiculo = [] as any;
                for (let item of _data["viajeConductorVehiculo"])
                    this.viajeConductorVehiculo!.push(ViajeConductorVehiculoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmpleadoView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpleadoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["numeroDocumento"] = this.numeroDocumento;
        data["nombre"] = this.nombre;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["tipoEmpleadoId"] = this.tipoEmpleadoId;
        data["vehiculoAsociadoId"] = this.vehiculoAsociadoId;
        data["esPropio"] = this.esPropio;
        data["empresaAjenaId"] = this.empresaAjenaId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["liquidarAEmpresaAjena"] = this.liquidarAEmpresaAjena;
        data["versionKeyExtTarifa"] = this.versionKeyExtTarifa;
        data["numeroSS"] = this.numeroSS;
        data["estadoCivilId"] = this.estadoCivilId;
        data["puntosCarnet"] = this.puntosCarnet;
        data["fechaActualizacionPuntos"] = this.fechaActualizacionPuntos ? this.fechaActualizacionPuntos.toISOString() : <any>undefined;
        data["graduacionVisual"] = this.graduacionVisual;
        data["antecedentes"] = this.antecedentes;
        data["observaciones"] = this.observaciones;
        data["codigoInterno"] = this.codigoInterno;
        data["telefonoEmpresa"] = this.telefonoEmpresa;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        if (Array.isArray(this.ajusteLiquidacion)) {
            data["ajusteLiquidacion"] = [];
            for (let item of this.ajusteLiquidacion)
                data["ajusteLiquidacion"].push(item.toJSON());
        }
        if (Array.isArray(this.empleadoContrato)) {
            data["empleadoContrato"] = [];
            for (let item of this.empleadoContrato)
                data["empleadoContrato"].push(item.toJSON());
        }
        if (Array.isArray(this.empleadoDatosCarnet)) {
            data["empleadoDatosCarnet"] = [];
            for (let item of this.empleadoDatosCarnet)
                data["empleadoDatosCarnet"].push(item.toJSON());
        }
        data["empleadoDireccion"] = this.empleadoDireccion ? this.empleadoDireccion.toJSON() : <any>undefined;
        if (Array.isArray(this.empleadoFormacion)) {
            data["empleadoFormacion"] = [];
            for (let item of this.empleadoFormacion)
                data["empleadoFormacion"].push(item.toJSON());
        }
        data["empleadoTacografo"] = this.empleadoTacografo ? this.empleadoTacografo.toJSON() : <any>undefined;
        data["empresaAjena"] = this.empresaAjena ? this.empresaAjena.toJSON() : <any>undefined;
        data["estadoCivil"] = this.estadoCivil ? this.estadoCivil.toJSON() : <any>undefined;
        if (Array.isArray(this.liquidacion)) {
            data["liquidacion"] = [];
            for (let item of this.liquidacion)
                data["liquidacion"].push(item.toJSON());
        }
        data["tipoEmpleado"] = this.tipoEmpleado ? this.tipoEmpleado.toJSON() : <any>undefined;
        data["vehiculoAsociado"] = this.vehiculoAsociado ? this.vehiculoAsociado.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeConductorVehiculo)) {
            data["viajeConductorVehiculo"] = [];
            for (let item of this.viajeConductorVehiculo)
                data["viajeConductorVehiculo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmpleadoView {
    id?: number;
    securityCompanyId?: number;
    numeroDocumento?: string | undefined;
    nombre?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    tipoEmpleadoId?: number | undefined;
    vehiculoAsociadoId?: number | undefined;
    esPropio?: boolean;
    empresaAjenaId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    liquidarAEmpresaAjena?: boolean;
    versionKeyExtTarifa?: string | undefined;
    numeroSS?: string | undefined;
    estadoCivilId?: number | undefined;
    puntosCarnet?: number | undefined;
    fechaActualizacionPuntos?: Date | undefined;
    graduacionVisual?: string | undefined;
    antecedentes?: boolean;
    observaciones?: string | undefined;
    codigoInterno?: string | undefined;
    telefonoEmpresa?: string | undefined;
    fechaNacimiento?: Date | undefined;
    ajusteLiquidacion?: AjusteLiquidacionView[] | undefined;
    empleadoContrato?: EmpleadoContratoView[] | undefined;
    empleadoDatosCarnet?: EmpleadoDatosCarnetView[] | undefined;
    empleadoDireccion?: EmpleadoDireccionView;
    empleadoFormacion?: EmpleadoFormacionView[] | undefined;
    empleadoTacografo?: EmpleadoTacografoView;
    empresaAjena?: EmpresaView;
    estadoCivil?: EstadoCivilView;
    liquidacion?: LiquidacionView[] | undefined;
    tipoEmpleado?: TipoEmpleadoView;
    vehiculoAsociado?: VehiculoView;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;
}

export class EmpresaDireccionView implements IEmpresaDireccionView {
    id?: number;
    empresaId?: number;
    direccion?: string | undefined;
    codigoPostal?: string | undefined;
    localidadId?: number;
    porDefecto?: boolean;
    tipoDireccionId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView;
    localidad?: LocalidadView;
    tipoDireccion?: TipoDireccionView;
    viajeAgente?: ViajeAgenteView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;

    constructor(data?: IEmpresaDireccionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empresaId = _data["empresaId"];
            this.direccion = _data["direccion"];
            this.codigoPostal = _data["codigoPostal"];
            this.localidadId = _data["localidadId"];
            this.porDefecto = _data["porDefecto"];
            this.tipoDireccionId = _data["tipoDireccionId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empresa = _data["empresa"] ? EmpresaView.fromJS(_data["empresa"]) : <any>undefined;
            this.localidad = _data["localidad"] ? LocalidadView.fromJS(_data["localidad"]) : <any>undefined;
            this.tipoDireccion = _data["tipoDireccion"] ? TipoDireccionView.fromJS(_data["tipoDireccion"]) : <any>undefined;
            if (Array.isArray(_data["viajeAgente"])) {
                this.viajeAgente = [] as any;
                for (let item of _data["viajeAgente"])
                    this.viajeAgente!.push(ViajeAgenteView.fromJS(item));
            }
            if (Array.isArray(_data["viajeCargador"])) {
                this.viajeCargador = [] as any;
                for (let item of _data["viajeCargador"])
                    this.viajeCargador!.push(ViajeCargadorView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmpresaDireccionView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpresaDireccionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empresaId"] = this.empresaId;
        data["direccion"] = this.direccion;
        data["codigoPostal"] = this.codigoPostal;
        data["localidadId"] = this.localidadId;
        data["porDefecto"] = this.porDefecto;
        data["tipoDireccionId"] = this.tipoDireccionId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empresa"] = this.empresa ? this.empresa.toJSON() : <any>undefined;
        data["localidad"] = this.localidad ? this.localidad.toJSON() : <any>undefined;
        data["tipoDireccion"] = this.tipoDireccion ? this.tipoDireccion.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeAgente)) {
            data["viajeAgente"] = [];
            for (let item of this.viajeAgente)
                data["viajeAgente"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeCargador)) {
            data["viajeCargador"] = [];
            for (let item of this.viajeCargador)
                data["viajeCargador"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmpresaDireccionView {
    id?: number;
    empresaId?: number;
    direccion?: string | undefined;
    codigoPostal?: string | undefined;
    localidadId?: number;
    porDefecto?: boolean;
    tipoDireccionId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView;
    localidad?: LocalidadView;
    tipoDireccion?: TipoDireccionView;
    viajeAgente?: ViajeAgenteView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;
}

export class EmpresaView implements IEmpresaView {
    id?: number;
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipoDocumentoId?: number | undefined;
    codigo?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    securityCompanyId?: number | undefined;
    versionKeyExtTarifa?: string | undefined;
    idExtFacturador?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    areaEmpresa?: AreaEmpresaView[] | undefined;
    empleado?: EmpleadoView[] | undefined;
    empresaDireccion?: EmpresaDireccionView[] | undefined;
    empresa_TipoEmpresa?: Empresa_TipoEmpresaView[] | undefined;
    paralizacionTerminal?: ParalizacionTerminalView[] | undefined;
    sageEmpresa?: SageEmpresaView[] | undefined;
    tipoDocumento?: TipoDocumentoView;
    viaje?: ViajeView[] | undefined;
    viajeAgente?: ViajeAgenteView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;
    viajeEquipamientoEmpresaAdmision?: ViajeEquipamientoView[] | undefined;
    viajeEquipamientoEmpresaEntrega?: ViajeEquipamientoView[] | undefined;

    constructor(data?: IEmpresaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.numeroDocumento = _data["numeroDocumento"];
            this.tipoDocumentoId = _data["tipoDocumentoId"];
            this.codigo = _data["codigo"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.versionKeyExtTarifa = _data["versionKeyExtTarifa"];
            this.idExtFacturador = _data["idExtFacturador"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["areaEmpresa"])) {
                this.areaEmpresa = [] as any;
                for (let item of _data["areaEmpresa"])
                    this.areaEmpresa!.push(AreaEmpresaView.fromJS(item));
            }
            if (Array.isArray(_data["empleado"])) {
                this.empleado = [] as any;
                for (let item of _data["empleado"])
                    this.empleado!.push(EmpleadoView.fromJS(item));
            }
            if (Array.isArray(_data["empresaDireccion"])) {
                this.empresaDireccion = [] as any;
                for (let item of _data["empresaDireccion"])
                    this.empresaDireccion!.push(EmpresaDireccionView.fromJS(item));
            }
            if (Array.isArray(_data["empresa_TipoEmpresa"])) {
                this.empresa_TipoEmpresa = [] as any;
                for (let item of _data["empresa_TipoEmpresa"])
                    this.empresa_TipoEmpresa!.push(Empresa_TipoEmpresaView.fromJS(item));
            }
            if (Array.isArray(_data["paralizacionTerminal"])) {
                this.paralizacionTerminal = [] as any;
                for (let item of _data["paralizacionTerminal"])
                    this.paralizacionTerminal!.push(ParalizacionTerminalView.fromJS(item));
            }
            if (Array.isArray(_data["sageEmpresa"])) {
                this.sageEmpresa = [] as any;
                for (let item of _data["sageEmpresa"])
                    this.sageEmpresa!.push(SageEmpresaView.fromJS(item));
            }
            this.tipoDocumento = _data["tipoDocumento"] ? TipoDocumentoView.fromJS(_data["tipoDocumento"]) : <any>undefined;
            if (Array.isArray(_data["viaje"])) {
                this.viaje = [] as any;
                for (let item of _data["viaje"])
                    this.viaje!.push(ViajeView.fromJS(item));
            }
            if (Array.isArray(_data["viajeAgente"])) {
                this.viajeAgente = [] as any;
                for (let item of _data["viajeAgente"])
                    this.viajeAgente!.push(ViajeAgenteView.fromJS(item));
            }
            if (Array.isArray(_data["viajeCargador"])) {
                this.viajeCargador = [] as any;
                for (let item of _data["viajeCargador"])
                    this.viajeCargador!.push(ViajeCargadorView.fromJS(item));
            }
            if (Array.isArray(_data["viajeConductorVehiculo"])) {
                this.viajeConductorVehiculo = [] as any;
                for (let item of _data["viajeConductorVehiculo"])
                    this.viajeConductorVehiculo!.push(ViajeConductorVehiculoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamientoEmpresaAdmision"])) {
                this.viajeEquipamientoEmpresaAdmision = [] as any;
                for (let item of _data["viajeEquipamientoEmpresaAdmision"])
                    this.viajeEquipamientoEmpresaAdmision!.push(ViajeEquipamientoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamientoEmpresaEntrega"])) {
                this.viajeEquipamientoEmpresaEntrega = [] as any;
                for (let item of _data["viajeEquipamientoEmpresaEntrega"])
                    this.viajeEquipamientoEmpresaEntrega!.push(ViajeEquipamientoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmpresaView {
        data = typeof data === 'object' ? data : {};
        let result = new EmpresaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["numeroDocumento"] = this.numeroDocumento;
        data["tipoDocumentoId"] = this.tipoDocumentoId;
        data["codigo"] = this.codigo;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["securityCompanyId"] = this.securityCompanyId;
        data["versionKeyExtTarifa"] = this.versionKeyExtTarifa;
        data["idExtFacturador"] = this.idExtFacturador;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.areaEmpresa)) {
            data["areaEmpresa"] = [];
            for (let item of this.areaEmpresa)
                data["areaEmpresa"].push(item.toJSON());
        }
        if (Array.isArray(this.empleado)) {
            data["empleado"] = [];
            for (let item of this.empleado)
                data["empleado"].push(item.toJSON());
        }
        if (Array.isArray(this.empresaDireccion)) {
            data["empresaDireccion"] = [];
            for (let item of this.empresaDireccion)
                data["empresaDireccion"].push(item.toJSON());
        }
        if (Array.isArray(this.empresa_TipoEmpresa)) {
            data["empresa_TipoEmpresa"] = [];
            for (let item of this.empresa_TipoEmpresa)
                data["empresa_TipoEmpresa"].push(item.toJSON());
        }
        if (Array.isArray(this.paralizacionTerminal)) {
            data["paralizacionTerminal"] = [];
            for (let item of this.paralizacionTerminal)
                data["paralizacionTerminal"].push(item.toJSON());
        }
        if (Array.isArray(this.sageEmpresa)) {
            data["sageEmpresa"] = [];
            for (let item of this.sageEmpresa)
                data["sageEmpresa"].push(item.toJSON());
        }
        data["tipoDocumento"] = this.tipoDocumento ? this.tipoDocumento.toJSON() : <any>undefined;
        if (Array.isArray(this.viaje)) {
            data["viaje"] = [];
            for (let item of this.viaje)
                data["viaje"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeAgente)) {
            data["viajeAgente"] = [];
            for (let item of this.viajeAgente)
                data["viajeAgente"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeCargador)) {
            data["viajeCargador"] = [];
            for (let item of this.viajeCargador)
                data["viajeCargador"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeConductorVehiculo)) {
            data["viajeConductorVehiculo"] = [];
            for (let item of this.viajeConductorVehiculo)
                data["viajeConductorVehiculo"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamientoEmpresaAdmision)) {
            data["viajeEquipamientoEmpresaAdmision"] = [];
            for (let item of this.viajeEquipamientoEmpresaAdmision)
                data["viajeEquipamientoEmpresaAdmision"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamientoEmpresaEntrega)) {
            data["viajeEquipamientoEmpresaEntrega"] = [];
            for (let item of this.viajeEquipamientoEmpresaEntrega)
                data["viajeEquipamientoEmpresaEntrega"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmpresaView {
    id?: number;
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipoDocumentoId?: number | undefined;
    codigo?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    securityCompanyId?: number | undefined;
    versionKeyExtTarifa?: string | undefined;
    idExtFacturador?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    areaEmpresa?: AreaEmpresaView[] | undefined;
    empleado?: EmpleadoView[] | undefined;
    empresaDireccion?: EmpresaDireccionView[] | undefined;
    empresa_TipoEmpresa?: Empresa_TipoEmpresaView[] | undefined;
    paralizacionTerminal?: ParalizacionTerminalView[] | undefined;
    sageEmpresa?: SageEmpresaView[] | undefined;
    tipoDocumento?: TipoDocumentoView;
    viaje?: ViajeView[] | undefined;
    viajeAgente?: ViajeAgenteView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;
    viajeEquipamientoEmpresaAdmision?: ViajeEquipamientoView[] | undefined;
    viajeEquipamientoEmpresaEntrega?: ViajeEquipamientoView[] | undefined;
}

export class Empresa_TipoEmpresaView implements IEmpresa_TipoEmpresaView {
    id?: number;
    empresaId?: number;
    tipoEmpresaId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView;
    tipoEmpresa?: TipoEmpresaView;

    constructor(data?: IEmpresa_TipoEmpresaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.empresaId = _data["empresaId"];
            this.tipoEmpresaId = _data["tipoEmpresaId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empresa = _data["empresa"] ? EmpresaView.fromJS(_data["empresa"]) : <any>undefined;
            this.tipoEmpresa = _data["tipoEmpresa"] ? TipoEmpresaView.fromJS(_data["tipoEmpresa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Empresa_TipoEmpresaView {
        data = typeof data === 'object' ? data : {};
        let result = new Empresa_TipoEmpresaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["empresaId"] = this.empresaId;
        data["tipoEmpresaId"] = this.tipoEmpresaId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empresa"] = this.empresa ? this.empresa.toJSON() : <any>undefined;
        data["tipoEmpresa"] = this.tipoEmpresa ? this.tipoEmpresa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmpresa_TipoEmpresaView {
    id?: number;
    empresaId?: number;
    tipoEmpresaId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView;
    tipoEmpresa?: TipoEmpresaView;
}

export class EstadoCivilView implements IEstadoCivilView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView[] | undefined;

    constructor(data?: IEstadoCivilView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["empleado"])) {
                this.empleado = [] as any;
                for (let item of _data["empleado"])
                    this.empleado!.push(EmpleadoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstadoCivilView {
        data = typeof data === 'object' ? data : {};
        let result = new EstadoCivilView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.empleado)) {
            data["empleado"] = [];
            for (let item of this.empleado)
                data["empleado"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEstadoCivilView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView[] | undefined;
}

export class EstadoEnvioFacturadorView implements IEstadoEnvioFacturadorView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    registroDocumento?: RegistroDocumentoView[] | undefined;

    constructor(data?: IEstadoEnvioFacturadorView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["registroDocumento"])) {
                this.registroDocumento = [] as any;
                for (let item of _data["registroDocumento"])
                    this.registroDocumento!.push(RegistroDocumentoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstadoEnvioFacturadorView {
        data = typeof data === 'object' ? data : {};
        let result = new EstadoEnvioFacturadorView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.registroDocumento)) {
            data["registroDocumento"] = [];
            for (let item of this.registroDocumento)
                data["registroDocumento"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEstadoEnvioFacturadorView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    registroDocumento?: RegistroDocumentoView[] | undefined;
}

export class EstadoMensajeView implements IEstadoMensajeView {
    id?: number;
    descripcion?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    borderColor?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;

    constructor(data?: IEstadoMensajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.color = _data["color"];
            this.backgroundColor = _data["backgroundColor"];
            this.borderColor = _data["borderColor"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstadoMensajeView {
        data = typeof data === 'object' ? data : {};
        let result = new EstadoMensajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["color"] = this.color;
        data["backgroundColor"] = this.backgroundColor;
        data["borderColor"] = this.borderColor;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEstadoMensajeView {
    id?: number;
    descripcion?: string | undefined;
    color?: string | undefined;
    backgroundColor?: string | undefined;
    borderColor?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;
}

export class EstadoProcesamientoView implements IEstadoProcesamientoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;

    constructor(data?: IEstadoProcesamientoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstadoProcesamientoView {
        data = typeof data === 'object' ? data : {};
        let result = new EstadoProcesamientoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEstadoProcesamientoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;
}

export class EstadoTarifaViajeView implements IEstadoTarifaViajeView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeTarificacion?: ViajeTarificacionView[] | undefined;

    constructor(data?: IEstadoTarifaViajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeTarificacion"])) {
                this.viajeTarificacion = [] as any;
                for (let item of _data["viajeTarificacion"])
                    this.viajeTarificacion!.push(ViajeTarificacionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstadoTarifaViajeView {
        data = typeof data === 'object' ? data : {};
        let result = new EstadoTarifaViajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeTarificacion)) {
            data["viajeTarificacion"] = [];
            for (let item of this.viajeTarificacion)
                data["viajeTarificacion"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEstadoTarifaViajeView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeTarificacion?: ViajeTarificacionView[] | undefined;
}

export class EstadoViajeView implements IEstadoViajeView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viaje?: ViajeView[] | undefined;
    viajeEquipamientoEstadoAdmision?: ViajeEquipamientoView[] | undefined;
    viajeEquipamientoEstadoEntrega?: ViajeEquipamientoView[] | undefined;

    constructor(data?: IEstadoViajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viaje"])) {
                this.viaje = [] as any;
                for (let item of _data["viaje"])
                    this.viaje!.push(ViajeView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamientoEstadoAdmision"])) {
                this.viajeEquipamientoEstadoAdmision = [] as any;
                for (let item of _data["viajeEquipamientoEstadoAdmision"])
                    this.viajeEquipamientoEstadoAdmision!.push(ViajeEquipamientoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamientoEstadoEntrega"])) {
                this.viajeEquipamientoEstadoEntrega = [] as any;
                for (let item of _data["viajeEquipamientoEstadoEntrega"])
                    this.viajeEquipamientoEstadoEntrega!.push(ViajeEquipamientoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstadoViajeView {
        data = typeof data === 'object' ? data : {};
        let result = new EstadoViajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viaje)) {
            data["viaje"] = [];
            for (let item of this.viaje)
                data["viaje"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamientoEstadoAdmision)) {
            data["viajeEquipamientoEstadoAdmision"] = [];
            for (let item of this.viajeEquipamientoEstadoAdmision)
                data["viajeEquipamientoEstadoAdmision"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamientoEstadoEntrega)) {
            data["viajeEquipamientoEstadoEntrega"] = [];
            for (let item of this.viajeEquipamientoEstadoEntrega)
                data["viajeEquipamientoEstadoEntrega"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEstadoViajeView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viaje?: ViajeView[] | undefined;
    viajeEquipamientoEstadoAdmision?: ViajeEquipamientoView[] | undefined;
    viajeEquipamientoEstadoEntrega?: ViajeEquipamientoView[] | undefined;
}

export class FlujoView implements IFlujoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;

    constructor(data?: IFlujoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FlujoView {
        data = typeof data === 'object' ? data : {};
        let result = new FlujoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFlujoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;
}

export class InformeDCTView implements IInformeDCTView {
    id?: number;
    securityCompanyId?: number;
    observaciones?: string | undefined;
    pieDeInforme?: string | undefined;
    pieDePagina?: string | undefined;
    mostrarLogo?: boolean;
    mostrarDireccion?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IInformeDCTView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.observaciones = _data["observaciones"];
            this.pieDeInforme = _data["pieDeInforme"];
            this.pieDePagina = _data["pieDePagina"];
            this.mostrarLogo = _data["mostrarLogo"];
            this.mostrarDireccion = _data["mostrarDireccion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InformeDCTView {
        data = typeof data === 'object' ? data : {};
        let result = new InformeDCTView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["observaciones"] = this.observaciones;
        data["pieDeInforme"] = this.pieDeInforme;
        data["pieDePagina"] = this.pieDePagina;
        data["mostrarLogo"] = this.mostrarLogo;
        data["mostrarDireccion"] = this.mostrarDireccion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInformeDCTView {
    id?: number;
    securityCompanyId?: number;
    observaciones?: string | undefined;
    pieDeInforme?: string | undefined;
    pieDePagina?: string | undefined;
    mostrarLogo?: boolean;
    mostrarDireccion?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class IntCorreoConfiguracionView implements IIntCorreoConfiguracionView {
    id?: number;
    securityCompanyId?: number;
    smtpServer?: string | undefined;
    smtpPort?: number;
    smtpUsername?: string | undefined;
    smtpPassword?: string | undefined;
    fromEmail?: string | undefined;
    fromName?: string | undefined;
    replyToEmail?: string | undefined;
    isActive?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    smtpSecurityModeId?: number;
    smtpSecurityMode?: SmtpSecurityModeView;

    constructor(data?: IIntCorreoConfiguracionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.smtpServer = _data["smtpServer"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUsername = _data["smtpUsername"];
            this.smtpPassword = _data["smtpPassword"];
            this.fromEmail = _data["fromEmail"];
            this.fromName = _data["fromName"];
            this.replyToEmail = _data["replyToEmail"];
            this.isActive = _data["isActive"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.smtpSecurityModeId = _data["smtpSecurityModeId"];
            this.smtpSecurityMode = _data["smtpSecurityMode"] ? SmtpSecurityModeView.fromJS(_data["smtpSecurityMode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntCorreoConfiguracionView {
        data = typeof data === 'object' ? data : {};
        let result = new IntCorreoConfiguracionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["smtpServer"] = this.smtpServer;
        data["smtpPort"] = this.smtpPort;
        data["smtpUsername"] = this.smtpUsername;
        data["smtpPassword"] = this.smtpPassword;
        data["fromEmail"] = this.fromEmail;
        data["fromName"] = this.fromName;
        data["replyToEmail"] = this.replyToEmail;
        data["isActive"] = this.isActive;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["smtpSecurityModeId"] = this.smtpSecurityModeId;
        data["smtpSecurityMode"] = this.smtpSecurityMode ? this.smtpSecurityMode.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIntCorreoConfiguracionView {
    id?: number;
    securityCompanyId?: number;
    smtpServer?: string | undefined;
    smtpPort?: number;
    smtpUsername?: string | undefined;
    smtpPassword?: string | undefined;
    fromEmail?: string | undefined;
    fromName?: string | undefined;
    replyToEmail?: string | undefined;
    isActive?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    smtpSecurityModeId?: number;
    smtpSecurityMode?: SmtpSecurityModeView;
}

export class IntTarifaOperacionView implements IIntTarifaOperacionView {
    id?: number;
    securityCompanyId?: number;
    tipoOperacionId?: number;
    servicioTarificableIdExt?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoOperacion?: TipoOperacionView;

    constructor(data?: IIntTarifaOperacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.tipoOperacionId = _data["tipoOperacionId"];
            this.servicioTarificableIdExt = _data["servicioTarificableIdExt"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoOperacion = _data["tipoOperacion"] ? TipoOperacionView.fromJS(_data["tipoOperacion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntTarifaOperacionView {
        data = typeof data === 'object' ? data : {};
        let result = new IntTarifaOperacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["tipoOperacionId"] = this.tipoOperacionId;
        data["servicioTarificableIdExt"] = this.servicioTarificableIdExt;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoOperacion"] = this.tipoOperacion ? this.tipoOperacion.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIntTarifaOperacionView {
    id?: number;
    securityCompanyId?: number;
    tipoOperacionId?: number;
    servicioTarificableIdExt?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoOperacion?: TipoOperacionView;
}

export class IntegracionSecurityCompanyView implements IIntegracionSecurityCompanyView {
    id?: number;
    securityCompanyId?: number;
    integracionId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    integracion?: IntegracionView;

    constructor(data?: IIntegracionSecurityCompanyView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.integracionId = _data["integracionId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.integracion = _data["integracion"] ? IntegracionView.fromJS(_data["integracion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntegracionSecurityCompanyView {
        data = typeof data === 'object' ? data : {};
        let result = new IntegracionSecurityCompanyView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["integracionId"] = this.integracionId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["integracion"] = this.integracion ? this.integracion.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIntegracionSecurityCompanyView {
    id?: number;
    securityCompanyId?: number;
    integracionId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    integracion?: IntegracionView;
}

export class IntegracionView implements IIntegracionView {
    id?: number;
    tipoIntegracionId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    integracionSecurityCompany?: IntegracionSecurityCompanyView[] | undefined;
    registroDocumento?: RegistroDocumentoView[] | undefined;

    constructor(data?: IIntegracionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tipoIntegracionId = _data["tipoIntegracionId"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["integracionSecurityCompany"])) {
                this.integracionSecurityCompany = [] as any;
                for (let item of _data["integracionSecurityCompany"])
                    this.integracionSecurityCompany!.push(IntegracionSecurityCompanyView.fromJS(item));
            }
            if (Array.isArray(_data["registroDocumento"])) {
                this.registroDocumento = [] as any;
                for (let item of _data["registroDocumento"])
                    this.registroDocumento!.push(RegistroDocumentoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IntegracionView {
        data = typeof data === 'object' ? data : {};
        let result = new IntegracionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipoIntegracionId"] = this.tipoIntegracionId;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.integracionSecurityCompany)) {
            data["integracionSecurityCompany"] = [];
            for (let item of this.integracionSecurityCompany)
                data["integracionSecurityCompany"].push(item.toJSON());
        }
        if (Array.isArray(this.registroDocumento)) {
            data["registroDocumento"] = [];
            for (let item of this.registroDocumento)
                data["registroDocumento"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIntegracionView {
    id?: number;
    tipoIntegracionId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    integracionSecurityCompany?: IntegracionSecurityCompanyView[] | undefined;
    registroDocumento?: RegistroDocumentoView[] | undefined;
}

export class IntercambioView implements IIntercambioView {
    securityCompany?: SecurityCompanyView;
    id?: number;
    nombre?: string | undefined;
    proveedor?: string | undefined;
    identificador?: string | undefined;
    emisor?: string | undefined;
    localidadId?: number | undefined;
    crearViajeAuto?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompanyId?: number;
    localidad?: LocalidadView;

    constructor(data?: IIntercambioView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.securityCompany = _data["securityCompany"] ? SecurityCompanyView.fromJS(_data["securityCompany"]) : <any>undefined;
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.proveedor = _data["proveedor"];
            this.identificador = _data["identificador"];
            this.emisor = _data["emisor"];
            this.localidadId = _data["localidadId"];
            this.crearViajeAuto = _data["crearViajeAuto"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityCompanyId = _data["securityCompanyId"];
            this.localidad = _data["localidad"] ? LocalidadView.fromJS(_data["localidad"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntercambioView {
        data = typeof data === 'object' ? data : {};
        let result = new IntercambioView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["securityCompany"] = this.securityCompany ? this.securityCompany.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["proveedor"] = this.proveedor;
        data["identificador"] = this.identificador;
        data["emisor"] = this.emisor;
        data["localidadId"] = this.localidadId;
        data["crearViajeAuto"] = this.crearViajeAuto;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityCompanyId"] = this.securityCompanyId;
        data["localidad"] = this.localidad ? this.localidad.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIntercambioView {
    securityCompany?: SecurityCompanyView;
    id?: number;
    nombre?: string | undefined;
    proveedor?: string | undefined;
    identificador?: string | undefined;
    emisor?: string | undefined;
    localidadId?: number | undefined;
    crearViajeAuto?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompanyId?: number;
    localidad?: LocalidadView;
}

export class LiquidacionView implements ILiquidacionView {
    viajesIds?: number[] | undefined;
    ajustesIds?: number[] | undefined;
    id?: number;
    securityCompanyId?: number;
    empleadoId?: number;
    fechaLiquidacion?: Date | undefined;
    fechaDesde?: Date | undefined;
    fechaHasta?: Date | undefined;
    importeConceptos?: number | undefined;
    importeRecargos?: number | undefined;
    importeViaje?: number;
    importeAjuste?: number;
    importeTotal?: number | undefined;
    liquidarAEmpresaAjena?: boolean;
    observaciones?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    ajusteLiquidacion?: AjusteLiquidacionView[] | undefined;
    empleado?: EmpleadoView;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;

    constructor(data?: ILiquidacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["viajesIds"])) {
                this.viajesIds = [] as any;
                for (let item of _data["viajesIds"])
                    this.viajesIds!.push(item);
            }
            if (Array.isArray(_data["ajustesIds"])) {
                this.ajustesIds = [] as any;
                for (let item of _data["ajustesIds"])
                    this.ajustesIds!.push(item);
            }
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.empleadoId = _data["empleadoId"];
            this.fechaLiquidacion = _data["fechaLiquidacion"] ? new Date(_data["fechaLiquidacion"].toString()) : <any>undefined;
            this.fechaDesde = _data["fechaDesde"] ? new Date(_data["fechaDesde"].toString()) : <any>undefined;
            this.fechaHasta = _data["fechaHasta"] ? new Date(_data["fechaHasta"].toString()) : <any>undefined;
            this.importeConceptos = _data["importeConceptos"];
            this.importeRecargos = _data["importeRecargos"];
            this.importeViaje = _data["importeViaje"];
            this.importeAjuste = _data["importeAjuste"];
            this.importeTotal = _data["importeTotal"];
            this.liquidarAEmpresaAjena = _data["liquidarAEmpresaAjena"];
            this.observaciones = _data["observaciones"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["ajusteLiquidacion"])) {
                this.ajusteLiquidacion = [] as any;
                for (let item of _data["ajusteLiquidacion"])
                    this.ajusteLiquidacion!.push(AjusteLiquidacionView.fromJS(item));
            }
            this.empleado = _data["empleado"] ? EmpleadoView.fromJS(_data["empleado"]) : <any>undefined;
            if (Array.isArray(_data["viajeConductorVehiculo"])) {
                this.viajeConductorVehiculo = [] as any;
                for (let item of _data["viajeConductorVehiculo"])
                    this.viajeConductorVehiculo!.push(ViajeConductorVehiculoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LiquidacionView {
        data = typeof data === 'object' ? data : {};
        let result = new LiquidacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.viajesIds)) {
            data["viajesIds"] = [];
            for (let item of this.viajesIds)
                data["viajesIds"].push(item);
        }
        if (Array.isArray(this.ajustesIds)) {
            data["ajustesIds"] = [];
            for (let item of this.ajustesIds)
                data["ajustesIds"].push(item);
        }
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["empleadoId"] = this.empleadoId;
        data["fechaLiquidacion"] = this.fechaLiquidacion ? this.fechaLiquidacion.toISOString() : <any>undefined;
        data["fechaDesde"] = this.fechaDesde ? this.fechaDesde.toISOString() : <any>undefined;
        data["fechaHasta"] = this.fechaHasta ? this.fechaHasta.toISOString() : <any>undefined;
        data["importeConceptos"] = this.importeConceptos;
        data["importeRecargos"] = this.importeRecargos;
        data["importeViaje"] = this.importeViaje;
        data["importeAjuste"] = this.importeAjuste;
        data["importeTotal"] = this.importeTotal;
        data["liquidarAEmpresaAjena"] = this.liquidarAEmpresaAjena;
        data["observaciones"] = this.observaciones;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.ajusteLiquidacion)) {
            data["ajusteLiquidacion"] = [];
            for (let item of this.ajusteLiquidacion)
                data["ajusteLiquidacion"].push(item.toJSON());
        }
        data["empleado"] = this.empleado ? this.empleado.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeConductorVehiculo)) {
            data["viajeConductorVehiculo"] = [];
            for (let item of this.viajeConductorVehiculo)
                data["viajeConductorVehiculo"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILiquidacionView {
    viajesIds?: number[] | undefined;
    ajustesIds?: number[] | undefined;
    id?: number;
    securityCompanyId?: number;
    empleadoId?: number;
    fechaLiquidacion?: Date | undefined;
    fechaDesde?: Date | undefined;
    fechaHasta?: Date | undefined;
    importeConceptos?: number | undefined;
    importeRecargos?: number | undefined;
    importeViaje?: number;
    importeAjuste?: number;
    importeTotal?: number | undefined;
    liquidarAEmpresaAjena?: boolean;
    observaciones?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    ajusteLiquidacion?: AjusteLiquidacionView[] | undefined;
    empleado?: EmpleadoView;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;
}

export class LocalidadView implements ILocalidadView {
    id?: number;
    provinciaId?: number | undefined;
    paisId?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    areaLocalidad?: AreaLocalidadView[] | undefined;
    distanciaLocalidadDestino?: DistanciaView[] | undefined;
    distanciaLocalidadOrigen?: DistanciaView[] | undefined;
    empleadoDireccion?: EmpleadoDireccionView[] | undefined;
    empresaDireccion?: EmpresaDireccionView[] | undefined;
    intercambio?: IntercambioView[] | undefined;
    pais?: PaisView;
    provincia?: ProvinciaView;
    securityCompanyConfigurationAdditional?: SecurityCompanyConfigurationAdditionalView[] | undefined;
    viaje?: ViajeView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;

    constructor(data?: ILocalidadView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.provinciaId = _data["provinciaId"];
            this.paisId = _data["paisId"];
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["areaLocalidad"])) {
                this.areaLocalidad = [] as any;
                for (let item of _data["areaLocalidad"])
                    this.areaLocalidad!.push(AreaLocalidadView.fromJS(item));
            }
            if (Array.isArray(_data["distanciaLocalidadDestino"])) {
                this.distanciaLocalidadDestino = [] as any;
                for (let item of _data["distanciaLocalidadDestino"])
                    this.distanciaLocalidadDestino!.push(DistanciaView.fromJS(item));
            }
            if (Array.isArray(_data["distanciaLocalidadOrigen"])) {
                this.distanciaLocalidadOrigen = [] as any;
                for (let item of _data["distanciaLocalidadOrigen"])
                    this.distanciaLocalidadOrigen!.push(DistanciaView.fromJS(item));
            }
            if (Array.isArray(_data["empleadoDireccion"])) {
                this.empleadoDireccion = [] as any;
                for (let item of _data["empleadoDireccion"])
                    this.empleadoDireccion!.push(EmpleadoDireccionView.fromJS(item));
            }
            if (Array.isArray(_data["empresaDireccion"])) {
                this.empresaDireccion = [] as any;
                for (let item of _data["empresaDireccion"])
                    this.empresaDireccion!.push(EmpresaDireccionView.fromJS(item));
            }
            if (Array.isArray(_data["intercambio"])) {
                this.intercambio = [] as any;
                for (let item of _data["intercambio"])
                    this.intercambio!.push(IntercambioView.fromJS(item));
            }
            this.pais = _data["pais"] ? PaisView.fromJS(_data["pais"]) : <any>undefined;
            this.provincia = _data["provincia"] ? ProvinciaView.fromJS(_data["provincia"]) : <any>undefined;
            if (Array.isArray(_data["securityCompanyConfigurationAdditional"])) {
                this.securityCompanyConfigurationAdditional = [] as any;
                for (let item of _data["securityCompanyConfigurationAdditional"])
                    this.securityCompanyConfigurationAdditional!.push(SecurityCompanyConfigurationAdditionalView.fromJS(item));
            }
            if (Array.isArray(_data["viaje"])) {
                this.viaje = [] as any;
                for (let item of _data["viaje"])
                    this.viaje!.push(ViajeView.fromJS(item));
            }
            if (Array.isArray(_data["viajeCargador"])) {
                this.viajeCargador = [] as any;
                for (let item of _data["viajeCargador"])
                    this.viajeCargador!.push(ViajeCargadorView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalidadView {
        data = typeof data === 'object' ? data : {};
        let result = new LocalidadView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["provinciaId"] = this.provinciaId;
        data["paisId"] = this.paisId;
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.areaLocalidad)) {
            data["areaLocalidad"] = [];
            for (let item of this.areaLocalidad)
                data["areaLocalidad"].push(item.toJSON());
        }
        if (Array.isArray(this.distanciaLocalidadDestino)) {
            data["distanciaLocalidadDestino"] = [];
            for (let item of this.distanciaLocalidadDestino)
                data["distanciaLocalidadDestino"].push(item.toJSON());
        }
        if (Array.isArray(this.distanciaLocalidadOrigen)) {
            data["distanciaLocalidadOrigen"] = [];
            for (let item of this.distanciaLocalidadOrigen)
                data["distanciaLocalidadOrigen"].push(item.toJSON());
        }
        if (Array.isArray(this.empleadoDireccion)) {
            data["empleadoDireccion"] = [];
            for (let item of this.empleadoDireccion)
                data["empleadoDireccion"].push(item.toJSON());
        }
        if (Array.isArray(this.empresaDireccion)) {
            data["empresaDireccion"] = [];
            for (let item of this.empresaDireccion)
                data["empresaDireccion"].push(item.toJSON());
        }
        if (Array.isArray(this.intercambio)) {
            data["intercambio"] = [];
            for (let item of this.intercambio)
                data["intercambio"].push(item.toJSON());
        }
        data["pais"] = this.pais ? this.pais.toJSON() : <any>undefined;
        data["provincia"] = this.provincia ? this.provincia.toJSON() : <any>undefined;
        if (Array.isArray(this.securityCompanyConfigurationAdditional)) {
            data["securityCompanyConfigurationAdditional"] = [];
            for (let item of this.securityCompanyConfigurationAdditional)
                data["securityCompanyConfigurationAdditional"].push(item.toJSON());
        }
        if (Array.isArray(this.viaje)) {
            data["viaje"] = [];
            for (let item of this.viaje)
                data["viaje"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeCargador)) {
            data["viajeCargador"] = [];
            for (let item of this.viajeCargador)
                data["viajeCargador"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalidadView {
    id?: number;
    provinciaId?: number | undefined;
    paisId?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    areaLocalidad?: AreaLocalidadView[] | undefined;
    distanciaLocalidadDestino?: DistanciaView[] | undefined;
    distanciaLocalidadOrigen?: DistanciaView[] | undefined;
    empleadoDireccion?: EmpleadoDireccionView[] | undefined;
    empresaDireccion?: EmpresaDireccionView[] | undefined;
    intercambio?: IntercambioView[] | undefined;
    pais?: PaisView;
    provincia?: ProvinciaView;
    securityCompanyConfigurationAdditional?: SecurityCompanyConfigurationAdditionalView[] | undefined;
    viaje?: ViajeView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;
}

export class MensajeView implements IMensajeView {
    contenidoFichero?: string | undefined;
    numeroBytesFichero?: number;
    id?: number;
    fechaEmision?: Date;
    flujoId?: number;
    tipoMensajeId?: number;
    numeroMensaje?: string | undefined;
    numeroDocumentoPCS?: string | undefined;
    estadoMensajeId?: number;
    estadoProcesamientoId?: number | undefined;
    tipoFuncionId?: number | undefined;
    tipoOperacionId?: number | undefined;
    esFerrocarril?: boolean | undefined;
    numeroBooking?: string | undefined;
    numeroExpedienteOL?: string | undefined;
    numeroBL?: string | undefined;
    matriculaContenedor?: string | undefined;
    identificadorContenedor?: string | undefined;
    securityCompanyId?: number | undefined;
    fechaEnvio?: Date | undefined;
    origenMensaje?: string | undefined;
    destinoMensaje?: string | undefined;
    nombreFichero?: string | undefined;
    emisor?: string | undefined;
    receptor?: string | undefined;
    numeroDocumentoEntregaPCS?: string | undefined;
    numeroDocumentoAdmisionPCS?: string | undefined;
    erroresDescripcion?: string | undefined;
    observaciones?: string | undefined;
    localidadProveedorId?: number | undefined;
    viajeId?: number | undefined;
    tipoRespuestaId?: number | undefined;
    referenciaDemandateTransporte?: string | undefined;
    localizadorEntrega?: string | undefined;
    localizadorAdmision?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    estadoMensaje?: EstadoMensajeView;
    estadoProcesamiento?: EstadoProcesamientoView;
    flujo?: FlujoView;
    tipoFuncion?: TipoFuncionView;
    tipoMensaje?: TipoMensajeView;
    tipoOperacion?: TipoOperacionView;
    tipoRespuesta?: TipoRespuestaView;
    viaje?: ViajeView;

    constructor(data?: IMensajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contenidoFichero = _data["contenidoFichero"];
            this.numeroBytesFichero = _data["numeroBytesFichero"];
            this.id = _data["id"];
            this.fechaEmision = _data["fechaEmision"] ? new Date(_data["fechaEmision"].toString()) : <any>undefined;
            this.flujoId = _data["flujoId"];
            this.tipoMensajeId = _data["tipoMensajeId"];
            this.numeroMensaje = _data["numeroMensaje"];
            this.numeroDocumentoPCS = _data["numeroDocumentoPCS"];
            this.estadoMensajeId = _data["estadoMensajeId"];
            this.estadoProcesamientoId = _data["estadoProcesamientoId"];
            this.tipoFuncionId = _data["tipoFuncionId"];
            this.tipoOperacionId = _data["tipoOperacionId"];
            this.esFerrocarril = _data["esFerrocarril"];
            this.numeroBooking = _data["numeroBooking"];
            this.numeroExpedienteOL = _data["numeroExpedienteOL"];
            this.numeroBL = _data["numeroBL"];
            this.matriculaContenedor = _data["matriculaContenedor"];
            this.identificadorContenedor = _data["identificadorContenedor"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.fechaEnvio = _data["fechaEnvio"] ? new Date(_data["fechaEnvio"].toString()) : <any>undefined;
            this.origenMensaje = _data["origenMensaje"];
            this.destinoMensaje = _data["destinoMensaje"];
            this.nombreFichero = _data["nombreFichero"];
            this.emisor = _data["emisor"];
            this.receptor = _data["receptor"];
            this.numeroDocumentoEntregaPCS = _data["numeroDocumentoEntregaPCS"];
            this.numeroDocumentoAdmisionPCS = _data["numeroDocumentoAdmisionPCS"];
            this.erroresDescripcion = _data["erroresDescripcion"];
            this.observaciones = _data["observaciones"];
            this.localidadProveedorId = _data["localidadProveedorId"];
            this.viajeId = _data["viajeId"];
            this.tipoRespuestaId = _data["tipoRespuestaId"];
            this.referenciaDemandateTransporte = _data["referenciaDemandateTransporte"];
            this.localizadorEntrega = _data["localizadorEntrega"];
            this.localizadorAdmision = _data["localizadorAdmision"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.estadoMensaje = _data["estadoMensaje"] ? EstadoMensajeView.fromJS(_data["estadoMensaje"]) : <any>undefined;
            this.estadoProcesamiento = _data["estadoProcesamiento"] ? EstadoProcesamientoView.fromJS(_data["estadoProcesamiento"]) : <any>undefined;
            this.flujo = _data["flujo"] ? FlujoView.fromJS(_data["flujo"]) : <any>undefined;
            this.tipoFuncion = _data["tipoFuncion"] ? TipoFuncionView.fromJS(_data["tipoFuncion"]) : <any>undefined;
            this.tipoMensaje = _data["tipoMensaje"] ? TipoMensajeView.fromJS(_data["tipoMensaje"]) : <any>undefined;
            this.tipoOperacion = _data["tipoOperacion"] ? TipoOperacionView.fromJS(_data["tipoOperacion"]) : <any>undefined;
            this.tipoRespuesta = _data["tipoRespuesta"] ? TipoRespuestaView.fromJS(_data["tipoRespuesta"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MensajeView {
        data = typeof data === 'object' ? data : {};
        let result = new MensajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contenidoFichero"] = this.contenidoFichero;
        data["numeroBytesFichero"] = this.numeroBytesFichero;
        data["id"] = this.id;
        data["fechaEmision"] = this.fechaEmision ? this.fechaEmision.toISOString() : <any>undefined;
        data["flujoId"] = this.flujoId;
        data["tipoMensajeId"] = this.tipoMensajeId;
        data["numeroMensaje"] = this.numeroMensaje;
        data["numeroDocumentoPCS"] = this.numeroDocumentoPCS;
        data["estadoMensajeId"] = this.estadoMensajeId;
        data["estadoProcesamientoId"] = this.estadoProcesamientoId;
        data["tipoFuncionId"] = this.tipoFuncionId;
        data["tipoOperacionId"] = this.tipoOperacionId;
        data["esFerrocarril"] = this.esFerrocarril;
        data["numeroBooking"] = this.numeroBooking;
        data["numeroExpedienteOL"] = this.numeroExpedienteOL;
        data["numeroBL"] = this.numeroBL;
        data["matriculaContenedor"] = this.matriculaContenedor;
        data["identificadorContenedor"] = this.identificadorContenedor;
        data["securityCompanyId"] = this.securityCompanyId;
        data["fechaEnvio"] = this.fechaEnvio ? this.fechaEnvio.toISOString() : <any>undefined;
        data["origenMensaje"] = this.origenMensaje;
        data["destinoMensaje"] = this.destinoMensaje;
        data["nombreFichero"] = this.nombreFichero;
        data["emisor"] = this.emisor;
        data["receptor"] = this.receptor;
        data["numeroDocumentoEntregaPCS"] = this.numeroDocumentoEntregaPCS;
        data["numeroDocumentoAdmisionPCS"] = this.numeroDocumentoAdmisionPCS;
        data["erroresDescripcion"] = this.erroresDescripcion;
        data["observaciones"] = this.observaciones;
        data["localidadProveedorId"] = this.localidadProveedorId;
        data["viajeId"] = this.viajeId;
        data["tipoRespuestaId"] = this.tipoRespuestaId;
        data["referenciaDemandateTransporte"] = this.referenciaDemandateTransporte;
        data["localizadorEntrega"] = this.localizadorEntrega;
        data["localizadorAdmision"] = this.localizadorAdmision;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["estadoMensaje"] = this.estadoMensaje ? this.estadoMensaje.toJSON() : <any>undefined;
        data["estadoProcesamiento"] = this.estadoProcesamiento ? this.estadoProcesamiento.toJSON() : <any>undefined;
        data["flujo"] = this.flujo ? this.flujo.toJSON() : <any>undefined;
        data["tipoFuncion"] = this.tipoFuncion ? this.tipoFuncion.toJSON() : <any>undefined;
        data["tipoMensaje"] = this.tipoMensaje ? this.tipoMensaje.toJSON() : <any>undefined;
        data["tipoOperacion"] = this.tipoOperacion ? this.tipoOperacion.toJSON() : <any>undefined;
        data["tipoRespuesta"] = this.tipoRespuesta ? this.tipoRespuesta.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMensajeView {
    contenidoFichero?: string | undefined;
    numeroBytesFichero?: number;
    id?: number;
    fechaEmision?: Date;
    flujoId?: number;
    tipoMensajeId?: number;
    numeroMensaje?: string | undefined;
    numeroDocumentoPCS?: string | undefined;
    estadoMensajeId?: number;
    estadoProcesamientoId?: number | undefined;
    tipoFuncionId?: number | undefined;
    tipoOperacionId?: number | undefined;
    esFerrocarril?: boolean | undefined;
    numeroBooking?: string | undefined;
    numeroExpedienteOL?: string | undefined;
    numeroBL?: string | undefined;
    matriculaContenedor?: string | undefined;
    identificadorContenedor?: string | undefined;
    securityCompanyId?: number | undefined;
    fechaEnvio?: Date | undefined;
    origenMensaje?: string | undefined;
    destinoMensaje?: string | undefined;
    nombreFichero?: string | undefined;
    emisor?: string | undefined;
    receptor?: string | undefined;
    numeroDocumentoEntregaPCS?: string | undefined;
    numeroDocumentoAdmisionPCS?: string | undefined;
    erroresDescripcion?: string | undefined;
    observaciones?: string | undefined;
    localidadProveedorId?: number | undefined;
    viajeId?: number | undefined;
    tipoRespuestaId?: number | undefined;
    referenciaDemandateTransporte?: string | undefined;
    localizadorEntrega?: string | undefined;
    localizadorAdmision?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    estadoMensaje?: EstadoMensajeView;
    estadoProcesamiento?: EstadoProcesamientoView;
    flujo?: FlujoView;
    tipoFuncion?: TipoFuncionView;
    tipoMensaje?: TipoMensajeView;
    tipoOperacion?: TipoOperacionView;
    tipoRespuesta?: TipoRespuestaView;
    viaje?: ViajeView;
}

export class ModoCreacionView implements IModoCreacionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viaje?: ViajeView[] | undefined;

    constructor(data?: IModoCreacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viaje"])) {
                this.viaje = [] as any;
                for (let item of _data["viaje"])
                    this.viaje!.push(ViajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModoCreacionView {
        data = typeof data === 'object' ? data : {};
        let result = new ModoCreacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viaje)) {
            data["viaje"] = [];
            for (let item of this.viaje)
                data["viaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModoCreacionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viaje?: ViajeView[] | undefined;
}

export class PaisView implements IPaisView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidad?: LocalidadView[] | undefined;
    provincia?: ProvinciaView[] | undefined;

    constructor(data?: IPaisView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["localidad"])) {
                this.localidad = [] as any;
                for (let item of _data["localidad"])
                    this.localidad!.push(LocalidadView.fromJS(item));
            }
            if (Array.isArray(_data["provincia"])) {
                this.provincia = [] as any;
                for (let item of _data["provincia"])
                    this.provincia!.push(ProvinciaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaisView {
        data = typeof data === 'object' ? data : {};
        let result = new PaisView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.localidad)) {
            data["localidad"] = [];
            for (let item of this.localidad)
                data["localidad"].push(item.toJSON());
        }
        if (Array.isArray(this.provincia)) {
            data["provincia"] = [];
            for (let item of this.provincia)
                data["provincia"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPaisView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidad?: LocalidadView[] | undefined;
    provincia?: ProvinciaView[] | undefined;
}

export class ParalizacionTerminalView implements IParalizacionTerminalView {
    id?: number;
    terminalId?: number;
    numMovimientos?: number;
    totalMinutosFacturables?: number;
    viajeTarifaId?: number | undefined;
    importe?: number | undefined;
    fechaEntradaTerminal?: Date | undefined;
    fechaSalidaTerminal?: Date | undefined;
    facturado?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    terminal?: EmpresaView;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
    viajeTarifa?: ViajeTarifaView;

    constructor(data?: IParalizacionTerminalView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.terminalId = _data["terminalId"];
            this.numMovimientos = _data["numMovimientos"];
            this.totalMinutosFacturables = _data["totalMinutosFacturables"];
            this.viajeTarifaId = _data["viajeTarifaId"];
            this.importe = _data["importe"];
            this.fechaEntradaTerminal = _data["fechaEntradaTerminal"] ? new Date(_data["fechaEntradaTerminal"].toString()) : <any>undefined;
            this.fechaSalidaTerminal = _data["fechaSalidaTerminal"] ? new Date(_data["fechaSalidaTerminal"].toString()) : <any>undefined;
            this.facturado = _data["facturado"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.terminal = _data["terminal"] ? EmpresaView.fromJS(_data["terminal"]) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamiento"])) {
                this.viajeEquipamiento = [] as any;
                for (let item of _data["viajeEquipamiento"])
                    this.viajeEquipamiento!.push(ViajeEquipamientoView.fromJS(item));
            }
            this.viajeTarifa = _data["viajeTarifa"] ? ViajeTarifaView.fromJS(_data["viajeTarifa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParalizacionTerminalView {
        data = typeof data === 'object' ? data : {};
        let result = new ParalizacionTerminalView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["terminalId"] = this.terminalId;
        data["numMovimientos"] = this.numMovimientos;
        data["totalMinutosFacturables"] = this.totalMinutosFacturables;
        data["viajeTarifaId"] = this.viajeTarifaId;
        data["importe"] = this.importe;
        data["fechaEntradaTerminal"] = this.fechaEntradaTerminal ? this.fechaEntradaTerminal.toISOString() : <any>undefined;
        data["fechaSalidaTerminal"] = this.fechaSalidaTerminal ? this.fechaSalidaTerminal.toISOString() : <any>undefined;
        data["facturado"] = this.facturado;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["terminal"] = this.terminal ? this.terminal.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeEquipamiento)) {
            data["viajeEquipamiento"] = [];
            for (let item of this.viajeEquipamiento)
                data["viajeEquipamiento"].push(item.toJSON());
        }
        data["viajeTarifa"] = this.viajeTarifa ? this.viajeTarifa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParalizacionTerminalView {
    id?: number;
    terminalId?: number;
    numMovimientos?: number;
    totalMinutosFacturables?: number;
    viajeTarifaId?: number | undefined;
    importe?: number | undefined;
    fechaEntradaTerminal?: Date | undefined;
    fechaSalidaTerminal?: Date | undefined;
    facturado?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    terminal?: EmpresaView;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
    viajeTarifa?: ViajeTarifaView;
}

export class ProvinciaView implements IProvinciaView {
    id?: number;
    paisId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidad?: LocalidadView[] | undefined;
    pais?: PaisView;

    constructor(data?: IProvinciaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.paisId = _data["paisId"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["localidad"])) {
                this.localidad = [] as any;
                for (let item of _data["localidad"])
                    this.localidad!.push(LocalidadView.fromJS(item));
            }
            this.pais = _data["pais"] ? PaisView.fromJS(_data["pais"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProvinciaView {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinciaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paisId"] = this.paisId;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.localidad)) {
            data["localidad"] = [];
            for (let item of this.localidad)
                data["localidad"].push(item.toJSON());
        }
        data["pais"] = this.pais ? this.pais.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProvinciaView {
    id?: number;
    paisId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidad?: LocalidadView[] | undefined;
    pais?: PaisView;
}

export class RegistroDocumentoView implements IRegistroDocumentoView {
    id?: number;
    securityCompanyId?: number;
    integracionId?: number;
    referenciaExterna?: string | undefined;
    referenciaDocumentoExterno?: string | undefined;
    urlDocumentoExterno?: string | undefined;
    estadoEnvioFacturadorId?: number;
    estadoExterno?: string | undefined;
    observacionesExternas?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    estadoEnvioFacturador?: EstadoEnvioFacturadorView;
    integracion?: IntegracionView;
    viaje?: ViajeView[] | undefined;

    constructor(data?: IRegistroDocumentoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.integracionId = _data["integracionId"];
            this.referenciaExterna = _data["referenciaExterna"];
            this.referenciaDocumentoExterno = _data["referenciaDocumentoExterno"];
            this.urlDocumentoExterno = _data["urlDocumentoExterno"];
            this.estadoEnvioFacturadorId = _data["estadoEnvioFacturadorId"];
            this.estadoExterno = _data["estadoExterno"];
            this.observacionesExternas = _data["observacionesExternas"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.estadoEnvioFacturador = _data["estadoEnvioFacturador"] ? EstadoEnvioFacturadorView.fromJS(_data["estadoEnvioFacturador"]) : <any>undefined;
            this.integracion = _data["integracion"] ? IntegracionView.fromJS(_data["integracion"]) : <any>undefined;
            if (Array.isArray(_data["viaje"])) {
                this.viaje = [] as any;
                for (let item of _data["viaje"])
                    this.viaje!.push(ViajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistroDocumentoView {
        data = typeof data === 'object' ? data : {};
        let result = new RegistroDocumentoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["integracionId"] = this.integracionId;
        data["referenciaExterna"] = this.referenciaExterna;
        data["referenciaDocumentoExterno"] = this.referenciaDocumentoExterno;
        data["urlDocumentoExterno"] = this.urlDocumentoExterno;
        data["estadoEnvioFacturadorId"] = this.estadoEnvioFacturadorId;
        data["estadoExterno"] = this.estadoExterno;
        data["observacionesExternas"] = this.observacionesExternas;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["estadoEnvioFacturador"] = this.estadoEnvioFacturador ? this.estadoEnvioFacturador.toJSON() : <any>undefined;
        data["integracion"] = this.integracion ? this.integracion.toJSON() : <any>undefined;
        if (Array.isArray(this.viaje)) {
            data["viaje"] = [];
            for (let item of this.viaje)
                data["viaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegistroDocumentoView {
    id?: number;
    securityCompanyId?: number;
    integracionId?: number;
    referenciaExterna?: string | undefined;
    referenciaDocumentoExterno?: string | undefined;
    urlDocumentoExterno?: string | undefined;
    estadoEnvioFacturadorId?: number;
    estadoExterno?: string | undefined;
    observacionesExternas?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    estadoEnvioFacturador?: EstadoEnvioFacturadorView;
    integracion?: IntegracionView;
    viaje?: ViajeView[] | undefined;
}

export class PreviewDocumentRequest implements IPreviewDocumentRequest {
    viajeId?: number;
    previewDct?: boolean;
    previewOrdenCompleta?: boolean;
    previewOrdenEntregaAdmision?: boolean;

    constructor(data?: IPreviewDocumentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viajeId = _data["viajeId"];
            this.previewDct = _data["previewDct"];
            this.previewOrdenCompleta = _data["previewOrdenCompleta"];
            this.previewOrdenEntregaAdmision = _data["previewOrdenEntregaAdmision"];
        }
    }

    static fromJS(data: any): PreviewDocumentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewDocumentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viajeId"] = this.viajeId;
        data["previewDct"] = this.previewDct;
        data["previewOrdenCompleta"] = this.previewOrdenCompleta;
        data["previewOrdenEntregaAdmision"] = this.previewOrdenEntregaAdmision;
        return data;
    }
}

export interface IPreviewDocumentRequest {
    viajeId?: number;
    previewDct?: boolean;
    previewOrdenCompleta?: boolean;
    previewOrdenEntregaAdmision?: boolean;
}

export class SendEmailDocumentsRequest implements ISendEmailDocumentsRequest {
    viajeId?: number;
    sendDct?: boolean;
    sendOrdenCompleta?: boolean;
    sendOrdenEntregaAdmision?: boolean;
    emailAddresses?: string[] | undefined;

    constructor(data?: ISendEmailDocumentsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viajeId = _data["viajeId"];
            this.sendDct = _data["sendDct"];
            this.sendOrdenCompleta = _data["sendOrdenCompleta"];
            this.sendOrdenEntregaAdmision = _data["sendOrdenEntregaAdmision"];
            if (Array.isArray(_data["emailAddresses"])) {
                this.emailAddresses = [] as any;
                for (let item of _data["emailAddresses"])
                    this.emailAddresses!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmailDocumentsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailDocumentsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viajeId"] = this.viajeId;
        data["sendDct"] = this.sendDct;
        data["sendOrdenCompleta"] = this.sendOrdenCompleta;
        data["sendOrdenEntregaAdmision"] = this.sendOrdenEntregaAdmision;
        if (Array.isArray(this.emailAddresses)) {
            data["emailAddresses"] = [];
            for (let item of this.emailAddresses)
                data["emailAddresses"].push(item);
        }
        return data;
    }
}

export interface ISendEmailDocumentsRequest {
    viajeId?: number;
    sendDct?: boolean;
    sendOrdenCompleta?: boolean;
    sendOrdenEntregaAdmision?: boolean;
    emailAddresses?: string[] | undefined;
}

export class PreviewDocumentDetailResponse implements IPreviewDocumentDetailResponse {
    tipoDocumento!: string | undefined;
    htmlContent!: string | undefined;
    containerNumber?: string | undefined;

    constructor(data?: IPreviewDocumentDetailResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tipoDocumento = _data["tipoDocumento"];
            this.htmlContent = _data["htmlContent"];
            this.containerNumber = _data["containerNumber"];
        }
    }

    static fromJS(data: any): PreviewDocumentDetailResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewDocumentDetailResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tipoDocumento"] = this.tipoDocumento;
        data["htmlContent"] = this.htmlContent;
        data["containerNumber"] = this.containerNumber;
        return data;
    }
}

export interface IPreviewDocumentDetailResponse {
    tipoDocumento: string | undefined;
    htmlContent: string | undefined;
    containerNumber?: string | undefined;
}

export class PreviewDocumentResponse implements IPreviewDocumentResponse {
    viajeId!: number;
    documents?: PreviewDocumentDetailResponse[] | undefined;

    constructor(data?: IPreviewDocumentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.viajeId = _data["viajeId"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(PreviewDocumentDetailResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PreviewDocumentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PreviewDocumentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["viajeId"] = this.viajeId;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPreviewDocumentResponse {
    viajeId: number;
    documents?: PreviewDocumentDetailResponse[] | undefined;
}

export class SageEmpresaView implements ISageEmpresaView {
    id?: number;
    securityCompanyId?: number;
    empresaId?: number;
    cuentaContableSage?: string | undefined;
    formaPago?: string | undefined;
    codigoFormaPagoSage?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView;

    constructor(data?: ISageEmpresaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.empresaId = _data["empresaId"];
            this.cuentaContableSage = _data["cuentaContableSage"];
            this.formaPago = _data["formaPago"];
            this.codigoFormaPagoSage = _data["codigoFormaPagoSage"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.empresa = _data["empresa"] ? EmpresaView.fromJS(_data["empresa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SageEmpresaView {
        data = typeof data === 'object' ? data : {};
        let result = new SageEmpresaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["empresaId"] = this.empresaId;
        data["cuentaContableSage"] = this.cuentaContableSage;
        data["formaPago"] = this.formaPago;
        data["codigoFormaPagoSage"] = this.codigoFormaPagoSage;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["empresa"] = this.empresa ? this.empresa.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISageEmpresaView {
    id?: number;
    securityCompanyId?: number;
    empresaId?: number;
    cuentaContableSage?: string | undefined;
    formaPago?: string | undefined;
    codigoFormaPagoSage?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView;
}

export class SageModoCalculoView implements ISageModoCalculoView {
    id?: number;
    securityCompanyId?: number;
    idExtModoCalculo?: number;
    extDescripcion?: string | undefined;
    codigoSage?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: ISageModoCalculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.idExtModoCalculo = _data["idExtModoCalculo"];
            this.extDescripcion = _data["extDescripcion"];
            this.codigoSage = _data["codigoSage"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SageModoCalculoView {
        data = typeof data === 'object' ? data : {};
        let result = new SageModoCalculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["idExtModoCalculo"] = this.idExtModoCalculo;
        data["extDescripcion"] = this.extDescripcion;
        data["codigoSage"] = this.codigoSage;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISageModoCalculoView {
    id?: number;
    securityCompanyId?: number;
    idExtModoCalculo?: number;
    extDescripcion?: string | undefined;
    codigoSage?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class SageRecargoView implements ISageRecargoView {
    id?: number;
    securityCompanyId?: number;
    idExtRecargo?: number;
    extDescripcion?: string | undefined;
    codigoSage?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: ISageRecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.idExtRecargo = _data["idExtRecargo"];
            this.extDescripcion = _data["extDescripcion"];
            this.codigoSage = _data["codigoSage"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SageRecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new SageRecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["idExtRecargo"] = this.idExtRecargo;
        data["extDescripcion"] = this.extDescripcion;
        data["codigoSage"] = this.codigoSage;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISageRecargoView {
    id?: number;
    securityCompanyId?: number;
    idExtRecargo?: number;
    extDescripcion?: string | undefined;
    codigoSage?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class SecurityCompanyConfigurationAdditionalView implements ISecurityCompanyConfigurationAdditionalView {
    id?: number;
    securityCompanyId?: number;
    direccion?: string | undefined;
    codigoPostal?: string | undefined;
    localidadId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidad?: LocalidadView;

    constructor(data?: ISecurityCompanyConfigurationAdditionalView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.direccion = _data["direccion"];
            this.codigoPostal = _data["codigoPostal"];
            this.localidadId = _data["localidadId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.localidad = _data["localidad"] ? LocalidadView.fromJS(_data["localidad"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecurityCompanyConfigurationAdditionalView {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityCompanyConfigurationAdditionalView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["direccion"] = this.direccion;
        data["codigoPostal"] = this.codigoPostal;
        data["localidadId"] = this.localidadId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["localidad"] = this.localidad ? this.localidad.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecurityCompanyConfigurationAdditionalView {
    id?: number;
    securityCompanyId?: number;
    direccion?: string | undefined;
    codigoPostal?: string | undefined;
    localidadId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    localidad?: LocalidadView;
}

export class SmtpSecurityModeView implements ISmtpSecurityModeView {
    id?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    intCorreoConfiguracion?: IntCorreoConfiguracionView[] | undefined;

    constructor(data?: ISmtpSecurityModeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["intCorreoConfiguracion"])) {
                this.intCorreoConfiguracion = [] as any;
                for (let item of _data["intCorreoConfiguracion"])
                    this.intCorreoConfiguracion!.push(IntCorreoConfiguracionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SmtpSecurityModeView {
        data = typeof data === 'object' ? data : {};
        let result = new SmtpSecurityModeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.intCorreoConfiguracion)) {
            data["intCorreoConfiguracion"] = [];
            for (let item of this.intCorreoConfiguracion)
                data["intCorreoConfiguracion"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISmtpSecurityModeView {
    id?: number;
    description?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    intCorreoConfiguracion?: IntCorreoConfiguracionView[] | undefined;
}

export class TipoBultoView implements ITipoBultoView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;

    constructor(data?: ITipoBultoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamientoMercancia"])) {
                this.viajeEquipamientoMercancia = [] as any;
                for (let item of _data["viajeEquipamientoMercancia"])
                    this.viajeEquipamientoMercancia!.push(ViajeEquipamientoMercanciaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoBultoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoBultoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeEquipamientoMercancia)) {
            data["viajeEquipamientoMercancia"] = [];
            for (let item of this.viajeEquipamientoMercancia)
                data["viajeEquipamientoMercancia"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoBultoView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;
}

export class TipoCarnetView implements ITipoCarnetView {
    id?: number;
    descripcion?: string | undefined;
    observaciones?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleadoDatosCarnet?: EmpleadoDatosCarnetView[] | undefined;

    constructor(data?: ITipoCarnetView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.observaciones = _data["observaciones"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["empleadoDatosCarnet"])) {
                this.empleadoDatosCarnet = [] as any;
                for (let item of _data["empleadoDatosCarnet"])
                    this.empleadoDatosCarnet!.push(EmpleadoDatosCarnetView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoCarnetView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoCarnetView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["observaciones"] = this.observaciones;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.empleadoDatosCarnet)) {
            data["empleadoDatosCarnet"] = [];
            for (let item of this.empleadoDatosCarnet)
                data["empleadoDatosCarnet"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoCarnetView {
    id?: number;
    descripcion?: string | undefined;
    observaciones?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleadoDatosCarnet?: EmpleadoDatosCarnetView[] | undefined;
}

export class TipoCodigoISOView implements ITipoCodigoISOView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    refrigerado?: boolean;
    clasificacionContenedorId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    clasificacionContenedor?: ClasificacionContenedorView;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;

    constructor(data?: ITipoCodigoISOView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.refrigerado = _data["refrigerado"];
            this.clasificacionContenedorId = _data["clasificacionContenedorId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.clasificacionContenedor = _data["clasificacionContenedor"] ? ClasificacionContenedorView.fromJS(_data["clasificacionContenedor"]) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamiento"])) {
                this.viajeEquipamiento = [] as any;
                for (let item of _data["viajeEquipamiento"])
                    this.viajeEquipamiento!.push(ViajeEquipamientoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoCodigoISOView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoCodigoISOView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["refrigerado"] = this.refrigerado;
        data["clasificacionContenedorId"] = this.clasificacionContenedorId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["clasificacionContenedor"] = this.clasificacionContenedor ? this.clasificacionContenedor.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeEquipamiento)) {
            data["viajeEquipamiento"] = [];
            for (let item of this.viajeEquipamiento)
                data["viajeEquipamiento"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoCodigoISOView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    refrigerado?: boolean;
    clasificacionContenedorId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    clasificacionContenedor?: ClasificacionContenedorView;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
}

export class TipoDireccionView implements ITipoDireccionView {
    id?: number;
    tipo?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresaDireccion?: EmpresaDireccionView[] | undefined;

    constructor(data?: ITipoDireccionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tipo = _data["tipo"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["empresaDireccion"])) {
                this.empresaDireccion = [] as any;
                for (let item of _data["empresaDireccion"])
                    this.empresaDireccion!.push(EmpresaDireccionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoDireccionView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoDireccionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tipo"] = this.tipo;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.empresaDireccion)) {
            data["empresaDireccion"] = [];
            for (let item of this.empresaDireccion)
                data["empresaDireccion"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoDireccionView {
    id?: number;
    tipo?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresaDireccion?: EmpresaDireccionView[] | undefined;
}

export class TipoDocumentoView implements ITipoDocumentoView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    mostrar?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView[] | undefined;

    constructor(data?: ITipoDocumentoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.mostrar = _data["mostrar"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["empresa"])) {
                this.empresa = [] as any;
                for (let item of _data["empresa"])
                    this.empresa!.push(EmpresaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoDocumentoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoDocumentoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["mostrar"] = this.mostrar;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.empresa)) {
            data["empresa"] = [];
            for (let item of this.empresa)
                data["empresa"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoDocumentoView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    mostrar?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa?: EmpresaView[] | undefined;
}

export class TipoEmpleadoView implements ITipoEmpleadoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView[] | undefined;

    constructor(data?: ITipoEmpleadoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["empleado"])) {
                this.empleado = [] as any;
                for (let item of _data["empleado"])
                    this.empleado!.push(EmpleadoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoEmpleadoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoEmpleadoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.empleado)) {
            data["empleado"] = [];
            for (let item of this.empleado)
                data["empleado"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoEmpleadoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empleado?: EmpleadoView[] | undefined;
}

export class TipoEmpresaView implements ITipoEmpresaView {
    id?: number;
    descripcion?: string | undefined;
    porSecurityCompany?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa_TipoEmpresa?: Empresa_TipoEmpresaView[] | undefined;
    viajeAgente?: ViajeAgenteView[] | undefined;

    constructor(data?: ITipoEmpresaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.porSecurityCompany = _data["porSecurityCompany"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["empresa_TipoEmpresa"])) {
                this.empresa_TipoEmpresa = [] as any;
                for (let item of _data["empresa_TipoEmpresa"])
                    this.empresa_TipoEmpresa!.push(Empresa_TipoEmpresaView.fromJS(item));
            }
            if (Array.isArray(_data["viajeAgente"])) {
                this.viajeAgente = [] as any;
                for (let item of _data["viajeAgente"])
                    this.viajeAgente!.push(ViajeAgenteView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoEmpresaView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoEmpresaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["porSecurityCompany"] = this.porSecurityCompany;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.empresa_TipoEmpresa)) {
            data["empresa_TipoEmpresa"] = [];
            for (let item of this.empresa_TipoEmpresa)
                data["empresa_TipoEmpresa"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeAgente)) {
            data["viajeAgente"] = [];
            for (let item of this.viajeAgente)
                data["viajeAgente"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoEmpresaView {
    id?: number;
    descripcion?: string | undefined;
    porSecurityCompany?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    empresa_TipoEmpresa?: Empresa_TipoEmpresaView[] | undefined;
    viajeAgente?: ViajeAgenteView[] | undefined;
}

export class TipoEquipamientoView implements ITipoEquipamientoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;

    constructor(data?: ITipoEquipamientoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamiento"])) {
                this.viajeEquipamiento = [] as any;
                for (let item of _data["viajeEquipamiento"])
                    this.viajeEquipamiento!.push(ViajeEquipamientoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoEquipamientoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoEquipamientoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeEquipamiento)) {
            data["viajeEquipamiento"] = [];
            for (let item of this.viajeEquipamiento)
                data["viajeEquipamiento"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoEquipamientoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
}

export class TipoFuncionView implements ITipoFuncionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;

    constructor(data?: ITipoFuncionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoFuncionView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoFuncionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoFuncionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;
}

export class TipoIntegracionView implements ITipoIntegracionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: ITipoIntegracionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TipoIntegracionView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoIntegracionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITipoIntegracionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class TipoIntervencionView implements ITipoIntervencionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculoIntervencionTaller?: VehiculoIntervencionTallerView[] | undefined;

    constructor(data?: ITipoIntervencionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["vehiculoIntervencionTaller"])) {
                this.vehiculoIntervencionTaller = [] as any;
                for (let item of _data["vehiculoIntervencionTaller"])
                    this.vehiculoIntervencionTaller!.push(VehiculoIntervencionTallerView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoIntervencionView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoIntervencionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.vehiculoIntervencionTaller)) {
            data["vehiculoIntervencionTaller"] = [];
            for (let item of this.vehiculoIntervencionTaller)
                data["vehiculoIntervencionTaller"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoIntervencionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculoIntervencionTaller?: VehiculoIntervencionTallerView[] | undefined;
}

export class TipoMensajeView implements ITipoMensajeView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;

    constructor(data?: ITipoMensajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoMensajeView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoMensajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoMensajeView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;
}

export class TipoMercanciaView implements ITipoMercanciaView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;

    constructor(data?: ITipoMercanciaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamientoMercancia"])) {
                this.viajeEquipamientoMercancia = [] as any;
                for (let item of _data["viajeEquipamientoMercancia"])
                    this.viajeEquipamientoMercancia!.push(ViajeEquipamientoMercanciaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoMercanciaView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoMercanciaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeEquipamientoMercancia)) {
            data["viajeEquipamientoMercancia"] = [];
            for (let item of this.viajeEquipamientoMercancia)
                data["viajeEquipamientoMercancia"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoMercanciaView {
    id?: number;
    codigo?: string | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;
}

export class TipoObservacionView implements ITipoObservacionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeObservacion?: ViajeObservacionView[] | undefined;

    constructor(data?: ITipoObservacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeObservacion"])) {
                this.viajeObservacion = [] as any;
                for (let item of _data["viajeObservacion"])
                    this.viajeObservacion!.push(ViajeObservacionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoObservacionView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoObservacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeObservacion)) {
            data["viajeObservacion"] = [];
            for (let item of this.viajeObservacion)
                data["viajeObservacion"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoObservacionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeObservacion?: ViajeObservacionView[] | undefined;
}

export class TipoOperacionBuqueView implements ITipoOperacionBuqueView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeBuque?: ViajeBuqueView[] | undefined;

    constructor(data?: ITipoOperacionBuqueView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeBuque"])) {
                this.viajeBuque = [] as any;
                for (let item of _data["viajeBuque"])
                    this.viajeBuque!.push(ViajeBuqueView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoOperacionBuqueView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoOperacionBuqueView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeBuque)) {
            data["viajeBuque"] = [];
            for (let item of this.viajeBuque)
                data["viajeBuque"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoOperacionBuqueView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeBuque?: ViajeBuqueView[] | undefined;
}

export class TipoOperacionView implements ITipoOperacionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    intTarifaOperacion?: IntTarifaOperacionView[] | undefined;
    mensaje?: MensajeView[] | undefined;
    viaje?: ViajeView[] | undefined;

    constructor(data?: ITipoOperacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["intTarifaOperacion"])) {
                this.intTarifaOperacion = [] as any;
                for (let item of _data["intTarifaOperacion"])
                    this.intTarifaOperacion!.push(IntTarifaOperacionView.fromJS(item));
            }
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
            if (Array.isArray(_data["viaje"])) {
                this.viaje = [] as any;
                for (let item of _data["viaje"])
                    this.viaje!.push(ViajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoOperacionView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoOperacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.intTarifaOperacion)) {
            data["intTarifaOperacion"] = [];
            for (let item of this.intTarifaOperacion)
                data["intTarifaOperacion"].push(item.toJSON());
        }
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        if (Array.isArray(this.viaje)) {
            data["viaje"] = [];
            for (let item of this.viaje)
                data["viaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoOperacionView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    intTarifaOperacion?: IntTarifaOperacionView[] | undefined;
    mensaje?: MensajeView[] | undefined;
    viaje?: ViajeView[] | undefined;
}

export class TipoPeligrosidadView implements ITipoPeligrosidadView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoMercanciaPeligrosa?: ViajeEquipamientoMercanciaPeligrosaView[] | undefined;

    constructor(data?: ITipoPeligrosidadView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamientoMercanciaPeligrosa"])) {
                this.viajeEquipamientoMercanciaPeligrosa = [] as any;
                for (let item of _data["viajeEquipamientoMercanciaPeligrosa"])
                    this.viajeEquipamientoMercanciaPeligrosa!.push(ViajeEquipamientoMercanciaPeligrosaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoPeligrosidadView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoPeligrosidadView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeEquipamientoMercanciaPeligrosa)) {
            data["viajeEquipamientoMercanciaPeligrosa"] = [];
            for (let item of this.viajeEquipamientoMercanciaPeligrosa)
                data["viajeEquipamientoMercanciaPeligrosa"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoPeligrosidadView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoMercanciaPeligrosa?: ViajeEquipamientoMercanciaPeligrosaView[] | undefined;
}

export class TipoPrecintoView implements ITipoPrecintoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoPrecinto?: ViajeEquipamientoPrecintoView[] | undefined;

    constructor(data?: ITipoPrecintoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamientoPrecinto"])) {
                this.viajeEquipamientoPrecinto = [] as any;
                for (let item of _data["viajeEquipamientoPrecinto"])
                    this.viajeEquipamientoPrecinto!.push(ViajeEquipamientoPrecintoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoPrecintoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoPrecintoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajeEquipamientoPrecinto)) {
            data["viajeEquipamientoPrecinto"] = [];
            for (let item of this.viajeEquipamientoPrecinto)
                data["viajeEquipamientoPrecinto"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoPrecintoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeEquipamientoPrecinto?: ViajeEquipamientoPrecintoView[] | undefined;
}

export class TipoPuertoView implements ITipoPuertoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajePuerto?: ViajePuertoView[] | undefined;

    constructor(data?: ITipoPuertoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["viajePuerto"])) {
                this.viajePuerto = [] as any;
                for (let item of _data["viajePuerto"])
                    this.viajePuerto!.push(ViajePuertoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoPuertoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoPuertoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.viajePuerto)) {
            data["viajePuerto"] = [];
            for (let item of this.viajePuerto)
                data["viajePuerto"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoPuertoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajePuerto?: ViajePuertoView[] | undefined;
}

export class TipoRespuestaView implements ITipoRespuestaView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;

    constructor(data?: ITipoRespuestaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoRespuestaView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoRespuestaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoRespuestaView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    mensaje?: MensajeView[] | undefined;
}

export class TipoUnidadMercanciaView implements ITipoUnidadMercanciaView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculoIntervencionTaller?: VehiculoIntervencionTallerView[] | undefined;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;

    constructor(data?: ITipoUnidadMercanciaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["vehiculoIntervencionTaller"])) {
                this.vehiculoIntervencionTaller = [] as any;
                for (let item of _data["vehiculoIntervencionTaller"])
                    this.vehiculoIntervencionTaller!.push(VehiculoIntervencionTallerView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamientoMercancia"])) {
                this.viajeEquipamientoMercancia = [] as any;
                for (let item of _data["viajeEquipamientoMercancia"])
                    this.viajeEquipamientoMercancia!.push(ViajeEquipamientoMercanciaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoUnidadMercanciaView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoUnidadMercanciaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.vehiculoIntervencionTaller)) {
            data["vehiculoIntervencionTaller"] = [];
            for (let item of this.vehiculoIntervencionTaller)
                data["vehiculoIntervencionTaller"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamientoMercancia)) {
            data["viajeEquipamientoMercancia"] = [];
            for (let item of this.viajeEquipamientoMercancia)
                data["viajeEquipamientoMercancia"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoUnidadMercanciaView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculoIntervencionTaller?: VehiculoIntervencionTallerView[] | undefined;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;
}

export class TipoVehiculoView implements ITipoVehiculoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView[] | undefined;

    constructor(data?: ITipoVehiculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["vehiculo"])) {
                this.vehiculo = [] as any;
                for (let item of _data["vehiculo"])
                    this.vehiculo!.push(VehiculoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TipoVehiculoView {
        data = typeof data === 'object' ? data : {};
        let result = new TipoVehiculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.vehiculo)) {
            data["vehiculo"] = [];
            for (let item of this.vehiculo)
                data["vehiculo"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITipoVehiculoView {
    id?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView[] | undefined;
}

export class VTA_ConceptosTarificacionView implements IVTA_ConceptosTarificacionView {
    id?: number;
    conceptoTarifaId?: number | undefined;
    elementoId?: number | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IVTA_ConceptosTarificacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.conceptoTarifaId = _data["conceptoTarifaId"];
            this.elementoId = _data["elementoId"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_ConceptosTarificacionView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_ConceptosTarificacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["conceptoTarifaId"] = this.conceptoTarifaId;
        data["elementoId"] = this.elementoId;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_ConceptosTarificacionView {
    id?: number;
    conceptoTarifaId?: number | undefined;
    elementoId?: number | undefined;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class VTA_EmpleadoView implements IVTA_EmpleadoView {
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipo?: string | undefined;
    vehiculo?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    id?: number;
    esPropio?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompanyId?: number | undefined;
    codigoInterno?: string | undefined;
    antecedentes?: boolean | undefined;
    tieneADR?: boolean | undefined;
    telefonoEmpresa?: string | undefined;
    fechaAntiguedad?: Date | undefined;
    fechaNacimiento?: Date | undefined;
    numeroSS?: string | undefined;
    puntosCarnet?: number | undefined;
    fechaActualizacionPuntos?: Date | undefined;

    constructor(data?: IVTA_EmpleadoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.numeroDocumento = _data["numeroDocumento"];
            this.tipo = _data["tipo"];
            this.vehiculo = _data["vehiculo"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.id = _data["id"];
            this.esPropio = _data["esPropio"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.securityCompanyId = _data["securityCompanyId"];
            this.codigoInterno = _data["codigoInterno"];
            this.antecedentes = _data["antecedentes"];
            this.tieneADR = _data["tieneADR"];
            this.telefonoEmpresa = _data["telefonoEmpresa"];
            this.fechaAntiguedad = _data["fechaAntiguedad"] ? new Date(_data["fechaAntiguedad"].toString()) : <any>undefined;
            this.fechaNacimiento = _data["fechaNacimiento"] ? new Date(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.numeroSS = _data["numeroSS"];
            this.puntosCarnet = _data["puntosCarnet"];
            this.fechaActualizacionPuntos = _data["fechaActualizacionPuntos"] ? new Date(_data["fechaActualizacionPuntos"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_EmpleadoView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_EmpleadoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["numeroDocumento"] = this.numeroDocumento;
        data["tipo"] = this.tipo;
        data["vehiculo"] = this.vehiculo;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["id"] = this.id;
        data["esPropio"] = this.esPropio;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["securityCompanyId"] = this.securityCompanyId;
        data["codigoInterno"] = this.codigoInterno;
        data["antecedentes"] = this.antecedentes;
        data["tieneADR"] = this.tieneADR;
        data["telefonoEmpresa"] = this.telefonoEmpresa;
        data["fechaAntiguedad"] = this.fechaAntiguedad ? this.fechaAntiguedad.toISOString() : <any>undefined;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["numeroSS"] = this.numeroSS;
        data["puntosCarnet"] = this.puntosCarnet;
        data["fechaActualizacionPuntos"] = this.fechaActualizacionPuntos ? this.fechaActualizacionPuntos.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_EmpleadoView {
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipo?: string | undefined;
    vehiculo?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    id?: number;
    esPropio?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    securityCompanyId?: number | undefined;
    codigoInterno?: string | undefined;
    antecedentes?: boolean | undefined;
    tieneADR?: boolean | undefined;
    telefonoEmpresa?: string | undefined;
    fechaAntiguedad?: Date | undefined;
    fechaNacimiento?: Date | undefined;
    numeroSS?: string | undefined;
    puntosCarnet?: number | undefined;
    fechaActualizacionPuntos?: Date | undefined;
}

export class VTA_EmpresaAjenaView implements IVTA_EmpresaAjenaView {
    id?: number;
    securityCompanyId?: number | undefined;
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipo?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    liquidarEmpresaAjena?: boolean | undefined;

    constructor(data?: IVTA_EmpresaAjenaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.nombre = _data["nombre"];
            this.numeroDocumento = _data["numeroDocumento"];
            this.tipo = _data["tipo"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.liquidarEmpresaAjena = _data["liquidarEmpresaAjena"];
        }
    }

    static fromJS(data: any): VTA_EmpresaAjenaView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_EmpresaAjenaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["nombre"] = this.nombre;
        data["numeroDocumento"] = this.numeroDocumento;
        data["tipo"] = this.tipo;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["liquidarEmpresaAjena"] = this.liquidarEmpresaAjena;
        return data;
    }
}

export interface IVTA_EmpresaAjenaView {
    id?: number;
    securityCompanyId?: number | undefined;
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipo?: string | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    liquidarEmpresaAjena?: boolean | undefined;
}

export class VTA_EmpresaView implements IVTA_EmpresaView {
    id?: number;
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipoEmpresaId?: number | undefined;
    tipo?: string | undefined;
    porSecurityCompany?: boolean | undefined;
    securityCompanyId?: number | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IVTA_EmpresaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nombre = _data["nombre"];
            this.numeroDocumento = _data["numeroDocumento"];
            this.tipoEmpresaId = _data["tipoEmpresaId"];
            this.tipo = _data["tipo"];
            this.porSecurityCompany = _data["porSecurityCompany"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_EmpresaView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_EmpresaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nombre"] = this.nombre;
        data["numeroDocumento"] = this.numeroDocumento;
        data["tipoEmpresaId"] = this.tipoEmpresaId;
        data["tipo"] = this.tipo;
        data["porSecurityCompany"] = this.porSecurityCompany;
        data["securityCompanyId"] = this.securityCompanyId;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_EmpresaView {
    id?: number;
    nombre?: string | undefined;
    numeroDocumento?: string | undefined;
    tipoEmpresaId?: number | undefined;
    tipo?: string | undefined;
    porSecurityCompany?: boolean | undefined;
    securityCompanyId?: number | undefined;
    telefono?: string | undefined;
    email?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class VTA_IntercambioView implements IVTA_IntercambioView {
    nombre?: string | undefined;
    proveedor?: string | undefined;
    identificador?: string | undefined;
    emisor?: string | undefined;
    localidad?: string | undefined;
    securityCompanyId?: number | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    crearViajeAuto?: boolean | undefined;

    constructor(data?: IVTA_IntercambioView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nombre = _data["nombre"];
            this.proveedor = _data["proveedor"];
            this.identificador = _data["identificador"];
            this.emisor = _data["emisor"];
            this.localidad = _data["localidad"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.id = _data["id"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.crearViajeAuto = _data["crearViajeAuto"];
        }
    }

    static fromJS(data: any): VTA_IntercambioView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_IntercambioView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nombre"] = this.nombre;
        data["proveedor"] = this.proveedor;
        data["identificador"] = this.identificador;
        data["emisor"] = this.emisor;
        data["localidad"] = this.localidad;
        data["securityCompanyId"] = this.securityCompanyId;
        data["id"] = this.id;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["crearViajeAuto"] = this.crearViajeAuto;
        return data;
    }
}

export interface IVTA_IntercambioView {
    nombre?: string | undefined;
    proveedor?: string | undefined;
    identificador?: string | undefined;
    emisor?: string | undefined;
    localidad?: string | undefined;
    securityCompanyId?: number | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    crearViajeAuto?: boolean | undefined;
}

export class VTA_LocalidadView implements IVTA_LocalidadView {
    codigo?: string | undefined;
    descripcion?: string | undefined;
    provincia?: string | undefined;
    pais?: string | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IVTA_LocalidadView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.codigo = _data["codigo"];
            this.descripcion = _data["descripcion"];
            this.provincia = _data["provincia"];
            this.pais = _data["pais"];
            this.id = _data["id"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_LocalidadView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_LocalidadView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["codigo"] = this.codigo;
        data["descripcion"] = this.descripcion;
        data["provincia"] = this.provincia;
        data["pais"] = this.pais;
        data["id"] = this.id;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_LocalidadView {
    codigo?: string | undefined;
    descripcion?: string | undefined;
    provincia?: string | undefined;
    pais?: string | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class VTA_MensajeView implements IVTA_MensajeView {
    id?: number;
    fechaEmision?: Date | undefined;
    flujo?: string | undefined;
    tipoMensaje?: string | undefined;
    numeroMensaje?: string | undefined;
    numeroDocumentoPCS?: string | undefined;
    estadoMensaje?: string | undefined;
    estadoMensaje_Color?: string | undefined;
    estadoMensaje_BackgroundColor?: string | undefined;
    estadoMensaje_BorderColor?: string | undefined;
    esFerrocarril?: boolean | undefined;
    numeroBooking?: string | undefined;
    numeroExpedienteOL?: string | undefined;
    numeroBL?: string | undefined;
    matriculaContenedor?: string | undefined;
    identificadorContenedor?: string | undefined;
    securityCompany_Name?: string | undefined;
    fechaEnvio?: Date | undefined;
    origenMensaje?: string | undefined;
    destinoMensaje?: string | undefined;
    nombreFichero?: string | undefined;
    receptor?: string | undefined;
    emisor?: string | undefined;
    numeroDocumentoEntregaPCS?: string | undefined;
    numeroDocumentoAdmisionPCS?: string | undefined;
    fechaAlta?: Date | undefined;
    tipoFuncion?: string | undefined;
    tipoOperacion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeId?: number | undefined;
    erroresDescripcion?: string | undefined;
    numeroViaje?: string | undefined;
    estadoProcesamientoId?: number | undefined;
    estadoProcesamiento_Descripcion?: string | undefined;
    referenciaDemandateTransporte?: string | undefined;
    localizadorEntrega?: string | undefined;
    localizadorAdmision?: string | undefined;

    constructor(data?: IVTA_MensajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fechaEmision = _data["fechaEmision"] ? new Date(_data["fechaEmision"].toString()) : <any>undefined;
            this.flujo = _data["flujo"];
            this.tipoMensaje = _data["tipoMensaje"];
            this.numeroMensaje = _data["numeroMensaje"];
            this.numeroDocumentoPCS = _data["numeroDocumentoPCS"];
            this.estadoMensaje = _data["estadoMensaje"];
            this.estadoMensaje_Color = _data["estadoMensaje_Color"];
            this.estadoMensaje_BackgroundColor = _data["estadoMensaje_BackgroundColor"];
            this.estadoMensaje_BorderColor = _data["estadoMensaje_BorderColor"];
            this.esFerrocarril = _data["esFerrocarril"];
            this.numeroBooking = _data["numeroBooking"];
            this.numeroExpedienteOL = _data["numeroExpedienteOL"];
            this.numeroBL = _data["numeroBL"];
            this.matriculaContenedor = _data["matriculaContenedor"];
            this.identificadorContenedor = _data["identificadorContenedor"];
            this.securityCompany_Name = _data["securityCompany_Name"];
            this.fechaEnvio = _data["fechaEnvio"] ? new Date(_data["fechaEnvio"].toString()) : <any>undefined;
            this.origenMensaje = _data["origenMensaje"];
            this.destinoMensaje = _data["destinoMensaje"];
            this.nombreFichero = _data["nombreFichero"];
            this.receptor = _data["receptor"];
            this.emisor = _data["emisor"];
            this.numeroDocumentoEntregaPCS = _data["numeroDocumentoEntregaPCS"];
            this.numeroDocumentoAdmisionPCS = _data["numeroDocumentoAdmisionPCS"];
            this.fechaAlta = _data["fechaAlta"] ? new Date(_data["fechaAlta"].toString()) : <any>undefined;
            this.tipoFuncion = _data["tipoFuncion"];
            this.tipoOperacion = _data["tipoOperacion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.viajeId = _data["viajeId"];
            this.erroresDescripcion = _data["erroresDescripcion"];
            this.numeroViaje = _data["numeroViaje"];
            this.estadoProcesamientoId = _data["estadoProcesamientoId"];
            this.estadoProcesamiento_Descripcion = _data["estadoProcesamiento_Descripcion"];
            this.referenciaDemandateTransporte = _data["referenciaDemandateTransporte"];
            this.localizadorEntrega = _data["localizadorEntrega"];
            this.localizadorAdmision = _data["localizadorAdmision"];
        }
    }

    static fromJS(data: any): VTA_MensajeView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_MensajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fechaEmision"] = this.fechaEmision ? this.fechaEmision.toISOString() : <any>undefined;
        data["flujo"] = this.flujo;
        data["tipoMensaje"] = this.tipoMensaje;
        data["numeroMensaje"] = this.numeroMensaje;
        data["numeroDocumentoPCS"] = this.numeroDocumentoPCS;
        data["estadoMensaje"] = this.estadoMensaje;
        data["estadoMensaje_Color"] = this.estadoMensaje_Color;
        data["estadoMensaje_BackgroundColor"] = this.estadoMensaje_BackgroundColor;
        data["estadoMensaje_BorderColor"] = this.estadoMensaje_BorderColor;
        data["esFerrocarril"] = this.esFerrocarril;
        data["numeroBooking"] = this.numeroBooking;
        data["numeroExpedienteOL"] = this.numeroExpedienteOL;
        data["numeroBL"] = this.numeroBL;
        data["matriculaContenedor"] = this.matriculaContenedor;
        data["identificadorContenedor"] = this.identificadorContenedor;
        data["securityCompany_Name"] = this.securityCompany_Name;
        data["fechaEnvio"] = this.fechaEnvio ? this.fechaEnvio.toISOString() : <any>undefined;
        data["origenMensaje"] = this.origenMensaje;
        data["destinoMensaje"] = this.destinoMensaje;
        data["nombreFichero"] = this.nombreFichero;
        data["receptor"] = this.receptor;
        data["emisor"] = this.emisor;
        data["numeroDocumentoEntregaPCS"] = this.numeroDocumentoEntregaPCS;
        data["numeroDocumentoAdmisionPCS"] = this.numeroDocumentoAdmisionPCS;
        data["fechaAlta"] = this.fechaAlta ? this.fechaAlta.toISOString() : <any>undefined;
        data["tipoFuncion"] = this.tipoFuncion;
        data["tipoOperacion"] = this.tipoOperacion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["viajeId"] = this.viajeId;
        data["erroresDescripcion"] = this.erroresDescripcion;
        data["numeroViaje"] = this.numeroViaje;
        data["estadoProcesamientoId"] = this.estadoProcesamientoId;
        data["estadoProcesamiento_Descripcion"] = this.estadoProcesamiento_Descripcion;
        data["referenciaDemandateTransporte"] = this.referenciaDemandateTransporte;
        data["localizadorEntrega"] = this.localizadorEntrega;
        data["localizadorAdmision"] = this.localizadorAdmision;
        return data;
    }
}

export interface IVTA_MensajeView {
    id?: number;
    fechaEmision?: Date | undefined;
    flujo?: string | undefined;
    tipoMensaje?: string | undefined;
    numeroMensaje?: string | undefined;
    numeroDocumentoPCS?: string | undefined;
    estadoMensaje?: string | undefined;
    estadoMensaje_Color?: string | undefined;
    estadoMensaje_BackgroundColor?: string | undefined;
    estadoMensaje_BorderColor?: string | undefined;
    esFerrocarril?: boolean | undefined;
    numeroBooking?: string | undefined;
    numeroExpedienteOL?: string | undefined;
    numeroBL?: string | undefined;
    matriculaContenedor?: string | undefined;
    identificadorContenedor?: string | undefined;
    securityCompany_Name?: string | undefined;
    fechaEnvio?: Date | undefined;
    origenMensaje?: string | undefined;
    destinoMensaje?: string | undefined;
    nombreFichero?: string | undefined;
    receptor?: string | undefined;
    emisor?: string | undefined;
    numeroDocumentoEntregaPCS?: string | undefined;
    numeroDocumentoAdmisionPCS?: string | undefined;
    fechaAlta?: Date | undefined;
    tipoFuncion?: string | undefined;
    tipoOperacion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeId?: number | undefined;
    erroresDescripcion?: string | undefined;
    numeroViaje?: string | undefined;
    estadoProcesamientoId?: number | undefined;
    estadoProcesamiento_Descripcion?: string | undefined;
    referenciaDemandateTransporte?: string | undefined;
    localizadorEntrega?: string | undefined;
    localizadorAdmision?: string | undefined;
}

export class VTA_ProvinciaView implements IVTA_ProvinciaView {
    descripcion?: string | undefined;
    paisId?: number | undefined;
    pais?: string | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;

    constructor(data?: IVTA_ProvinciaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.descripcion = _data["descripcion"];
            this.paisId = _data["paisId"];
            this.pais = _data["pais"];
            this.id = _data["id"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_ProvinciaView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_ProvinciaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["descripcion"] = this.descripcion;
        data["paisId"] = this.paisId;
        data["pais"] = this.pais;
        data["id"] = this.id;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_ProvinciaView {
    descripcion?: string | undefined;
    paisId?: number | undefined;
    pais?: string | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
}

export class VTA_VehiculoView implements IVTA_VehiculoView {
    matricula?: string | undefined;
    tipoVehiculo?: string | undefined;
    marca?: string | undefined;
    modelo?: string | undefined;
    bastidor?: string | undefined;
    vehiculoAsociado?: string | undefined;
    id?: number;
    securityCompanyId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    fechaMatriculacion?: Date | undefined;
    clasificacionVehiculo_Descripcion?: string | undefined;
    caducidadITV?: Date | undefined;
    vehiculoTacografo_FechaCaducidad?: Date | undefined;
    extintor1_Numero?: string | undefined;
    extintor1_FechaCaducidad?: Date | undefined;
    extintor2_Numero?: string | undefined;
    extintor2_FechaCaducidad?: Date | undefined;
    tara?: number | undefined;
    vehiculoSeguro_Companyia?: string | undefined;
    vehiculoSeguro_NumeroPoliza?: string | undefined;
    vehiculoSeguro_FechaCaducidad?: Date | undefined;

    constructor(data?: IVTA_VehiculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matricula = _data["matricula"];
            this.tipoVehiculo = _data["tipoVehiculo"];
            this.marca = _data["marca"];
            this.modelo = _data["modelo"];
            this.bastidor = _data["bastidor"];
            this.vehiculoAsociado = _data["vehiculoAsociado"];
            this.id = _data["id"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.fechaMatriculacion = _data["fechaMatriculacion"] ? new Date(_data["fechaMatriculacion"].toString()) : <any>undefined;
            this.clasificacionVehiculo_Descripcion = _data["clasificacionVehiculo_Descripcion"];
            this.caducidadITV = _data["caducidadITV"] ? new Date(_data["caducidadITV"].toString()) : <any>undefined;
            this.vehiculoTacografo_FechaCaducidad = _data["vehiculoTacografo_FechaCaducidad"] ? new Date(_data["vehiculoTacografo_FechaCaducidad"].toString()) : <any>undefined;
            this.extintor1_Numero = _data["extintor1_Numero"];
            this.extintor1_FechaCaducidad = _data["extintor1_FechaCaducidad"] ? new Date(_data["extintor1_FechaCaducidad"].toString()) : <any>undefined;
            this.extintor2_Numero = _data["extintor2_Numero"];
            this.extintor2_FechaCaducidad = _data["extintor2_FechaCaducidad"] ? new Date(_data["extintor2_FechaCaducidad"].toString()) : <any>undefined;
            this.tara = _data["tara"];
            this.vehiculoSeguro_Companyia = _data["vehiculoSeguro_Companyia"];
            this.vehiculoSeguro_NumeroPoliza = _data["vehiculoSeguro_NumeroPoliza"];
            this.vehiculoSeguro_FechaCaducidad = _data["vehiculoSeguro_FechaCaducidad"] ? new Date(_data["vehiculoSeguro_FechaCaducidad"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VTA_VehiculoView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_VehiculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matricula"] = this.matricula;
        data["tipoVehiculo"] = this.tipoVehiculo;
        data["marca"] = this.marca;
        data["modelo"] = this.modelo;
        data["bastidor"] = this.bastidor;
        data["vehiculoAsociado"] = this.vehiculoAsociado;
        data["id"] = this.id;
        data["securityCompanyId"] = this.securityCompanyId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["fechaMatriculacion"] = this.fechaMatriculacion ? this.fechaMatriculacion.toISOString() : <any>undefined;
        data["clasificacionVehiculo_Descripcion"] = this.clasificacionVehiculo_Descripcion;
        data["caducidadITV"] = this.caducidadITV ? this.caducidadITV.toISOString() : <any>undefined;
        data["vehiculoTacografo_FechaCaducidad"] = this.vehiculoTacografo_FechaCaducidad ? this.vehiculoTacografo_FechaCaducidad.toISOString() : <any>undefined;
        data["extintor1_Numero"] = this.extintor1_Numero;
        data["extintor1_FechaCaducidad"] = this.extintor1_FechaCaducidad ? this.extintor1_FechaCaducidad.toISOString() : <any>undefined;
        data["extintor2_Numero"] = this.extintor2_Numero;
        data["extintor2_FechaCaducidad"] = this.extintor2_FechaCaducidad ? this.extintor2_FechaCaducidad.toISOString() : <any>undefined;
        data["tara"] = this.tara;
        data["vehiculoSeguro_Companyia"] = this.vehiculoSeguro_Companyia;
        data["vehiculoSeguro_NumeroPoliza"] = this.vehiculoSeguro_NumeroPoliza;
        data["vehiculoSeguro_FechaCaducidad"] = this.vehiculoSeguro_FechaCaducidad ? this.vehiculoSeguro_FechaCaducidad.toISOString() : <any>undefined;
        return data;
    }
}

export interface IVTA_VehiculoView {
    matricula?: string | undefined;
    tipoVehiculo?: string | undefined;
    marca?: string | undefined;
    modelo?: string | undefined;
    bastidor?: string | undefined;
    vehiculoAsociado?: string | undefined;
    id?: number;
    securityCompanyId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    fechaMatriculacion?: Date | undefined;
    clasificacionVehiculo_Descripcion?: string | undefined;
    caducidadITV?: Date | undefined;
    vehiculoTacografo_FechaCaducidad?: Date | undefined;
    extintor1_Numero?: string | undefined;
    extintor1_FechaCaducidad?: Date | undefined;
    extintor2_Numero?: string | undefined;
    extintor2_FechaCaducidad?: Date | undefined;
    tara?: number | undefined;
    vehiculoSeguro_Companyia?: string | undefined;
    vehiculoSeguro_NumeroPoliza?: string | undefined;
    vehiculoSeguro_FechaCaducidad?: Date | undefined;
}

export class VTA_ViajeView implements IVTA_ViajeView {
    numeroViaje?: string | undefined;
    fecha?: Date | undefined;
    estadoViajeId?: number | undefined;
    estadoViaje?: string | undefined;
    modoCreacionId?: number | undefined;
    modoCreacion?: string | undefined;
    tipoOperacionId?: number | undefined;
    tipoOperacion?: string | undefined;
    esCombinado?: boolean | undefined;
    esCombinadoObservacion?: string | undefined;
    fechaTraspaso?: Date | undefined;
    numeroBooking?: string | undefined;
    codigoISO?: string | undefined;
    matriculaEquipamiento?: string | undefined;
    viajeEmpresaEntrega?: string | undefined;
    fechaEntrega?: Date | undefined;
    estadoEntregaId?: number | undefined;
    estadoEntrega?: string | undefined;
    viajeEmpresaAdmision?: string | undefined;
    fechaAdmision?: Date | undefined;
    estadoAdmisionId?: number | undefined;
    estadoAdmision?: string | undefined;
    localizadorEntrega?: string | undefined;
    localizadorAdmision?: string | undefined;
    hayReefer?: boolean | undefined;
    hayMercanciaPeligrosa?: boolean | undefined;
    precintoEntrega?: string | undefined;
    precintoAdmision?: string | undefined;
    entregaConductor?: string | undefined;
    entregaEmpresaAjenaId?: number | undefined;
    entregaEmpresaAjenaNombre?: string | undefined;
    vehiculosEntrega?: string | undefined;
    admisionConductor?: string | undefined;
    admisionEmpresaAjenaId?: number | undefined;
    admisionEmpresaAjenaNombre?: string | undefined;
    vehiculosAdmision?: string | undefined;
    cargador?: string | undefined;
    localidad?: string | undefined;
    km?: number | undefined;
    fechaCargadorTemprano?: Date | undefined;
    orden?: number | undefined;
    cotizacion_TarifaId?: number | undefined;
    cotizacion_EstadoTarifaViajeId?: number | undefined;
    cotizacion_EstadoDescripcion?: string | undefined;
    liquidacion_TarifaId?: number | undefined;
    liquidacion_EstadoTarifaViajeId?: number | undefined;
    liquidacion_EstadoDescripcion?: string | undefined;
    empresaNombre?: string | undefined;
    nombreCliente?: string | undefined;
    referenciaCliente?: string | undefined;
    localidadOrigen?: string | undefined;
    canceladoManual?: boolean | undefined;
    fechaBaja?: Date | undefined;
    securityCompanyId?: number | undefined;
    clienteId?: number | undefined;
    registroDocumentoId?: number | undefined;
    workOrder?: string | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    proveedor?: string | undefined;
    fechaLiquidacion?: string | undefined;
    numeroBL?: string | undefined;

    constructor(data?: IVTA_ViajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numeroViaje = _data["numeroViaje"];
            this.fecha = _data["fecha"] ? new Date(_data["fecha"].toString()) : <any>undefined;
            this.estadoViajeId = _data["estadoViajeId"];
            this.estadoViaje = _data["estadoViaje"];
            this.modoCreacionId = _data["modoCreacionId"];
            this.modoCreacion = _data["modoCreacion"];
            this.tipoOperacionId = _data["tipoOperacionId"];
            this.tipoOperacion = _data["tipoOperacion"];
            this.esCombinado = _data["esCombinado"];
            this.esCombinadoObservacion = _data["esCombinadoObservacion"];
            this.fechaTraspaso = _data["fechaTraspaso"] ? new Date(_data["fechaTraspaso"].toString()) : <any>undefined;
            this.numeroBooking = _data["numeroBooking"];
            this.codigoISO = _data["codigoISO"];
            this.matriculaEquipamiento = _data["matriculaEquipamiento"];
            this.viajeEmpresaEntrega = _data["viajeEmpresaEntrega"];
            this.fechaEntrega = _data["fechaEntrega"] ? new Date(_data["fechaEntrega"].toString()) : <any>undefined;
            this.estadoEntregaId = _data["estadoEntregaId"];
            this.estadoEntrega = _data["estadoEntrega"];
            this.viajeEmpresaAdmision = _data["viajeEmpresaAdmision"];
            this.fechaAdmision = _data["fechaAdmision"] ? new Date(_data["fechaAdmision"].toString()) : <any>undefined;
            this.estadoAdmisionId = _data["estadoAdmisionId"];
            this.estadoAdmision = _data["estadoAdmision"];
            this.localizadorEntrega = _data["localizadorEntrega"];
            this.localizadorAdmision = _data["localizadorAdmision"];
            this.hayReefer = _data["hayReefer"];
            this.hayMercanciaPeligrosa = _data["hayMercanciaPeligrosa"];
            this.precintoEntrega = _data["precintoEntrega"];
            this.precintoAdmision = _data["precintoAdmision"];
            this.entregaConductor = _data["entregaConductor"];
            this.entregaEmpresaAjenaId = _data["entregaEmpresaAjenaId"];
            this.entregaEmpresaAjenaNombre = _data["entregaEmpresaAjenaNombre"];
            this.vehiculosEntrega = _data["vehiculosEntrega"];
            this.admisionConductor = _data["admisionConductor"];
            this.admisionEmpresaAjenaId = _data["admisionEmpresaAjenaId"];
            this.admisionEmpresaAjenaNombre = _data["admisionEmpresaAjenaNombre"];
            this.vehiculosAdmision = _data["vehiculosAdmision"];
            this.cargador = _data["cargador"];
            this.localidad = _data["localidad"];
            this.km = _data["km"];
            this.fechaCargadorTemprano = _data["fechaCargadorTemprano"] ? new Date(_data["fechaCargadorTemprano"].toString()) : <any>undefined;
            this.orden = _data["orden"];
            this.cotizacion_TarifaId = _data["cotizacion_TarifaId"];
            this.cotizacion_EstadoTarifaViajeId = _data["cotizacion_EstadoTarifaViajeId"];
            this.cotizacion_EstadoDescripcion = _data["cotizacion_EstadoDescripcion"];
            this.liquidacion_TarifaId = _data["liquidacion_TarifaId"];
            this.liquidacion_EstadoTarifaViajeId = _data["liquidacion_EstadoTarifaViajeId"];
            this.liquidacion_EstadoDescripcion = _data["liquidacion_EstadoDescripcion"];
            this.empresaNombre = _data["empresaNombre"];
            this.nombreCliente = _data["nombreCliente"];
            this.referenciaCliente = _data["referenciaCliente"];
            this.localidadOrigen = _data["localidadOrigen"];
            this.canceladoManual = _data["canceladoManual"];
            this.fechaBaja = _data["fechaBaja"] ? new Date(_data["fechaBaja"].toString()) : <any>undefined;
            this.securityCompanyId = _data["securityCompanyId"];
            this.clienteId = _data["clienteId"];
            this.registroDocumentoId = _data["registroDocumentoId"];
            this.workOrder = _data["workOrder"];
            this.id = _data["id"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.proveedor = _data["proveedor"];
            this.fechaLiquidacion = _data["fechaLiquidacion"];
            this.numeroBL = _data["numeroBL"];
        }
    }

    static fromJS(data: any): VTA_ViajeView {
        data = typeof data === 'object' ? data : {};
        let result = new VTA_ViajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numeroViaje"] = this.numeroViaje;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        data["estadoViajeId"] = this.estadoViajeId;
        data["estadoViaje"] = this.estadoViaje;
        data["modoCreacionId"] = this.modoCreacionId;
        data["modoCreacion"] = this.modoCreacion;
        data["tipoOperacionId"] = this.tipoOperacionId;
        data["tipoOperacion"] = this.tipoOperacion;
        data["esCombinado"] = this.esCombinado;
        data["esCombinadoObservacion"] = this.esCombinadoObservacion;
        data["fechaTraspaso"] = this.fechaTraspaso ? this.fechaTraspaso.toISOString() : <any>undefined;
        data["numeroBooking"] = this.numeroBooking;
        data["codigoISO"] = this.codigoISO;
        data["matriculaEquipamiento"] = this.matriculaEquipamiento;
        data["viajeEmpresaEntrega"] = this.viajeEmpresaEntrega;
        data["fechaEntrega"] = this.fechaEntrega ? this.fechaEntrega.toISOString() : <any>undefined;
        data["estadoEntregaId"] = this.estadoEntregaId;
        data["estadoEntrega"] = this.estadoEntrega;
        data["viajeEmpresaAdmision"] = this.viajeEmpresaAdmision;
        data["fechaAdmision"] = this.fechaAdmision ? this.fechaAdmision.toISOString() : <any>undefined;
        data["estadoAdmisionId"] = this.estadoAdmisionId;
        data["estadoAdmision"] = this.estadoAdmision;
        data["localizadorEntrega"] = this.localizadorEntrega;
        data["localizadorAdmision"] = this.localizadorAdmision;
        data["hayReefer"] = this.hayReefer;
        data["hayMercanciaPeligrosa"] = this.hayMercanciaPeligrosa;
        data["precintoEntrega"] = this.precintoEntrega;
        data["precintoAdmision"] = this.precintoAdmision;
        data["entregaConductor"] = this.entregaConductor;
        data["entregaEmpresaAjenaId"] = this.entregaEmpresaAjenaId;
        data["entregaEmpresaAjenaNombre"] = this.entregaEmpresaAjenaNombre;
        data["vehiculosEntrega"] = this.vehiculosEntrega;
        data["admisionConductor"] = this.admisionConductor;
        data["admisionEmpresaAjenaId"] = this.admisionEmpresaAjenaId;
        data["admisionEmpresaAjenaNombre"] = this.admisionEmpresaAjenaNombre;
        data["vehiculosAdmision"] = this.vehiculosAdmision;
        data["cargador"] = this.cargador;
        data["localidad"] = this.localidad;
        data["km"] = this.km;
        data["fechaCargadorTemprano"] = this.fechaCargadorTemprano ? this.fechaCargadorTemprano.toISOString() : <any>undefined;
        data["orden"] = this.orden;
        data["cotizacion_TarifaId"] = this.cotizacion_TarifaId;
        data["cotizacion_EstadoTarifaViajeId"] = this.cotizacion_EstadoTarifaViajeId;
        data["cotizacion_EstadoDescripcion"] = this.cotizacion_EstadoDescripcion;
        data["liquidacion_TarifaId"] = this.liquidacion_TarifaId;
        data["liquidacion_EstadoTarifaViajeId"] = this.liquidacion_EstadoTarifaViajeId;
        data["liquidacion_EstadoDescripcion"] = this.liquidacion_EstadoDescripcion;
        data["empresaNombre"] = this.empresaNombre;
        data["nombreCliente"] = this.nombreCliente;
        data["referenciaCliente"] = this.referenciaCliente;
        data["localidadOrigen"] = this.localidadOrigen;
        data["canceladoManual"] = this.canceladoManual;
        data["fechaBaja"] = this.fechaBaja ? this.fechaBaja.toISOString() : <any>undefined;
        data["securityCompanyId"] = this.securityCompanyId;
        data["clienteId"] = this.clienteId;
        data["registroDocumentoId"] = this.registroDocumentoId;
        data["workOrder"] = this.workOrder;
        data["id"] = this.id;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["proveedor"] = this.proveedor;
        data["fechaLiquidacion"] = this.fechaLiquidacion;
        data["numeroBL"] = this.numeroBL;
        return data;
    }
}

export interface IVTA_ViajeView {
    numeroViaje?: string | undefined;
    fecha?: Date | undefined;
    estadoViajeId?: number | undefined;
    estadoViaje?: string | undefined;
    modoCreacionId?: number | undefined;
    modoCreacion?: string | undefined;
    tipoOperacionId?: number | undefined;
    tipoOperacion?: string | undefined;
    esCombinado?: boolean | undefined;
    esCombinadoObservacion?: string | undefined;
    fechaTraspaso?: Date | undefined;
    numeroBooking?: string | undefined;
    codigoISO?: string | undefined;
    matriculaEquipamiento?: string | undefined;
    viajeEmpresaEntrega?: string | undefined;
    fechaEntrega?: Date | undefined;
    estadoEntregaId?: number | undefined;
    estadoEntrega?: string | undefined;
    viajeEmpresaAdmision?: string | undefined;
    fechaAdmision?: Date | undefined;
    estadoAdmisionId?: number | undefined;
    estadoAdmision?: string | undefined;
    localizadorEntrega?: string | undefined;
    localizadorAdmision?: string | undefined;
    hayReefer?: boolean | undefined;
    hayMercanciaPeligrosa?: boolean | undefined;
    precintoEntrega?: string | undefined;
    precintoAdmision?: string | undefined;
    entregaConductor?: string | undefined;
    entregaEmpresaAjenaId?: number | undefined;
    entregaEmpresaAjenaNombre?: string | undefined;
    vehiculosEntrega?: string | undefined;
    admisionConductor?: string | undefined;
    admisionEmpresaAjenaId?: number | undefined;
    admisionEmpresaAjenaNombre?: string | undefined;
    vehiculosAdmision?: string | undefined;
    cargador?: string | undefined;
    localidad?: string | undefined;
    km?: number | undefined;
    fechaCargadorTemprano?: Date | undefined;
    orden?: number | undefined;
    cotizacion_TarifaId?: number | undefined;
    cotizacion_EstadoTarifaViajeId?: number | undefined;
    cotizacion_EstadoDescripcion?: string | undefined;
    liquidacion_TarifaId?: number | undefined;
    liquidacion_EstadoTarifaViajeId?: number | undefined;
    liquidacion_EstadoDescripcion?: string | undefined;
    empresaNombre?: string | undefined;
    nombreCliente?: string | undefined;
    referenciaCliente?: string | undefined;
    localidadOrigen?: string | undefined;
    canceladoManual?: boolean | undefined;
    fechaBaja?: Date | undefined;
    securityCompanyId?: number | undefined;
    clienteId?: number | undefined;
    registroDocumentoId?: number | undefined;
    workOrder?: string | undefined;
    id?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    proveedor?: string | undefined;
    fechaLiquidacion?: string | undefined;
    numeroBL?: string | undefined;
}

export class VehiculoExtintorView implements IVehiculoExtintorView {
    id?: number;
    vehiculoId?: number;
    numero?: string | undefined;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;

    constructor(data?: IVehiculoExtintorView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehiculoId = _data["vehiculoId"];
            this.numero = _data["numero"];
            this.fechaCaducidad = _data["fechaCaducidad"] ? new Date(_data["fechaCaducidad"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.vehiculo = _data["vehiculo"] ? VehiculoView.fromJS(_data["vehiculo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehiculoExtintorView {
        data = typeof data === 'object' ? data : {};
        let result = new VehiculoExtintorView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehiculoId"] = this.vehiculoId;
        data["numero"] = this.numero;
        data["fechaCaducidad"] = this.fechaCaducidad ? this.fechaCaducidad.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["vehiculo"] = this.vehiculo ? this.vehiculo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehiculoExtintorView {
    id?: number;
    vehiculoId?: number;
    numero?: string | undefined;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;
}

export class VehiculoIntervencionTallerView implements IVehiculoIntervencionTallerView {
    id?: number;
    fecha?: Date | undefined;
    importe?: number | undefined;
    descripcion?: string | undefined;
    tipoIntervencionId?: number;
    vehiculoId?: number;
    cantidad?: number | undefined;
    tipoUnidadId?: number | undefined;
    numeroFactura?: string | undefined;
    proveedor?: string | undefined;
    materiales?: string | undefined;
    manoDeObra?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoIntervencion?: TipoIntervencionView;
    tipoUnidad?: TipoUnidadMercanciaView;
    vehiculo?: VehiculoView;

    constructor(data?: IVehiculoIntervencionTallerView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fecha = _data["fecha"] ? new Date(_data["fecha"].toString()) : <any>undefined;
            this.importe = _data["importe"];
            this.descripcion = _data["descripcion"];
            this.tipoIntervencionId = _data["tipoIntervencionId"];
            this.vehiculoId = _data["vehiculoId"];
            this.cantidad = _data["cantidad"];
            this.tipoUnidadId = _data["tipoUnidadId"];
            this.numeroFactura = _data["numeroFactura"];
            this.proveedor = _data["proveedor"];
            this.materiales = _data["materiales"];
            this.manoDeObra = _data["manoDeObra"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoIntervencion = _data["tipoIntervencion"] ? TipoIntervencionView.fromJS(_data["tipoIntervencion"]) : <any>undefined;
            this.tipoUnidad = _data["tipoUnidad"] ? TipoUnidadMercanciaView.fromJS(_data["tipoUnidad"]) : <any>undefined;
            this.vehiculo = _data["vehiculo"] ? VehiculoView.fromJS(_data["vehiculo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehiculoIntervencionTallerView {
        data = typeof data === 'object' ? data : {};
        let result = new VehiculoIntervencionTallerView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        data["importe"] = this.importe;
        data["descripcion"] = this.descripcion;
        data["tipoIntervencionId"] = this.tipoIntervencionId;
        data["vehiculoId"] = this.vehiculoId;
        data["cantidad"] = this.cantidad;
        data["tipoUnidadId"] = this.tipoUnidadId;
        data["numeroFactura"] = this.numeroFactura;
        data["proveedor"] = this.proveedor;
        data["materiales"] = this.materiales;
        data["manoDeObra"] = this.manoDeObra;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoIntervencion"] = this.tipoIntervencion ? this.tipoIntervencion.toJSON() : <any>undefined;
        data["tipoUnidad"] = this.tipoUnidad ? this.tipoUnidad.toJSON() : <any>undefined;
        data["vehiculo"] = this.vehiculo ? this.vehiculo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehiculoIntervencionTallerView {
    id?: number;
    fecha?: Date | undefined;
    importe?: number | undefined;
    descripcion?: string | undefined;
    tipoIntervencionId?: number;
    vehiculoId?: number;
    cantidad?: number | undefined;
    tipoUnidadId?: number | undefined;
    numeroFactura?: string | undefined;
    proveedor?: string | undefined;
    materiales?: string | undefined;
    manoDeObra?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoIntervencion?: TipoIntervencionView;
    tipoUnidad?: TipoUnidadMercanciaView;
    vehiculo?: VehiculoView;
}

export class VehiculoSeguroView implements IVehiculoSeguroView {
    id?: number;
    vehiculoId?: number;
    companyia?: string | undefined;
    numeroPoliza?: string | undefined;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;

    constructor(data?: IVehiculoSeguroView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehiculoId = _data["vehiculoId"];
            this.companyia = _data["companyia"];
            this.numeroPoliza = _data["numeroPoliza"];
            this.fechaCaducidad = _data["fechaCaducidad"] ? new Date(_data["fechaCaducidad"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.vehiculo = _data["vehiculo"] ? VehiculoView.fromJS(_data["vehiculo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehiculoSeguroView {
        data = typeof data === 'object' ? data : {};
        let result = new VehiculoSeguroView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehiculoId"] = this.vehiculoId;
        data["companyia"] = this.companyia;
        data["numeroPoliza"] = this.numeroPoliza;
        data["fechaCaducidad"] = this.fechaCaducidad ? this.fechaCaducidad.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["vehiculo"] = this.vehiculo ? this.vehiculo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehiculoSeguroView {
    id?: number;
    vehiculoId?: number;
    companyia?: string | undefined;
    numeroPoliza?: string | undefined;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;
}

export class VehiculoTacografoView implements IVehiculoTacografoView {
    id?: number;
    vehiculoId?: number;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;

    constructor(data?: IVehiculoTacografoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehiculoId = _data["vehiculoId"];
            this.fechaCaducidad = _data["fechaCaducidad"] ? new Date(_data["fechaCaducidad"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.vehiculo = _data["vehiculo"] ? VehiculoView.fromJS(_data["vehiculo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VehiculoTacografoView {
        data = typeof data === 'object' ? data : {};
        let result = new VehiculoTacografoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehiculoId"] = this.vehiculoId;
        data["fechaCaducidad"] = this.fechaCaducidad ? this.fechaCaducidad.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["vehiculo"] = this.vehiculo ? this.vehiculo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehiculoTacografoView {
    id?: number;
    vehiculoId?: number;
    fechaCaducidad?: Date;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;
}

export class VehiculoView implements IVehiculoView {
    id?: number;
    matricula?: string | undefined;
    tipoVehiculoId?: number;
    vehiculoAsociadoId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    clasificacionVehiculoId?: number | undefined;
    bastidor?: string | undefined;
    marca?: string | undefined;
    modelo?: string | undefined;
    tara?: number | undefined;
    fechaMatriculacion?: Date | undefined;
    caducidadITV?: Date | undefined;
    frigorifico?: boolean;
    mmpp?: boolean;
    observaciones?: string | undefined;
    mma?: number | undefined;
    clasificacionVehiculo?: ClasificacionVehiculoView;
    empleado?: EmpleadoView[] | undefined;
    inverseVehiculoAsociado?: VehiculoView[] | undefined;
    tipoVehiculo?: TipoVehiculoView;
    vehiculoAsociado?: VehiculoView;
    vehiculoExtintor?: VehiculoExtintorView[] | undefined;
    vehiculoIntervencionTaller?: VehiculoIntervencionTallerView[] | undefined;
    vehiculoSeguro?: VehiculoSeguroView[] | undefined;
    vehiculoTacografo?: VehiculoTacografoView;
    vehiculo_SecurityCompany?: Vehiculo_SecurityCompanyView[] | undefined;
    viajeConductorVehiculoCabeza?: ViajeConductorVehiculoView[] | undefined;
    viajeConductorVehiculoRemolque?: ViajeConductorVehiculoView[] | undefined;

    constructor(data?: IVehiculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.matricula = _data["matricula"];
            this.tipoVehiculoId = _data["tipoVehiculoId"];
            this.vehiculoAsociadoId = _data["vehiculoAsociadoId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.clasificacionVehiculoId = _data["clasificacionVehiculoId"];
            this.bastidor = _data["bastidor"];
            this.marca = _data["marca"];
            this.modelo = _data["modelo"];
            this.tara = _data["tara"];
            this.fechaMatriculacion = _data["fechaMatriculacion"] ? new Date(_data["fechaMatriculacion"].toString()) : <any>undefined;
            this.caducidadITV = _data["caducidadITV"] ? new Date(_data["caducidadITV"].toString()) : <any>undefined;
            this.frigorifico = _data["frigorifico"];
            this.mmpp = _data["mmpp"];
            this.observaciones = _data["observaciones"];
            this.mma = _data["mma"];
            this.clasificacionVehiculo = _data["clasificacionVehiculo"] ? ClasificacionVehiculoView.fromJS(_data["clasificacionVehiculo"]) : <any>undefined;
            if (Array.isArray(_data["empleado"])) {
                this.empleado = [] as any;
                for (let item of _data["empleado"])
                    this.empleado!.push(EmpleadoView.fromJS(item));
            }
            if (Array.isArray(_data["inverseVehiculoAsociado"])) {
                this.inverseVehiculoAsociado = [] as any;
                for (let item of _data["inverseVehiculoAsociado"])
                    this.inverseVehiculoAsociado!.push(VehiculoView.fromJS(item));
            }
            this.tipoVehiculo = _data["tipoVehiculo"] ? TipoVehiculoView.fromJS(_data["tipoVehiculo"]) : <any>undefined;
            this.vehiculoAsociado = _data["vehiculoAsociado"] ? VehiculoView.fromJS(_data["vehiculoAsociado"]) : <any>undefined;
            if (Array.isArray(_data["vehiculoExtintor"])) {
                this.vehiculoExtintor = [] as any;
                for (let item of _data["vehiculoExtintor"])
                    this.vehiculoExtintor!.push(VehiculoExtintorView.fromJS(item));
            }
            if (Array.isArray(_data["vehiculoIntervencionTaller"])) {
                this.vehiculoIntervencionTaller = [] as any;
                for (let item of _data["vehiculoIntervencionTaller"])
                    this.vehiculoIntervencionTaller!.push(VehiculoIntervencionTallerView.fromJS(item));
            }
            if (Array.isArray(_data["vehiculoSeguro"])) {
                this.vehiculoSeguro = [] as any;
                for (let item of _data["vehiculoSeguro"])
                    this.vehiculoSeguro!.push(VehiculoSeguroView.fromJS(item));
            }
            this.vehiculoTacografo = _data["vehiculoTacografo"] ? VehiculoTacografoView.fromJS(_data["vehiculoTacografo"]) : <any>undefined;
            if (Array.isArray(_data["vehiculo_SecurityCompany"])) {
                this.vehiculo_SecurityCompany = [] as any;
                for (let item of _data["vehiculo_SecurityCompany"])
                    this.vehiculo_SecurityCompany!.push(Vehiculo_SecurityCompanyView.fromJS(item));
            }
            if (Array.isArray(_data["viajeConductorVehiculoCabeza"])) {
                this.viajeConductorVehiculoCabeza = [] as any;
                for (let item of _data["viajeConductorVehiculoCabeza"])
                    this.viajeConductorVehiculoCabeza!.push(ViajeConductorVehiculoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeConductorVehiculoRemolque"])) {
                this.viajeConductorVehiculoRemolque = [] as any;
                for (let item of _data["viajeConductorVehiculoRemolque"])
                    this.viajeConductorVehiculoRemolque!.push(ViajeConductorVehiculoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VehiculoView {
        data = typeof data === 'object' ? data : {};
        let result = new VehiculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["matricula"] = this.matricula;
        data["tipoVehiculoId"] = this.tipoVehiculoId;
        data["vehiculoAsociadoId"] = this.vehiculoAsociadoId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["clasificacionVehiculoId"] = this.clasificacionVehiculoId;
        data["bastidor"] = this.bastidor;
        data["marca"] = this.marca;
        data["modelo"] = this.modelo;
        data["tara"] = this.tara;
        data["fechaMatriculacion"] = this.fechaMatriculacion ? this.fechaMatriculacion.toISOString() : <any>undefined;
        data["caducidadITV"] = this.caducidadITV ? this.caducidadITV.toISOString() : <any>undefined;
        data["frigorifico"] = this.frigorifico;
        data["mmpp"] = this.mmpp;
        data["observaciones"] = this.observaciones;
        data["mma"] = this.mma;
        data["clasificacionVehiculo"] = this.clasificacionVehiculo ? this.clasificacionVehiculo.toJSON() : <any>undefined;
        if (Array.isArray(this.empleado)) {
            data["empleado"] = [];
            for (let item of this.empleado)
                data["empleado"].push(item.toJSON());
        }
        if (Array.isArray(this.inverseVehiculoAsociado)) {
            data["inverseVehiculoAsociado"] = [];
            for (let item of this.inverseVehiculoAsociado)
                data["inverseVehiculoAsociado"].push(item.toJSON());
        }
        data["tipoVehiculo"] = this.tipoVehiculo ? this.tipoVehiculo.toJSON() : <any>undefined;
        data["vehiculoAsociado"] = this.vehiculoAsociado ? this.vehiculoAsociado.toJSON() : <any>undefined;
        if (Array.isArray(this.vehiculoExtintor)) {
            data["vehiculoExtintor"] = [];
            for (let item of this.vehiculoExtintor)
                data["vehiculoExtintor"].push(item.toJSON());
        }
        if (Array.isArray(this.vehiculoIntervencionTaller)) {
            data["vehiculoIntervencionTaller"] = [];
            for (let item of this.vehiculoIntervencionTaller)
                data["vehiculoIntervencionTaller"].push(item.toJSON());
        }
        if (Array.isArray(this.vehiculoSeguro)) {
            data["vehiculoSeguro"] = [];
            for (let item of this.vehiculoSeguro)
                data["vehiculoSeguro"].push(item.toJSON());
        }
        data["vehiculoTacografo"] = this.vehiculoTacografo ? this.vehiculoTacografo.toJSON() : <any>undefined;
        if (Array.isArray(this.vehiculo_SecurityCompany)) {
            data["vehiculo_SecurityCompany"] = [];
            for (let item of this.vehiculo_SecurityCompany)
                data["vehiculo_SecurityCompany"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeConductorVehiculoCabeza)) {
            data["viajeConductorVehiculoCabeza"] = [];
            for (let item of this.viajeConductorVehiculoCabeza)
                data["viajeConductorVehiculoCabeza"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeConductorVehiculoRemolque)) {
            data["viajeConductorVehiculoRemolque"] = [];
            for (let item of this.viajeConductorVehiculoRemolque)
                data["viajeConductorVehiculoRemolque"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVehiculoView {
    id?: number;
    matricula?: string | undefined;
    tipoVehiculoId?: number;
    vehiculoAsociadoId?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    clasificacionVehiculoId?: number | undefined;
    bastidor?: string | undefined;
    marca?: string | undefined;
    modelo?: string | undefined;
    tara?: number | undefined;
    fechaMatriculacion?: Date | undefined;
    caducidadITV?: Date | undefined;
    frigorifico?: boolean;
    mmpp?: boolean;
    observaciones?: string | undefined;
    mma?: number | undefined;
    clasificacionVehiculo?: ClasificacionVehiculoView;
    empleado?: EmpleadoView[] | undefined;
    inverseVehiculoAsociado?: VehiculoView[] | undefined;
    tipoVehiculo?: TipoVehiculoView;
    vehiculoAsociado?: VehiculoView;
    vehiculoExtintor?: VehiculoExtintorView[] | undefined;
    vehiculoIntervencionTaller?: VehiculoIntervencionTallerView[] | undefined;
    vehiculoSeguro?: VehiculoSeguroView[] | undefined;
    vehiculoTacografo?: VehiculoTacografoView;
    vehiculo_SecurityCompany?: Vehiculo_SecurityCompanyView[] | undefined;
    viajeConductorVehiculoCabeza?: ViajeConductorVehiculoView[] | undefined;
    viajeConductorVehiculoRemolque?: ViajeConductorVehiculoView[] | undefined;
}

export class Vehiculo_SecurityCompanyView implements IVehiculo_SecurityCompanyView {
    id?: number;
    vehiculoId?: number;
    securityCompanyId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;

    constructor(data?: IVehiculo_SecurityCompanyView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.vehiculoId = _data["vehiculoId"];
            this.securityCompanyId = _data["securityCompanyId"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.vehiculo = _data["vehiculo"] ? VehiculoView.fromJS(_data["vehiculo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Vehiculo_SecurityCompanyView {
        data = typeof data === 'object' ? data : {};
        let result = new Vehiculo_SecurityCompanyView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["vehiculoId"] = this.vehiculoId;
        data["securityCompanyId"] = this.securityCompanyId;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["vehiculo"] = this.vehiculo ? this.vehiculo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVehiculo_SecurityCompanyView {
    id?: number;
    vehiculoId?: number;
    securityCompanyId?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    vehiculo?: VehiculoView;
}

export class ViajeAgenteView implements IViajeAgenteView {
    guardarEmpresa?: boolean | undefined;
    localidadId?: number | undefined;
    id?: number;
    viajeId?: number;
    nombreAgente?: string | undefined;
    numeroDocumento?: string | undefined;
    codigoAgente?: string | undefined;
    direccionAgente?: string | undefined;
    codigoPostal?: string | undefined;
    localidadAgente?: string | undefined;
    empresaId?: number | undefined;
    tipoEmpresaId?: number;
    direccionDestinoId?: number | undefined;
    referencia?: string | undefined;
    numeroAutorizacion?: string | undefined;
    informacionDetectada?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    direccionDestino?: EmpresaDireccionView;
    empresa?: EmpresaView;
    tipoEmpresa?: TipoEmpresaView;
    viaje?: ViajeView;

    constructor(data?: IViajeAgenteView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guardarEmpresa = _data["guardarEmpresa"];
            this.localidadId = _data["localidadId"];
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.nombreAgente = _data["nombreAgente"];
            this.numeroDocumento = _data["numeroDocumento"];
            this.codigoAgente = _data["codigoAgente"];
            this.direccionAgente = _data["direccionAgente"];
            this.codigoPostal = _data["codigoPostal"];
            this.localidadAgente = _data["localidadAgente"];
            this.empresaId = _data["empresaId"];
            this.tipoEmpresaId = _data["tipoEmpresaId"];
            this.direccionDestinoId = _data["direccionDestinoId"];
            this.referencia = _data["referencia"];
            this.numeroAutorizacion = _data["numeroAutorizacion"];
            this.informacionDetectada = _data["informacionDetectada"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.direccionDestino = _data["direccionDestino"] ? EmpresaDireccionView.fromJS(_data["direccionDestino"]) : <any>undefined;
            this.empresa = _data["empresa"] ? EmpresaView.fromJS(_data["empresa"]) : <any>undefined;
            this.tipoEmpresa = _data["tipoEmpresa"] ? TipoEmpresaView.fromJS(_data["tipoEmpresa"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeAgenteView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeAgenteView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guardarEmpresa"] = this.guardarEmpresa;
        data["localidadId"] = this.localidadId;
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["nombreAgente"] = this.nombreAgente;
        data["numeroDocumento"] = this.numeroDocumento;
        data["codigoAgente"] = this.codigoAgente;
        data["direccionAgente"] = this.direccionAgente;
        data["codigoPostal"] = this.codigoPostal;
        data["localidadAgente"] = this.localidadAgente;
        data["empresaId"] = this.empresaId;
        data["tipoEmpresaId"] = this.tipoEmpresaId;
        data["direccionDestinoId"] = this.direccionDestinoId;
        data["referencia"] = this.referencia;
        data["numeroAutorizacion"] = this.numeroAutorizacion;
        data["informacionDetectada"] = this.informacionDetectada;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["direccionDestino"] = this.direccionDestino ? this.direccionDestino.toJSON() : <any>undefined;
        data["empresa"] = this.empresa ? this.empresa.toJSON() : <any>undefined;
        data["tipoEmpresa"] = this.tipoEmpresa ? this.tipoEmpresa.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeAgenteView {
    guardarEmpresa?: boolean | undefined;
    localidadId?: number | undefined;
    id?: number;
    viajeId?: number;
    nombreAgente?: string | undefined;
    numeroDocumento?: string | undefined;
    codigoAgente?: string | undefined;
    direccionAgente?: string | undefined;
    codigoPostal?: string | undefined;
    localidadAgente?: string | undefined;
    empresaId?: number | undefined;
    tipoEmpresaId?: number;
    direccionDestinoId?: number | undefined;
    referencia?: string | undefined;
    numeroAutorizacion?: string | undefined;
    informacionDetectada?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    direccionDestino?: EmpresaDireccionView;
    empresa?: EmpresaView;
    tipoEmpresa?: TipoEmpresaView;
    viaje?: ViajeView;
}

export class ViajeBuqueView implements IViajeBuqueView {
    id?: number;
    viajeId?: number;
    tipoOperacionBuqueId?: number | undefined;
    nombreBuque?: string | undefined;
    numeroViajeMaritimo?: string | undefined;
    numeroEscala?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoOperacionBuque?: TipoOperacionBuqueView;
    viaje?: ViajeView;

    constructor(data?: IViajeBuqueView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.tipoOperacionBuqueId = _data["tipoOperacionBuqueId"];
            this.nombreBuque = _data["nombreBuque"];
            this.numeroViajeMaritimo = _data["numeroViajeMaritimo"];
            this.numeroEscala = _data["numeroEscala"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoOperacionBuque = _data["tipoOperacionBuque"] ? TipoOperacionBuqueView.fromJS(_data["tipoOperacionBuque"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeBuqueView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeBuqueView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["tipoOperacionBuqueId"] = this.tipoOperacionBuqueId;
        data["nombreBuque"] = this.nombreBuque;
        data["numeroViajeMaritimo"] = this.numeroViajeMaritimo;
        data["numeroEscala"] = this.numeroEscala;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoOperacionBuque"] = this.tipoOperacionBuque ? this.tipoOperacionBuque.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeBuqueView {
    id?: number;
    viajeId?: number;
    tipoOperacionBuqueId?: number | undefined;
    nombreBuque?: string | undefined;
    numeroViajeMaritimo?: string | undefined;
    numeroEscala?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoOperacionBuque?: TipoOperacionBuqueView;
    viaje?: ViajeView;
}

export class ViajeCargadorView implements IViajeCargadorView {
    guardarEmpresa?: boolean | undefined;
    id?: number;
    viajeId?: number;
    orden?: number;
    referenciaCarga?: string | undefined;
    nombreEmpresa?: string | undefined;
    direccionEmpresa?: string | undefined;
    codigoPostal?: string | undefined;
    localidad?: string | undefined;
    localidadId?: number | undefined;
    pais?: string | undefined;
    empresaId?: number | undefined;
    direccionId?: number | undefined;
    fechaPrevista?: Date | undefined;
    fechaSolicitada?: Date | undefined;
    km?: number | undefined;
    observacion?: string | undefined;
    informacionDetectada?: string | undefined;
    cargadorFacturable?: boolean | undefined;
    distanciaRutaId?: number | undefined;
    horasDemora?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    direccion?: EmpresaDireccionView;
    distanciaRuta?: DistanciaView;
    empresa?: EmpresaView;
    localidadNavigation?: LocalidadView;
    viaje?: ViajeView;

    constructor(data?: IViajeCargadorView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guardarEmpresa = _data["guardarEmpresa"];
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.orden = _data["orden"];
            this.referenciaCarga = _data["referenciaCarga"];
            this.nombreEmpresa = _data["nombreEmpresa"];
            this.direccionEmpresa = _data["direccionEmpresa"];
            this.codigoPostal = _data["codigoPostal"];
            this.localidad = _data["localidad"];
            this.localidadId = _data["localidadId"];
            this.pais = _data["pais"];
            this.empresaId = _data["empresaId"];
            this.direccionId = _data["direccionId"];
            this.fechaPrevista = _data["fechaPrevista"] ? new Date(_data["fechaPrevista"].toString()) : <any>undefined;
            this.fechaSolicitada = _data["fechaSolicitada"] ? new Date(_data["fechaSolicitada"].toString()) : <any>undefined;
            this.km = _data["km"];
            this.observacion = _data["observacion"];
            this.informacionDetectada = _data["informacionDetectada"];
            this.cargadorFacturable = _data["cargadorFacturable"];
            this.distanciaRutaId = _data["distanciaRutaId"];
            this.horasDemora = _data["horasDemora"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.direccion = _data["direccion"] ? EmpresaDireccionView.fromJS(_data["direccion"]) : <any>undefined;
            this.distanciaRuta = _data["distanciaRuta"] ? DistanciaView.fromJS(_data["distanciaRuta"]) : <any>undefined;
            this.empresa = _data["empresa"] ? EmpresaView.fromJS(_data["empresa"]) : <any>undefined;
            this.localidadNavigation = _data["localidadNavigation"] ? LocalidadView.fromJS(_data["localidadNavigation"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeCargadorView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeCargadorView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guardarEmpresa"] = this.guardarEmpresa;
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["orden"] = this.orden;
        data["referenciaCarga"] = this.referenciaCarga;
        data["nombreEmpresa"] = this.nombreEmpresa;
        data["direccionEmpresa"] = this.direccionEmpresa;
        data["codigoPostal"] = this.codigoPostal;
        data["localidad"] = this.localidad;
        data["localidadId"] = this.localidadId;
        data["pais"] = this.pais;
        data["empresaId"] = this.empresaId;
        data["direccionId"] = this.direccionId;
        data["fechaPrevista"] = this.fechaPrevista ? this.fechaPrevista.toISOString() : <any>undefined;
        data["fechaSolicitada"] = this.fechaSolicitada ? this.fechaSolicitada.toISOString() : <any>undefined;
        data["km"] = this.km;
        data["observacion"] = this.observacion;
        data["informacionDetectada"] = this.informacionDetectada;
        data["cargadorFacturable"] = this.cargadorFacturable;
        data["distanciaRutaId"] = this.distanciaRutaId;
        data["horasDemora"] = this.horasDemora;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["direccion"] = this.direccion ? this.direccion.toJSON() : <any>undefined;
        data["distanciaRuta"] = this.distanciaRuta ? this.distanciaRuta.toJSON() : <any>undefined;
        data["empresa"] = this.empresa ? this.empresa.toJSON() : <any>undefined;
        data["localidadNavigation"] = this.localidadNavigation ? this.localidadNavigation.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeCargadorView {
    guardarEmpresa?: boolean | undefined;
    id?: number;
    viajeId?: number;
    orden?: number;
    referenciaCarga?: string | undefined;
    nombreEmpresa?: string | undefined;
    direccionEmpresa?: string | undefined;
    codigoPostal?: string | undefined;
    localidad?: string | undefined;
    localidadId?: number | undefined;
    pais?: string | undefined;
    empresaId?: number | undefined;
    direccionId?: number | undefined;
    fechaPrevista?: Date | undefined;
    fechaSolicitada?: Date | undefined;
    km?: number | undefined;
    observacion?: string | undefined;
    informacionDetectada?: string | undefined;
    cargadorFacturable?: boolean | undefined;
    distanciaRutaId?: number | undefined;
    horasDemora?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    direccion?: EmpresaDireccionView;
    distanciaRuta?: DistanciaView;
    empresa?: EmpresaView;
    localidadNavigation?: LocalidadView;
    viaje?: ViajeView;
}

export class ViajeConductorVehiculoView implements IViajeConductorVehiculoView {
    guardarEntidades?: boolean | undefined;
    id?: number;
    viajeId?: number;
    conductorId?: number | undefined;
    cabezaId?: number | undefined;
    remolqueId?: number | undefined;
    liquidacionId?: number | undefined;
    esEntrega?: boolean | undefined;
    esAdmision?: boolean | undefined;
    nombreConductor?: string | undefined;
    nifConductor?: string | undefined;
    telefonoConductor?: string | undefined;
    emailConductor?: string | undefined;
    esPropioConductor?: boolean;
    empresaAjenaIdConductor?: number | undefined;
    empresaAjenaNombreConductor?: string | undefined;
    matriculaCabeza?: string | undefined;
    matriculaRemolque?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    cabeza?: VehiculoView;
    conductor?: EmpleadoView;
    empresaAjenaIdConductorNavigation?: EmpresaView;
    liquidacion?: LiquidacionView;
    remolque?: VehiculoView;
    viaje?: ViajeView;

    constructor(data?: IViajeConductorVehiculoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guardarEntidades = _data["guardarEntidades"];
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.conductorId = _data["conductorId"];
            this.cabezaId = _data["cabezaId"];
            this.remolqueId = _data["remolqueId"];
            this.liquidacionId = _data["liquidacionId"];
            this.esEntrega = _data["esEntrega"];
            this.esAdmision = _data["esAdmision"];
            this.nombreConductor = _data["nombreConductor"];
            this.nifConductor = _data["nifConductor"];
            this.telefonoConductor = _data["telefonoConductor"];
            this.emailConductor = _data["emailConductor"];
            this.esPropioConductor = _data["esPropioConductor"];
            this.empresaAjenaIdConductor = _data["empresaAjenaIdConductor"];
            this.empresaAjenaNombreConductor = _data["empresaAjenaNombreConductor"];
            this.matriculaCabeza = _data["matriculaCabeza"];
            this.matriculaRemolque = _data["matriculaRemolque"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.cabeza = _data["cabeza"] ? VehiculoView.fromJS(_data["cabeza"]) : <any>undefined;
            this.conductor = _data["conductor"] ? EmpleadoView.fromJS(_data["conductor"]) : <any>undefined;
            this.empresaAjenaIdConductorNavigation = _data["empresaAjenaIdConductorNavigation"] ? EmpresaView.fromJS(_data["empresaAjenaIdConductorNavigation"]) : <any>undefined;
            this.liquidacion = _data["liquidacion"] ? LiquidacionView.fromJS(_data["liquidacion"]) : <any>undefined;
            this.remolque = _data["remolque"] ? VehiculoView.fromJS(_data["remolque"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeConductorVehiculoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeConductorVehiculoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guardarEntidades"] = this.guardarEntidades;
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["conductorId"] = this.conductorId;
        data["cabezaId"] = this.cabezaId;
        data["remolqueId"] = this.remolqueId;
        data["liquidacionId"] = this.liquidacionId;
        data["esEntrega"] = this.esEntrega;
        data["esAdmision"] = this.esAdmision;
        data["nombreConductor"] = this.nombreConductor;
        data["nifConductor"] = this.nifConductor;
        data["telefonoConductor"] = this.telefonoConductor;
        data["emailConductor"] = this.emailConductor;
        data["esPropioConductor"] = this.esPropioConductor;
        data["empresaAjenaIdConductor"] = this.empresaAjenaIdConductor;
        data["empresaAjenaNombreConductor"] = this.empresaAjenaNombreConductor;
        data["matriculaCabeza"] = this.matriculaCabeza;
        data["matriculaRemolque"] = this.matriculaRemolque;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["cabeza"] = this.cabeza ? this.cabeza.toJSON() : <any>undefined;
        data["conductor"] = this.conductor ? this.conductor.toJSON() : <any>undefined;
        data["empresaAjenaIdConductorNavigation"] = this.empresaAjenaIdConductorNavigation ? this.empresaAjenaIdConductorNavigation.toJSON() : <any>undefined;
        data["liquidacion"] = this.liquidacion ? this.liquidacion.toJSON() : <any>undefined;
        data["remolque"] = this.remolque ? this.remolque.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeConductorVehiculoView {
    guardarEntidades?: boolean | undefined;
    id?: number;
    viajeId?: number;
    conductorId?: number | undefined;
    cabezaId?: number | undefined;
    remolqueId?: number | undefined;
    liquidacionId?: number | undefined;
    esEntrega?: boolean | undefined;
    esAdmision?: boolean | undefined;
    nombreConductor?: string | undefined;
    nifConductor?: string | undefined;
    telefonoConductor?: string | undefined;
    emailConductor?: string | undefined;
    esPropioConductor?: boolean;
    empresaAjenaIdConductor?: number | undefined;
    empresaAjenaNombreConductor?: string | undefined;
    matriculaCabeza?: string | undefined;
    matriculaRemolque?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    cabeza?: VehiculoView;
    conductor?: EmpleadoView;
    empresaAjenaIdConductorNavigation?: EmpresaView;
    liquidacion?: LiquidacionView;
    remolque?: VehiculoView;
    viaje?: ViajeView;
}

export class ViajeEquipamientoMercanciaPeligrosaView implements IViajeEquipamientoMercanciaPeligrosaView {
    id?: number;
    numeroAutorizacion?: string | undefined;
    codigoOnu?: string | undefined;
    descripcionMmpp?: string | undefined;
    codigoClase?: string | undefined;
    peligrosidadId?: number | undefined;
    esCantidadLimitada?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    peligrosidad?: TipoPeligrosidadView;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;

    constructor(data?: IViajeEquipamientoMercanciaPeligrosaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.numeroAutorizacion = _data["numeroAutorizacion"];
            this.codigoOnu = _data["codigoOnu"];
            this.descripcionMmpp = _data["descripcionMmpp"];
            this.codigoClase = _data["codigoClase"];
            this.peligrosidadId = _data["peligrosidadId"];
            this.esCantidadLimitada = _data["esCantidadLimitada"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.peligrosidad = _data["peligrosidad"] ? TipoPeligrosidadView.fromJS(_data["peligrosidad"]) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamientoMercancia"])) {
                this.viajeEquipamientoMercancia = [] as any;
                for (let item of _data["viajeEquipamientoMercancia"])
                    this.viajeEquipamientoMercancia!.push(ViajeEquipamientoMercanciaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViajeEquipamientoMercanciaPeligrosaView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeEquipamientoMercanciaPeligrosaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["numeroAutorizacion"] = this.numeroAutorizacion;
        data["codigoOnu"] = this.codigoOnu;
        data["descripcionMmpp"] = this.descripcionMmpp;
        data["codigoClase"] = this.codigoClase;
        data["peligrosidadId"] = this.peligrosidadId;
        data["esCantidadLimitada"] = this.esCantidadLimitada;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["peligrosidad"] = this.peligrosidad ? this.peligrosidad.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeEquipamientoMercancia)) {
            data["viajeEquipamientoMercancia"] = [];
            for (let item of this.viajeEquipamientoMercancia)
                data["viajeEquipamientoMercancia"].push(item.toJSON());
        }
        return data;
    }
}

export interface IViajeEquipamientoMercanciaPeligrosaView {
    id?: number;
    numeroAutorizacion?: string | undefined;
    codigoOnu?: string | undefined;
    descripcionMmpp?: string | undefined;
    codigoClase?: string | undefined;
    peligrosidadId?: number | undefined;
    esCantidadLimitada?: boolean | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    peligrosidad?: TipoPeligrosidadView;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;
}

export class ViajeEquipamientoMercanciaView implements IViajeEquipamientoMercanciaView {
    id?: number;
    viajeEquipamientoId?: number;
    viajeEquipamientoMercanciaPeligrosaId?: number | undefined;
    tipoBultoId?: number | undefined;
    codigoBulto?: string | undefined;
    descripcionBulto?: string | undefined;
    informacionDetectadaBulto?: string | undefined;
    tipoMercanciaId?: number | undefined;
    codigoMercancia?: string | undefined;
    descripcionMercancia?: string | undefined;
    informacionDetectadaMercancia?: string | undefined;
    tipoUnidadId?: number | undefined;
    itemNumber?: number | undefined;
    numeroBultos?: number | undefined;
    cantidad?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoBulto?: TipoBultoView;
    tipoMercancia?: TipoMercanciaView;
    tipoUnidad?: TipoUnidadMercanciaView;
    viajeEquipamiento?: ViajeEquipamientoView;
    viajeEquipamientoMercanciaPeligrosa?: ViajeEquipamientoMercanciaPeligrosaView;

    constructor(data?: IViajeEquipamientoMercanciaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeEquipamientoId = _data["viajeEquipamientoId"];
            this.viajeEquipamientoMercanciaPeligrosaId = _data["viajeEquipamientoMercanciaPeligrosaId"];
            this.tipoBultoId = _data["tipoBultoId"];
            this.codigoBulto = _data["codigoBulto"];
            this.descripcionBulto = _data["descripcionBulto"];
            this.informacionDetectadaBulto = _data["informacionDetectadaBulto"];
            this.tipoMercanciaId = _data["tipoMercanciaId"];
            this.codigoMercancia = _data["codigoMercancia"];
            this.descripcionMercancia = _data["descripcionMercancia"];
            this.informacionDetectadaMercancia = _data["informacionDetectadaMercancia"];
            this.tipoUnidadId = _data["tipoUnidadId"];
            this.itemNumber = _data["itemNumber"];
            this.numeroBultos = _data["numeroBultos"];
            this.cantidad = _data["cantidad"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoBulto = _data["tipoBulto"] ? TipoBultoView.fromJS(_data["tipoBulto"]) : <any>undefined;
            this.tipoMercancia = _data["tipoMercancia"] ? TipoMercanciaView.fromJS(_data["tipoMercancia"]) : <any>undefined;
            this.tipoUnidad = _data["tipoUnidad"] ? TipoUnidadMercanciaView.fromJS(_data["tipoUnidad"]) : <any>undefined;
            this.viajeEquipamiento = _data["viajeEquipamiento"] ? ViajeEquipamientoView.fromJS(_data["viajeEquipamiento"]) : <any>undefined;
            this.viajeEquipamientoMercanciaPeligrosa = _data["viajeEquipamientoMercanciaPeligrosa"] ? ViajeEquipamientoMercanciaPeligrosaView.fromJS(_data["viajeEquipamientoMercanciaPeligrosa"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeEquipamientoMercanciaView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeEquipamientoMercanciaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeEquipamientoId"] = this.viajeEquipamientoId;
        data["viajeEquipamientoMercanciaPeligrosaId"] = this.viajeEquipamientoMercanciaPeligrosaId;
        data["tipoBultoId"] = this.tipoBultoId;
        data["codigoBulto"] = this.codigoBulto;
        data["descripcionBulto"] = this.descripcionBulto;
        data["informacionDetectadaBulto"] = this.informacionDetectadaBulto;
        data["tipoMercanciaId"] = this.tipoMercanciaId;
        data["codigoMercancia"] = this.codigoMercancia;
        data["descripcionMercancia"] = this.descripcionMercancia;
        data["informacionDetectadaMercancia"] = this.informacionDetectadaMercancia;
        data["tipoUnidadId"] = this.tipoUnidadId;
        data["itemNumber"] = this.itemNumber;
        data["numeroBultos"] = this.numeroBultos;
        data["cantidad"] = this.cantidad;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoBulto"] = this.tipoBulto ? this.tipoBulto.toJSON() : <any>undefined;
        data["tipoMercancia"] = this.tipoMercancia ? this.tipoMercancia.toJSON() : <any>undefined;
        data["tipoUnidad"] = this.tipoUnidad ? this.tipoUnidad.toJSON() : <any>undefined;
        data["viajeEquipamiento"] = this.viajeEquipamiento ? this.viajeEquipamiento.toJSON() : <any>undefined;
        data["viajeEquipamientoMercanciaPeligrosa"] = this.viajeEquipamientoMercanciaPeligrosa ? this.viajeEquipamientoMercanciaPeligrosa.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeEquipamientoMercanciaView {
    id?: number;
    viajeEquipamientoId?: number;
    viajeEquipamientoMercanciaPeligrosaId?: number | undefined;
    tipoBultoId?: number | undefined;
    codigoBulto?: string | undefined;
    descripcionBulto?: string | undefined;
    informacionDetectadaBulto?: string | undefined;
    tipoMercanciaId?: number | undefined;
    codigoMercancia?: string | undefined;
    descripcionMercancia?: string | undefined;
    informacionDetectadaMercancia?: string | undefined;
    tipoUnidadId?: number | undefined;
    itemNumber?: number | undefined;
    numeroBultos?: number | undefined;
    cantidad?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoBulto?: TipoBultoView;
    tipoMercancia?: TipoMercanciaView;
    tipoUnidad?: TipoUnidadMercanciaView;
    viajeEquipamiento?: ViajeEquipamientoView;
    viajeEquipamientoMercanciaPeligrosa?: ViajeEquipamientoMercanciaPeligrosaView;
}

export class ViajeEquipamientoPrecintoView implements IViajeEquipamientoPrecintoView {
    id?: number;
    viajeEquipamientoId?: number;
    tipoPrecintoId?: number;
    precinto?: string | undefined;
    esEntrega?: boolean;
    esAdmision?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoPrecinto?: TipoPrecintoView;
    viajeEquipamiento?: ViajeEquipamientoView;

    constructor(data?: IViajeEquipamientoPrecintoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeEquipamientoId = _data["viajeEquipamientoId"];
            this.tipoPrecintoId = _data["tipoPrecintoId"];
            this.precinto = _data["precinto"];
            this.esEntrega = _data["esEntrega"];
            this.esAdmision = _data["esAdmision"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoPrecinto = _data["tipoPrecinto"] ? TipoPrecintoView.fromJS(_data["tipoPrecinto"]) : <any>undefined;
            this.viajeEquipamiento = _data["viajeEquipamiento"] ? ViajeEquipamientoView.fromJS(_data["viajeEquipamiento"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeEquipamientoPrecintoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeEquipamientoPrecintoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeEquipamientoId"] = this.viajeEquipamientoId;
        data["tipoPrecintoId"] = this.tipoPrecintoId;
        data["precinto"] = this.precinto;
        data["esEntrega"] = this.esEntrega;
        data["esAdmision"] = this.esAdmision;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoPrecinto"] = this.tipoPrecinto ? this.tipoPrecinto.toJSON() : <any>undefined;
        data["viajeEquipamiento"] = this.viajeEquipamiento ? this.viajeEquipamiento.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeEquipamientoPrecintoView {
    id?: number;
    viajeEquipamientoId?: number;
    tipoPrecintoId?: number;
    precinto?: string | undefined;
    esEntrega?: boolean;
    esAdmision?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoPrecinto?: TipoPrecintoView;
    viajeEquipamiento?: ViajeEquipamientoView;
}

export class ViajeEquipamientoView implements IViajeEquipamientoView {
    guardarEmpresa?: boolean | undefined;
    tipoOperacionId?: number;
    id?: number;
    viajeId?: number;
    itemNumber?: string | undefined;
    matriculaEquipamiento?: string | undefined;
    codigoISO?: string | undefined;
    descripcionISO?: string | undefined;
    numeroBooking?: string | undefined;
    numeroBL?: string | undefined;
    numeroExpOL?: string | undefined;
    numeroDocumentoAsociado?: string | undefined;
    empresaEntregaId?: number | undefined;
    fechaSolicitadaEntrega?: Date | undefined;
    fechaConfirmacionEntrega?: Date | undefined;
    fechaEstimadaEntrega?: Date | undefined;
    estadoEntregaId?: number | undefined;
    empresaAdmisionId?: number | undefined;
    fechaSolicitadaAdmision?: Date | undefined;
    fechaConfirmacionAdmision?: Date | undefined;
    fechaEstimadaAdmision?: Date | undefined;
    estadoAdmisionId?: number | undefined;
    tara?: number | undefined;
    empresaEntregaCodigo?: string | undefined;
    empresaEntregaNombre?: string | undefined;
    empresaEntregaNumeroDocumento?: string | undefined;
    empresaEntregaDireccion?: string | undefined;
    empresaEntregaCodigoPostal?: string | undefined;
    empresaEntregaLocalidad?: string | undefined;
    empresaAdmisionCodigo?: string | undefined;
    empresaAdmisionNombre?: string | undefined;
    empresaAdmisionNumeroDocumento?: string | undefined;
    empresaAdmisionDireccion?: string | undefined;
    empresaAdmisionCodigoPostal?: string | undefined;
    empresaAdmisionLocalidad?: string | undefined;
    numeroDocumentoPCS?: string | undefined;
    numeroDocumentoEntregaPCS?: string | undefined;
    numeroDocumentoAdmisionPCS?: string | undefined;
    tipoEquipamientoId?: number | undefined;
    informacionDetectadaMercancia?: string | undefined;
    informacionDetectadaBulto?: string | undefined;
    codigoBarrasEntrega?: string | undefined;
    localizadorEntrega?: string | undefined;
    codigoBarrasAdmision?: string | undefined;
    localizadorAdmision?: string | undefined;
    temperatura?: number | undefined;
    tipoTemperatura?: string | undefined;
    tipoCodigoISOId?: number | undefined;
    refrigeradoISO?: boolean | undefined;
    conectarEnTerminal?: boolean | undefined;
    conectarEnCamion?: boolean | undefined;
    informacionDetectadaCodigoISO?: string | undefined;
    clasificacionContenedorId?: number | undefined;
    paralizacionTerminalId?: number | undefined;
    llenoEntrega?: boolean;
    llenoAdmision?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    clasificacionContenedor?: ClasificacionContenedorView;
    empresaAdmision?: EmpresaView;
    empresaEntrega?: EmpresaView;
    estadoAdmision?: EstadoViajeView;
    estadoEntrega?: EstadoViajeView;
    paralizacionTerminal?: ParalizacionTerminalView;
    tipoCodigoISO?: TipoCodigoISOView;
    tipoEquipamiento?: TipoEquipamientoView;
    viaje?: ViajeView;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;
    viajeEquipamientoPrecinto?: ViajeEquipamientoPrecintoView[] | undefined;

    constructor(data?: IViajeEquipamientoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guardarEmpresa = _data["guardarEmpresa"];
            this.tipoOperacionId = _data["tipoOperacionId"];
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.itemNumber = _data["itemNumber"];
            this.matriculaEquipamiento = _data["matriculaEquipamiento"];
            this.codigoISO = _data["codigoISO"];
            this.descripcionISO = _data["descripcionISO"];
            this.numeroBooking = _data["numeroBooking"];
            this.numeroBL = _data["numeroBL"];
            this.numeroExpOL = _data["numeroExpOL"];
            this.numeroDocumentoAsociado = _data["numeroDocumentoAsociado"];
            this.empresaEntregaId = _data["empresaEntregaId"];
            this.fechaSolicitadaEntrega = _data["fechaSolicitadaEntrega"] ? new Date(_data["fechaSolicitadaEntrega"].toString()) : <any>undefined;
            this.fechaConfirmacionEntrega = _data["fechaConfirmacionEntrega"] ? new Date(_data["fechaConfirmacionEntrega"].toString()) : <any>undefined;
            this.fechaEstimadaEntrega = _data["fechaEstimadaEntrega"] ? new Date(_data["fechaEstimadaEntrega"].toString()) : <any>undefined;
            this.estadoEntregaId = _data["estadoEntregaId"];
            this.empresaAdmisionId = _data["empresaAdmisionId"];
            this.fechaSolicitadaAdmision = _data["fechaSolicitadaAdmision"] ? new Date(_data["fechaSolicitadaAdmision"].toString()) : <any>undefined;
            this.fechaConfirmacionAdmision = _data["fechaConfirmacionAdmision"] ? new Date(_data["fechaConfirmacionAdmision"].toString()) : <any>undefined;
            this.fechaEstimadaAdmision = _data["fechaEstimadaAdmision"] ? new Date(_data["fechaEstimadaAdmision"].toString()) : <any>undefined;
            this.estadoAdmisionId = _data["estadoAdmisionId"];
            this.tara = _data["tara"];
            this.empresaEntregaCodigo = _data["empresaEntregaCodigo"];
            this.empresaEntregaNombre = _data["empresaEntregaNombre"];
            this.empresaEntregaNumeroDocumento = _data["empresaEntregaNumeroDocumento"];
            this.empresaEntregaDireccion = _data["empresaEntregaDireccion"];
            this.empresaEntregaCodigoPostal = _data["empresaEntregaCodigoPostal"];
            this.empresaEntregaLocalidad = _data["empresaEntregaLocalidad"];
            this.empresaAdmisionCodigo = _data["empresaAdmisionCodigo"];
            this.empresaAdmisionNombre = _data["empresaAdmisionNombre"];
            this.empresaAdmisionNumeroDocumento = _data["empresaAdmisionNumeroDocumento"];
            this.empresaAdmisionDireccion = _data["empresaAdmisionDireccion"];
            this.empresaAdmisionCodigoPostal = _data["empresaAdmisionCodigoPostal"];
            this.empresaAdmisionLocalidad = _data["empresaAdmisionLocalidad"];
            this.numeroDocumentoPCS = _data["numeroDocumentoPCS"];
            this.numeroDocumentoEntregaPCS = _data["numeroDocumentoEntregaPCS"];
            this.numeroDocumentoAdmisionPCS = _data["numeroDocumentoAdmisionPCS"];
            this.tipoEquipamientoId = _data["tipoEquipamientoId"];
            this.informacionDetectadaMercancia = _data["informacionDetectadaMercancia"];
            this.informacionDetectadaBulto = _data["informacionDetectadaBulto"];
            this.codigoBarrasEntrega = _data["codigoBarrasEntrega"];
            this.localizadorEntrega = _data["localizadorEntrega"];
            this.codigoBarrasAdmision = _data["codigoBarrasAdmision"];
            this.localizadorAdmision = _data["localizadorAdmision"];
            this.temperatura = _data["temperatura"];
            this.tipoTemperatura = _data["tipoTemperatura"];
            this.tipoCodigoISOId = _data["tipoCodigoISOId"];
            this.refrigeradoISO = _data["refrigeradoISO"];
            this.conectarEnTerminal = _data["conectarEnTerminal"];
            this.conectarEnCamion = _data["conectarEnCamion"];
            this.informacionDetectadaCodigoISO = _data["informacionDetectadaCodigoISO"];
            this.clasificacionContenedorId = _data["clasificacionContenedorId"];
            this.paralizacionTerminalId = _data["paralizacionTerminalId"];
            this.llenoEntrega = _data["llenoEntrega"];
            this.llenoAdmision = _data["llenoAdmision"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.clasificacionContenedor = _data["clasificacionContenedor"] ? ClasificacionContenedorView.fromJS(_data["clasificacionContenedor"]) : <any>undefined;
            this.empresaAdmision = _data["empresaAdmision"] ? EmpresaView.fromJS(_data["empresaAdmision"]) : <any>undefined;
            this.empresaEntrega = _data["empresaEntrega"] ? EmpresaView.fromJS(_data["empresaEntrega"]) : <any>undefined;
            this.estadoAdmision = _data["estadoAdmision"] ? EstadoViajeView.fromJS(_data["estadoAdmision"]) : <any>undefined;
            this.estadoEntrega = _data["estadoEntrega"] ? EstadoViajeView.fromJS(_data["estadoEntrega"]) : <any>undefined;
            this.paralizacionTerminal = _data["paralizacionTerminal"] ? ParalizacionTerminalView.fromJS(_data["paralizacionTerminal"]) : <any>undefined;
            this.tipoCodigoISO = _data["tipoCodigoISO"] ? TipoCodigoISOView.fromJS(_data["tipoCodigoISO"]) : <any>undefined;
            this.tipoEquipamiento = _data["tipoEquipamiento"] ? TipoEquipamientoView.fromJS(_data["tipoEquipamiento"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
            if (Array.isArray(_data["viajeEquipamientoMercancia"])) {
                this.viajeEquipamientoMercancia = [] as any;
                for (let item of _data["viajeEquipamientoMercancia"])
                    this.viajeEquipamientoMercancia!.push(ViajeEquipamientoMercanciaView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamientoPrecinto"])) {
                this.viajeEquipamientoPrecinto = [] as any;
                for (let item of _data["viajeEquipamientoPrecinto"])
                    this.viajeEquipamientoPrecinto!.push(ViajeEquipamientoPrecintoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViajeEquipamientoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeEquipamientoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guardarEmpresa"] = this.guardarEmpresa;
        data["tipoOperacionId"] = this.tipoOperacionId;
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["itemNumber"] = this.itemNumber;
        data["matriculaEquipamiento"] = this.matriculaEquipamiento;
        data["codigoISO"] = this.codigoISO;
        data["descripcionISO"] = this.descripcionISO;
        data["numeroBooking"] = this.numeroBooking;
        data["numeroBL"] = this.numeroBL;
        data["numeroExpOL"] = this.numeroExpOL;
        data["numeroDocumentoAsociado"] = this.numeroDocumentoAsociado;
        data["empresaEntregaId"] = this.empresaEntregaId;
        data["fechaSolicitadaEntrega"] = this.fechaSolicitadaEntrega ? this.fechaSolicitadaEntrega.toISOString() : <any>undefined;
        data["fechaConfirmacionEntrega"] = this.fechaConfirmacionEntrega ? this.fechaConfirmacionEntrega.toISOString() : <any>undefined;
        data["fechaEstimadaEntrega"] = this.fechaEstimadaEntrega ? this.fechaEstimadaEntrega.toISOString() : <any>undefined;
        data["estadoEntregaId"] = this.estadoEntregaId;
        data["empresaAdmisionId"] = this.empresaAdmisionId;
        data["fechaSolicitadaAdmision"] = this.fechaSolicitadaAdmision ? this.fechaSolicitadaAdmision.toISOString() : <any>undefined;
        data["fechaConfirmacionAdmision"] = this.fechaConfirmacionAdmision ? this.fechaConfirmacionAdmision.toISOString() : <any>undefined;
        data["fechaEstimadaAdmision"] = this.fechaEstimadaAdmision ? this.fechaEstimadaAdmision.toISOString() : <any>undefined;
        data["estadoAdmisionId"] = this.estadoAdmisionId;
        data["tara"] = this.tara;
        data["empresaEntregaCodigo"] = this.empresaEntregaCodigo;
        data["empresaEntregaNombre"] = this.empresaEntregaNombre;
        data["empresaEntregaNumeroDocumento"] = this.empresaEntregaNumeroDocumento;
        data["empresaEntregaDireccion"] = this.empresaEntregaDireccion;
        data["empresaEntregaCodigoPostal"] = this.empresaEntregaCodigoPostal;
        data["empresaEntregaLocalidad"] = this.empresaEntregaLocalidad;
        data["empresaAdmisionCodigo"] = this.empresaAdmisionCodigo;
        data["empresaAdmisionNombre"] = this.empresaAdmisionNombre;
        data["empresaAdmisionNumeroDocumento"] = this.empresaAdmisionNumeroDocumento;
        data["empresaAdmisionDireccion"] = this.empresaAdmisionDireccion;
        data["empresaAdmisionCodigoPostal"] = this.empresaAdmisionCodigoPostal;
        data["empresaAdmisionLocalidad"] = this.empresaAdmisionLocalidad;
        data["numeroDocumentoPCS"] = this.numeroDocumentoPCS;
        data["numeroDocumentoEntregaPCS"] = this.numeroDocumentoEntregaPCS;
        data["numeroDocumentoAdmisionPCS"] = this.numeroDocumentoAdmisionPCS;
        data["tipoEquipamientoId"] = this.tipoEquipamientoId;
        data["informacionDetectadaMercancia"] = this.informacionDetectadaMercancia;
        data["informacionDetectadaBulto"] = this.informacionDetectadaBulto;
        data["codigoBarrasEntrega"] = this.codigoBarrasEntrega;
        data["localizadorEntrega"] = this.localizadorEntrega;
        data["codigoBarrasAdmision"] = this.codigoBarrasAdmision;
        data["localizadorAdmision"] = this.localizadorAdmision;
        data["temperatura"] = this.temperatura;
        data["tipoTemperatura"] = this.tipoTemperatura;
        data["tipoCodigoISOId"] = this.tipoCodigoISOId;
        data["refrigeradoISO"] = this.refrigeradoISO;
        data["conectarEnTerminal"] = this.conectarEnTerminal;
        data["conectarEnCamion"] = this.conectarEnCamion;
        data["informacionDetectadaCodigoISO"] = this.informacionDetectadaCodigoISO;
        data["clasificacionContenedorId"] = this.clasificacionContenedorId;
        data["paralizacionTerminalId"] = this.paralizacionTerminalId;
        data["llenoEntrega"] = this.llenoEntrega;
        data["llenoAdmision"] = this.llenoAdmision;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["clasificacionContenedor"] = this.clasificacionContenedor ? this.clasificacionContenedor.toJSON() : <any>undefined;
        data["empresaAdmision"] = this.empresaAdmision ? this.empresaAdmision.toJSON() : <any>undefined;
        data["empresaEntrega"] = this.empresaEntrega ? this.empresaEntrega.toJSON() : <any>undefined;
        data["estadoAdmision"] = this.estadoAdmision ? this.estadoAdmision.toJSON() : <any>undefined;
        data["estadoEntrega"] = this.estadoEntrega ? this.estadoEntrega.toJSON() : <any>undefined;
        data["paralizacionTerminal"] = this.paralizacionTerminal ? this.paralizacionTerminal.toJSON() : <any>undefined;
        data["tipoCodigoISO"] = this.tipoCodigoISO ? this.tipoCodigoISO.toJSON() : <any>undefined;
        data["tipoEquipamiento"] = this.tipoEquipamiento ? this.tipoEquipamiento.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeEquipamientoMercancia)) {
            data["viajeEquipamientoMercancia"] = [];
            for (let item of this.viajeEquipamientoMercancia)
                data["viajeEquipamientoMercancia"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamientoPrecinto)) {
            data["viajeEquipamientoPrecinto"] = [];
            for (let item of this.viajeEquipamientoPrecinto)
                data["viajeEquipamientoPrecinto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IViajeEquipamientoView {
    guardarEmpresa?: boolean | undefined;
    tipoOperacionId?: number;
    id?: number;
    viajeId?: number;
    itemNumber?: string | undefined;
    matriculaEquipamiento?: string | undefined;
    codigoISO?: string | undefined;
    descripcionISO?: string | undefined;
    numeroBooking?: string | undefined;
    numeroBL?: string | undefined;
    numeroExpOL?: string | undefined;
    numeroDocumentoAsociado?: string | undefined;
    empresaEntregaId?: number | undefined;
    fechaSolicitadaEntrega?: Date | undefined;
    fechaConfirmacionEntrega?: Date | undefined;
    fechaEstimadaEntrega?: Date | undefined;
    estadoEntregaId?: number | undefined;
    empresaAdmisionId?: number | undefined;
    fechaSolicitadaAdmision?: Date | undefined;
    fechaConfirmacionAdmision?: Date | undefined;
    fechaEstimadaAdmision?: Date | undefined;
    estadoAdmisionId?: number | undefined;
    tara?: number | undefined;
    empresaEntregaCodigo?: string | undefined;
    empresaEntregaNombre?: string | undefined;
    empresaEntregaNumeroDocumento?: string | undefined;
    empresaEntregaDireccion?: string | undefined;
    empresaEntregaCodigoPostal?: string | undefined;
    empresaEntregaLocalidad?: string | undefined;
    empresaAdmisionCodigo?: string | undefined;
    empresaAdmisionNombre?: string | undefined;
    empresaAdmisionNumeroDocumento?: string | undefined;
    empresaAdmisionDireccion?: string | undefined;
    empresaAdmisionCodigoPostal?: string | undefined;
    empresaAdmisionLocalidad?: string | undefined;
    numeroDocumentoPCS?: string | undefined;
    numeroDocumentoEntregaPCS?: string | undefined;
    numeroDocumentoAdmisionPCS?: string | undefined;
    tipoEquipamientoId?: number | undefined;
    informacionDetectadaMercancia?: string | undefined;
    informacionDetectadaBulto?: string | undefined;
    codigoBarrasEntrega?: string | undefined;
    localizadorEntrega?: string | undefined;
    codigoBarrasAdmision?: string | undefined;
    localizadorAdmision?: string | undefined;
    temperatura?: number | undefined;
    tipoTemperatura?: string | undefined;
    tipoCodigoISOId?: number | undefined;
    refrigeradoISO?: boolean | undefined;
    conectarEnTerminal?: boolean | undefined;
    conectarEnCamion?: boolean | undefined;
    informacionDetectadaCodigoISO?: string | undefined;
    clasificacionContenedorId?: number | undefined;
    paralizacionTerminalId?: number | undefined;
    llenoEntrega?: boolean;
    llenoAdmision?: boolean;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    clasificacionContenedor?: ClasificacionContenedorView;
    empresaAdmision?: EmpresaView;
    empresaEntrega?: EmpresaView;
    estadoAdmision?: EstadoViajeView;
    estadoEntrega?: EstadoViajeView;
    paralizacionTerminal?: ParalizacionTerminalView;
    tipoCodigoISO?: TipoCodigoISOView;
    tipoEquipamiento?: TipoEquipamientoView;
    viaje?: ViajeView;
    viajeEquipamientoMercancia?: ViajeEquipamientoMercanciaView[] | undefined;
    viajeEquipamientoPrecinto?: ViajeEquipamientoPrecintoView[] | undefined;
}

export class ViajeObservacionView implements IViajeObservacionView {
    id?: number;
    viajeId?: number;
    tipoObservacionId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoObservacion?: TipoObservacionView;
    viaje?: ViajeView;

    constructor(data?: IViajeObservacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.tipoObservacionId = _data["tipoObservacionId"];
            this.descripcion = _data["descripcion"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoObservacion = _data["tipoObservacion"] ? TipoObservacionView.fromJS(_data["tipoObservacion"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeObservacionView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeObservacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["tipoObservacionId"] = this.tipoObservacionId;
        data["descripcion"] = this.descripcion;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoObservacion"] = this.tipoObservacion ? this.tipoObservacion.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeObservacionView {
    id?: number;
    viajeId?: number;
    tipoObservacionId?: number;
    descripcion?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoObservacion?: TipoObservacionView;
    viaje?: ViajeView;
}

export class ViajePuertoView implements IViajePuertoView {
    id?: number;
    viajeId?: number;
    tipoPuertoId?: number | undefined;
    codigoPuerto?: string | undefined;
    nombrePuerto?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoPuerto?: TipoPuertoView;
    viaje?: ViajeView;

    constructor(data?: IViajePuertoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.tipoPuertoId = _data["tipoPuertoId"];
            this.codigoPuerto = _data["codigoPuerto"];
            this.nombrePuerto = _data["nombrePuerto"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.tipoPuerto = _data["tipoPuerto"] ? TipoPuertoView.fromJS(_data["tipoPuerto"]) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajePuertoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajePuertoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["tipoPuertoId"] = this.tipoPuertoId;
        data["codigoPuerto"] = this.codigoPuerto;
        data["nombrePuerto"] = this.nombrePuerto;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["tipoPuerto"] = this.tipoPuerto ? this.tipoPuerto.toJSON() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajePuertoView {
    id?: number;
    viajeId?: number;
    tipoPuertoId?: number | undefined;
    codigoPuerto?: string | undefined;
    nombrePuerto?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    tipoPuerto?: TipoPuertoView;
    viaje?: ViajeView;
}

export class ViajeRecargoView implements IViajeRecargoView {
    id?: number;
    viajeId?: number;
    idExtRecargo?: number;
    recargo?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viaje?: ViajeView;

    constructor(data?: IViajeRecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.idExtRecargo = _data["idExtRecargo"];
            this.recargo = _data["recargo"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeRecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeRecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["idExtRecargo"] = this.idExtRecargo;
        data["recargo"] = this.recargo;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeRecargoView {
    id?: number;
    viajeId?: number;
    idExtRecargo?: number;
    recargo?: string | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viaje?: ViajeView;
}

export class ViajeTarifaView implements IViajeTarifaView {
    id?: number;
    viajeId?: number;
    idExtTipoTarifa?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    paralizacionTerminal?: ParalizacionTerminalView[] | undefined;
    viaje?: ViajeView;
    viajeTarificacion?: ViajeTarificacionView[] | undefined;

    constructor(data?: IViajeTarifaView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeId = _data["viajeId"];
            this.idExtTipoTarifa = _data["idExtTipoTarifa"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["paralizacionTerminal"])) {
                this.paralizacionTerminal = [] as any;
                for (let item of _data["paralizacionTerminal"])
                    this.paralizacionTerminal!.push(ParalizacionTerminalView.fromJS(item));
            }
            this.viaje = _data["viaje"] ? ViajeView.fromJS(_data["viaje"]) : <any>undefined;
            if (Array.isArray(_data["viajeTarificacion"])) {
                this.viajeTarificacion = [] as any;
                for (let item of _data["viajeTarificacion"])
                    this.viajeTarificacion!.push(ViajeTarificacionView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViajeTarifaView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeTarifaView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeId"] = this.viajeId;
        data["idExtTipoTarifa"] = this.idExtTipoTarifa;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.paralizacionTerminal)) {
            data["paralizacionTerminal"] = [];
            for (let item of this.paralizacionTerminal)
                data["paralizacionTerminal"].push(item.toJSON());
        }
        data["viaje"] = this.viaje ? this.viaje.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeTarificacion)) {
            data["viajeTarificacion"] = [];
            for (let item of this.viajeTarificacion)
                data["viajeTarificacion"].push(item.toJSON());
        }
        return data;
    }
}

export interface IViajeTarifaView {
    id?: number;
    viajeId?: number;
    idExtTipoTarifa?: number | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    paralizacionTerminal?: ParalizacionTerminalView[] | undefined;
    viaje?: ViajeView;
    viajeTarificacion?: ViajeTarificacionView[] | undefined;
}

export class ViajeTarificacionConceptoView implements IViajeTarificacionConceptoView {
    id?: number;
    viajeTarificacionId?: number;
    idExtTarifaCalculoDetalle?: number;
    condicionesAplicadasConcepto?: string | undefined;
    precioBaseConceptos?: number;
    cantidadConcepto?: number;
    importeTotalConcepto?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeTarificacion?: ViajeTarificacionView;

    constructor(data?: IViajeTarificacionConceptoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeTarificacionId = _data["viajeTarificacionId"];
            this.idExtTarifaCalculoDetalle = _data["idExtTarifaCalculoDetalle"];
            this.condicionesAplicadasConcepto = _data["condicionesAplicadasConcepto"];
            this.precioBaseConceptos = _data["precioBaseConceptos"];
            this.cantidadConcepto = _data["cantidadConcepto"];
            this.importeTotalConcepto = _data["importeTotalConcepto"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.viajeTarificacion = _data["viajeTarificacion"] ? ViajeTarificacionView.fromJS(_data["viajeTarificacion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeTarificacionConceptoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeTarificacionConceptoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeTarificacionId"] = this.viajeTarificacionId;
        data["idExtTarifaCalculoDetalle"] = this.idExtTarifaCalculoDetalle;
        data["condicionesAplicadasConcepto"] = this.condicionesAplicadasConcepto;
        data["precioBaseConceptos"] = this.precioBaseConceptos;
        data["cantidadConcepto"] = this.cantidadConcepto;
        data["importeTotalConcepto"] = this.importeTotalConcepto;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["viajeTarificacion"] = this.viajeTarificacion ? this.viajeTarificacion.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeTarificacionConceptoView {
    id?: number;
    viajeTarificacionId?: number;
    idExtTarifaCalculoDetalle?: number;
    condicionesAplicadasConcepto?: string | undefined;
    precioBaseConceptos?: number;
    cantidadConcepto?: number;
    importeTotalConcepto?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeTarificacion?: ViajeTarificacionView;
}

export class ViajeTarificacionRecargoView implements IViajeTarificacionRecargoView {
    id?: number;
    viajeTarificacionId?: number;
    idExtTarifaRecargoDetalle?: number | undefined;
    idExtRecargo?: number;
    condicionesAplicadasRecargo?: string | undefined;
    recargo?: string | undefined;
    importeTarifaRecargo?: number;
    cantidadRecargo?: number;
    importeTotalRecargo?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeTarificacion?: ViajeTarificacionView;

    constructor(data?: IViajeTarificacionRecargoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeTarificacionId = _data["viajeTarificacionId"];
            this.idExtTarifaRecargoDetalle = _data["idExtTarifaRecargoDetalle"];
            this.idExtRecargo = _data["idExtRecargo"];
            this.condicionesAplicadasRecargo = _data["condicionesAplicadasRecargo"];
            this.recargo = _data["recargo"];
            this.importeTarifaRecargo = _data["importeTarifaRecargo"];
            this.cantidadRecargo = _data["cantidadRecargo"];
            this.importeTotalRecargo = _data["importeTotalRecargo"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.viajeTarificacion = _data["viajeTarificacion"] ? ViajeTarificacionView.fromJS(_data["viajeTarificacion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ViajeTarificacionRecargoView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeTarificacionRecargoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeTarificacionId"] = this.viajeTarificacionId;
        data["idExtTarifaRecargoDetalle"] = this.idExtTarifaRecargoDetalle;
        data["idExtRecargo"] = this.idExtRecargo;
        data["condicionesAplicadasRecargo"] = this.condicionesAplicadasRecargo;
        data["recargo"] = this.recargo;
        data["importeTarifaRecargo"] = this.importeTarifaRecargo;
        data["cantidadRecargo"] = this.cantidadRecargo;
        data["importeTotalRecargo"] = this.importeTotalRecargo;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["viajeTarificacion"] = this.viajeTarificacion ? this.viajeTarificacion.toJSON() : <any>undefined;
        return data;
    }
}

export interface IViajeTarificacionRecargoView {
    id?: number;
    viajeTarificacionId?: number;
    idExtTarifaRecargoDetalle?: number | undefined;
    idExtRecargo?: number;
    condicionesAplicadasRecargo?: string | undefined;
    recargo?: string | undefined;
    importeTarifaRecargo?: number;
    cantidadRecargo?: number;
    importeTotalRecargo?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    viajeTarificacion?: ViajeTarificacionView;
}

export class ViajeTarificacionView implements IViajeTarificacionView {
    id?: number;
    viajeTarifaId?: number;
    estadoTarifaViajeId?: number;
    esImporteManual?: boolean;
    idExtTarifa?: number | undefined;
    idExtModoCalculoAplicado?: number | undefined;
    modoCalculoAplicado?: string | undefined;
    precioBaseConceptos?: number;
    importeTotalConcepto?: number;
    importeTotalRecargos?: number;
    importeTotal?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    estadoTarifaViaje?: EstadoTarifaViajeView;
    viajeTarifa?: ViajeTarifaView;
    viajeTarificacionConcepto?: ViajeTarificacionConceptoView[] | undefined;
    viajeTarificacionRecargo?: ViajeTarificacionRecargoView[] | undefined;

    constructor(data?: IViajeTarificacionView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.viajeTarifaId = _data["viajeTarifaId"];
            this.estadoTarifaViajeId = _data["estadoTarifaViajeId"];
            this.esImporteManual = _data["esImporteManual"];
            this.idExtTarifa = _data["idExtTarifa"];
            this.idExtModoCalculoAplicado = _data["idExtModoCalculoAplicado"];
            this.modoCalculoAplicado = _data["modoCalculoAplicado"];
            this.precioBaseConceptos = _data["precioBaseConceptos"];
            this.importeTotalConcepto = _data["importeTotalConcepto"];
            this.importeTotalRecargos = _data["importeTotalRecargos"];
            this.importeTotal = _data["importeTotal"];
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.estadoTarifaViaje = _data["estadoTarifaViaje"] ? EstadoTarifaViajeView.fromJS(_data["estadoTarifaViaje"]) : <any>undefined;
            this.viajeTarifa = _data["viajeTarifa"] ? ViajeTarifaView.fromJS(_data["viajeTarifa"]) : <any>undefined;
            if (Array.isArray(_data["viajeTarificacionConcepto"])) {
                this.viajeTarificacionConcepto = [] as any;
                for (let item of _data["viajeTarificacionConcepto"])
                    this.viajeTarificacionConcepto!.push(ViajeTarificacionConceptoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeTarificacionRecargo"])) {
                this.viajeTarificacionRecargo = [] as any;
                for (let item of _data["viajeTarificacionRecargo"])
                    this.viajeTarificacionRecargo!.push(ViajeTarificacionRecargoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViajeTarificacionView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeTarificacionView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["viajeTarifaId"] = this.viajeTarifaId;
        data["estadoTarifaViajeId"] = this.estadoTarifaViajeId;
        data["esImporteManual"] = this.esImporteManual;
        data["idExtTarifa"] = this.idExtTarifa;
        data["idExtModoCalculoAplicado"] = this.idExtModoCalculoAplicado;
        data["modoCalculoAplicado"] = this.modoCalculoAplicado;
        data["precioBaseConceptos"] = this.precioBaseConceptos;
        data["importeTotalConcepto"] = this.importeTotalConcepto;
        data["importeTotalRecargos"] = this.importeTotalRecargos;
        data["importeTotal"] = this.importeTotal;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["estadoTarifaViaje"] = this.estadoTarifaViaje ? this.estadoTarifaViaje.toJSON() : <any>undefined;
        data["viajeTarifa"] = this.viajeTarifa ? this.viajeTarifa.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeTarificacionConcepto)) {
            data["viajeTarificacionConcepto"] = [];
            for (let item of this.viajeTarificacionConcepto)
                data["viajeTarificacionConcepto"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeTarificacionRecargo)) {
            data["viajeTarificacionRecargo"] = [];
            for (let item of this.viajeTarificacionRecargo)
                data["viajeTarificacionRecargo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IViajeTarificacionView {
    id?: number;
    viajeTarifaId?: number;
    estadoTarifaViajeId?: number;
    esImporteManual?: boolean;
    idExtTarifa?: number | undefined;
    idExtModoCalculoAplicado?: number | undefined;
    modoCalculoAplicado?: string | undefined;
    precioBaseConceptos?: number;
    importeTotalConcepto?: number;
    importeTotalRecargos?: number;
    importeTotal?: number;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    estadoTarifaViaje?: EstadoTarifaViajeView;
    viajeTarifa?: ViajeTarifaView;
    viajeTarificacionConcepto?: ViajeTarificacionConceptoView[] | undefined;
    viajeTarificacionRecargo?: ViajeTarificacionRecargoView[] | undefined;
}

export class ViajeView implements IViajeView {
    intercambio?: IntercambioView;
    securityCompany?: SecurityCompanyView;
    estadoCotizacion?: number | undefined;
    estadoLiquidacion?: number | undefined;
    id?: number;
    modoCreacionId?: number | undefined;
    numeroViaje?: string | undefined;
    estadoViajeId?: number;
    tipoOperacionId?: number;
    fecha?: Date;
    securityCompanyId?: number | undefined;
    localidadOrigenId?: number;
    clienteId?: number | undefined;
    informacionDetectadaCliente?: string | undefined;
    nombreCliente?: string | undefined;
    numeroDocumentoCliente?: string | undefined;
    referenciaCliente?: string | undefined;
    codigoNaviera?: string | undefined;
    nombreNaviera?: string | undefined;
    codigoLineaMaritimaEntrega?: string | undefined;
    descripcionLineaMaritimaEntrega?: string | undefined;
    codigoLineaMaritimaAdmision?: string | undefined;
    descripcionLineaMaritimaAdmision?: string | undefined;
    canceladoManual?: boolean;
    registroDocumentoId?: number | undefined;
    workOrder?: string | undefined;
    proveedor?: string | undefined;
    esCombinado?: boolean;
    esCombinadoObservacion?: string | undefined;
    fechaTraspaso?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    cliente?: EmpresaView;
    estadoViaje?: EstadoViajeView;
    localidadOrigen?: LocalidadView;
    mensaje?: MensajeView[] | undefined;
    modoCreacion?: ModoCreacionView;
    registroDocumento?: RegistroDocumentoView;
    tipoOperacion?: TipoOperacionView;
    viajeAgente?: ViajeAgenteView[] | undefined;
    viajeBuque?: ViajeBuqueView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
    viajeObservacion?: ViajeObservacionView[] | undefined;
    viajePuerto?: ViajePuertoView[] | undefined;
    viajeRecargo?: ViajeRecargoView[] | undefined;
    viajeTarifa?: ViajeTarifaView[] | undefined;

    constructor(data?: IViajeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.intercambio = _data["intercambio"] ? IntercambioView.fromJS(_data["intercambio"]) : <any>undefined;
            this.securityCompany = _data["securityCompany"] ? SecurityCompanyView.fromJS(_data["securityCompany"]) : <any>undefined;
            this.estadoCotizacion = _data["estadoCotizacion"];
            this.estadoLiquidacion = _data["estadoLiquidacion"];
            this.id = _data["id"];
            this.modoCreacionId = _data["modoCreacionId"];
            this.numeroViaje = _data["numeroViaje"];
            this.estadoViajeId = _data["estadoViajeId"];
            this.tipoOperacionId = _data["tipoOperacionId"];
            this.fecha = _data["fecha"] ? new Date(_data["fecha"].toString()) : <any>undefined;
            this.securityCompanyId = _data["securityCompanyId"];
            this.localidadOrigenId = _data["localidadOrigenId"];
            this.clienteId = _data["clienteId"];
            this.informacionDetectadaCliente = _data["informacionDetectadaCliente"];
            this.nombreCliente = _data["nombreCliente"];
            this.numeroDocumentoCliente = _data["numeroDocumentoCliente"];
            this.referenciaCliente = _data["referenciaCliente"];
            this.codigoNaviera = _data["codigoNaviera"];
            this.nombreNaviera = _data["nombreNaviera"];
            this.codigoLineaMaritimaEntrega = _data["codigoLineaMaritimaEntrega"];
            this.descripcionLineaMaritimaEntrega = _data["descripcionLineaMaritimaEntrega"];
            this.codigoLineaMaritimaAdmision = _data["codigoLineaMaritimaAdmision"];
            this.descripcionLineaMaritimaAdmision = _data["descripcionLineaMaritimaAdmision"];
            this.canceladoManual = _data["canceladoManual"];
            this.registroDocumentoId = _data["registroDocumentoId"];
            this.workOrder = _data["workOrder"];
            this.proveedor = _data["proveedor"];
            this.esCombinado = _data["esCombinado"];
            this.esCombinadoObservacion = _data["esCombinadoObservacion"];
            this.fechaTraspaso = _data["fechaTraspaso"] ? new Date(_data["fechaTraspaso"].toString()) : <any>undefined;
            this.auditCreationUser = _data["auditCreationUser"];
            this.auditModificationUser = _data["auditModificationUser"];
            this.auditCreationDate = _data["auditCreationDate"] ? new Date(_data["auditCreationDate"].toString()) : <any>undefined;
            this.auditModificationDate = _data["auditModificationDate"] ? new Date(_data["auditModificationDate"].toString()) : <any>undefined;
            this.auditDeletionDate = _data["auditDeletionDate"] ? new Date(_data["auditDeletionDate"].toString()) : <any>undefined;
            this.cliente = _data["cliente"] ? EmpresaView.fromJS(_data["cliente"]) : <any>undefined;
            this.estadoViaje = _data["estadoViaje"] ? EstadoViajeView.fromJS(_data["estadoViaje"]) : <any>undefined;
            this.localidadOrigen = _data["localidadOrigen"] ? LocalidadView.fromJS(_data["localidadOrigen"]) : <any>undefined;
            if (Array.isArray(_data["mensaje"])) {
                this.mensaje = [] as any;
                for (let item of _data["mensaje"])
                    this.mensaje!.push(MensajeView.fromJS(item));
            }
            this.modoCreacion = _data["modoCreacion"] ? ModoCreacionView.fromJS(_data["modoCreacion"]) : <any>undefined;
            this.registroDocumento = _data["registroDocumento"] ? RegistroDocumentoView.fromJS(_data["registroDocumento"]) : <any>undefined;
            this.tipoOperacion = _data["tipoOperacion"] ? TipoOperacionView.fromJS(_data["tipoOperacion"]) : <any>undefined;
            if (Array.isArray(_data["viajeAgente"])) {
                this.viajeAgente = [] as any;
                for (let item of _data["viajeAgente"])
                    this.viajeAgente!.push(ViajeAgenteView.fromJS(item));
            }
            if (Array.isArray(_data["viajeBuque"])) {
                this.viajeBuque = [] as any;
                for (let item of _data["viajeBuque"])
                    this.viajeBuque!.push(ViajeBuqueView.fromJS(item));
            }
            if (Array.isArray(_data["viajeCargador"])) {
                this.viajeCargador = [] as any;
                for (let item of _data["viajeCargador"])
                    this.viajeCargador!.push(ViajeCargadorView.fromJS(item));
            }
            if (Array.isArray(_data["viajeConductorVehiculo"])) {
                this.viajeConductorVehiculo = [] as any;
                for (let item of _data["viajeConductorVehiculo"])
                    this.viajeConductorVehiculo!.push(ViajeConductorVehiculoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeEquipamiento"])) {
                this.viajeEquipamiento = [] as any;
                for (let item of _data["viajeEquipamiento"])
                    this.viajeEquipamiento!.push(ViajeEquipamientoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeObservacion"])) {
                this.viajeObservacion = [] as any;
                for (let item of _data["viajeObservacion"])
                    this.viajeObservacion!.push(ViajeObservacionView.fromJS(item));
            }
            if (Array.isArray(_data["viajePuerto"])) {
                this.viajePuerto = [] as any;
                for (let item of _data["viajePuerto"])
                    this.viajePuerto!.push(ViajePuertoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeRecargo"])) {
                this.viajeRecargo = [] as any;
                for (let item of _data["viajeRecargo"])
                    this.viajeRecargo!.push(ViajeRecargoView.fromJS(item));
            }
            if (Array.isArray(_data["viajeTarifa"])) {
                this.viajeTarifa = [] as any;
                for (let item of _data["viajeTarifa"])
                    this.viajeTarifa!.push(ViajeTarifaView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ViajeView {
        data = typeof data === 'object' ? data : {};
        let result = new ViajeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["intercambio"] = this.intercambio ? this.intercambio.toJSON() : <any>undefined;
        data["securityCompany"] = this.securityCompany ? this.securityCompany.toJSON() : <any>undefined;
        data["estadoCotizacion"] = this.estadoCotizacion;
        data["estadoLiquidacion"] = this.estadoLiquidacion;
        data["id"] = this.id;
        data["modoCreacionId"] = this.modoCreacionId;
        data["numeroViaje"] = this.numeroViaje;
        data["estadoViajeId"] = this.estadoViajeId;
        data["tipoOperacionId"] = this.tipoOperacionId;
        data["fecha"] = this.fecha ? this.fecha.toISOString() : <any>undefined;
        data["securityCompanyId"] = this.securityCompanyId;
        data["localidadOrigenId"] = this.localidadOrigenId;
        data["clienteId"] = this.clienteId;
        data["informacionDetectadaCliente"] = this.informacionDetectadaCliente;
        data["nombreCliente"] = this.nombreCliente;
        data["numeroDocumentoCliente"] = this.numeroDocumentoCliente;
        data["referenciaCliente"] = this.referenciaCliente;
        data["codigoNaviera"] = this.codigoNaviera;
        data["nombreNaviera"] = this.nombreNaviera;
        data["codigoLineaMaritimaEntrega"] = this.codigoLineaMaritimaEntrega;
        data["descripcionLineaMaritimaEntrega"] = this.descripcionLineaMaritimaEntrega;
        data["codigoLineaMaritimaAdmision"] = this.codigoLineaMaritimaAdmision;
        data["descripcionLineaMaritimaAdmision"] = this.descripcionLineaMaritimaAdmision;
        data["canceladoManual"] = this.canceladoManual;
        data["registroDocumentoId"] = this.registroDocumentoId;
        data["workOrder"] = this.workOrder;
        data["proveedor"] = this.proveedor;
        data["esCombinado"] = this.esCombinado;
        data["esCombinadoObservacion"] = this.esCombinadoObservacion;
        data["fechaTraspaso"] = this.fechaTraspaso ? this.fechaTraspaso.toISOString() : <any>undefined;
        data["auditCreationUser"] = this.auditCreationUser;
        data["auditModificationUser"] = this.auditModificationUser;
        data["auditCreationDate"] = this.auditCreationDate ? this.auditCreationDate.toISOString() : <any>undefined;
        data["auditModificationDate"] = this.auditModificationDate ? this.auditModificationDate.toISOString() : <any>undefined;
        data["auditDeletionDate"] = this.auditDeletionDate ? this.auditDeletionDate.toISOString() : <any>undefined;
        data["cliente"] = this.cliente ? this.cliente.toJSON() : <any>undefined;
        data["estadoViaje"] = this.estadoViaje ? this.estadoViaje.toJSON() : <any>undefined;
        data["localidadOrigen"] = this.localidadOrigen ? this.localidadOrigen.toJSON() : <any>undefined;
        if (Array.isArray(this.mensaje)) {
            data["mensaje"] = [];
            for (let item of this.mensaje)
                data["mensaje"].push(item.toJSON());
        }
        data["modoCreacion"] = this.modoCreacion ? this.modoCreacion.toJSON() : <any>undefined;
        data["registroDocumento"] = this.registroDocumento ? this.registroDocumento.toJSON() : <any>undefined;
        data["tipoOperacion"] = this.tipoOperacion ? this.tipoOperacion.toJSON() : <any>undefined;
        if (Array.isArray(this.viajeAgente)) {
            data["viajeAgente"] = [];
            for (let item of this.viajeAgente)
                data["viajeAgente"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeBuque)) {
            data["viajeBuque"] = [];
            for (let item of this.viajeBuque)
                data["viajeBuque"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeCargador)) {
            data["viajeCargador"] = [];
            for (let item of this.viajeCargador)
                data["viajeCargador"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeConductorVehiculo)) {
            data["viajeConductorVehiculo"] = [];
            for (let item of this.viajeConductorVehiculo)
                data["viajeConductorVehiculo"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeEquipamiento)) {
            data["viajeEquipamiento"] = [];
            for (let item of this.viajeEquipamiento)
                data["viajeEquipamiento"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeObservacion)) {
            data["viajeObservacion"] = [];
            for (let item of this.viajeObservacion)
                data["viajeObservacion"].push(item.toJSON());
        }
        if (Array.isArray(this.viajePuerto)) {
            data["viajePuerto"] = [];
            for (let item of this.viajePuerto)
                data["viajePuerto"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeRecargo)) {
            data["viajeRecargo"] = [];
            for (let item of this.viajeRecargo)
                data["viajeRecargo"].push(item.toJSON());
        }
        if (Array.isArray(this.viajeTarifa)) {
            data["viajeTarifa"] = [];
            for (let item of this.viajeTarifa)
                data["viajeTarifa"].push(item.toJSON());
        }
        return data;
    }
}

export interface IViajeView {
    intercambio?: IntercambioView;
    securityCompany?: SecurityCompanyView;
    estadoCotizacion?: number | undefined;
    estadoLiquidacion?: number | undefined;
    id?: number;
    modoCreacionId?: number | undefined;
    numeroViaje?: string | undefined;
    estadoViajeId?: number;
    tipoOperacionId?: number;
    fecha?: Date;
    securityCompanyId?: number | undefined;
    localidadOrigenId?: number;
    clienteId?: number | undefined;
    informacionDetectadaCliente?: string | undefined;
    nombreCliente?: string | undefined;
    numeroDocumentoCliente?: string | undefined;
    referenciaCliente?: string | undefined;
    codigoNaviera?: string | undefined;
    nombreNaviera?: string | undefined;
    codigoLineaMaritimaEntrega?: string | undefined;
    descripcionLineaMaritimaEntrega?: string | undefined;
    codigoLineaMaritimaAdmision?: string | undefined;
    descripcionLineaMaritimaAdmision?: string | undefined;
    canceladoManual?: boolean;
    registroDocumentoId?: number | undefined;
    workOrder?: string | undefined;
    proveedor?: string | undefined;
    esCombinado?: boolean;
    esCombinadoObservacion?: string | undefined;
    fechaTraspaso?: Date | undefined;
    auditCreationUser?: string | undefined;
    auditModificationUser?: string | undefined;
    auditCreationDate?: Date | undefined;
    auditModificationDate?: Date | undefined;
    auditDeletionDate?: Date | undefined;
    cliente?: EmpresaView;
    estadoViaje?: EstadoViajeView;
    localidadOrigen?: LocalidadView;
    mensaje?: MensajeView[] | undefined;
    modoCreacion?: ModoCreacionView;
    registroDocumento?: RegistroDocumentoView;
    tipoOperacion?: TipoOperacionView;
    viajeAgente?: ViajeAgenteView[] | undefined;
    viajeBuque?: ViajeBuqueView[] | undefined;
    viajeCargador?: ViajeCargadorView[] | undefined;
    viajeConductorVehiculo?: ViajeConductorVehiculoView[] | undefined;
    viajeEquipamiento?: ViajeEquipamientoView[] | undefined;
    viajeObservacion?: ViajeObservacionView[] | undefined;
    viajePuerto?: ViajePuertoView[] | undefined;
    viajeRecargo?: ViajeRecargoView[] | undefined;
    viajeTarifa?: ViajeTarifaView[] | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}